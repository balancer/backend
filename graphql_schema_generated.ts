import { gql } from 'apollo-server-express';
export const schema = gql`
    #
    # THIS FILE IS AUTOGENERATED â€” DO NOT EDIT IT
    #

    scalar AmountHumanReadable

    scalar BigDecimal

    scalar BigInt

    scalar Bytes

    scalar Date

    type GqlBalancePoolAprItem {
        apr: GqlPoolAprValue!
        id: ID!
        subItems: [GqlBalancePoolAprSubItem!]
        title: String!
    }

    type GqlBalancePoolAprSubItem {
        apr: GqlPoolAprValue!
        id: ID!
        title: String!
    }

    scalar GqlBigNumber

    enum GqlChain {
        ARBITRUM
        AVALANCHE
        BASE
        FANTOM
        FRAXTAL
        GNOSIS
        MAINNET
        MODE
        OPTIMISM
        POLYGON
        SEPOLIA
        ZKEVM
    }

    type GqlContentNewsItem {
        discussionUrl: String
        id: ID!
        image: String
        source: GqlContentNewsItemSource!
        text: String!
        timestamp: String!
        url: String!
    }

    enum GqlContentNewsItemSource {
        discord
        medium
        twitter
    }

    type GqlFeaturePoolGroupItemExternalLink {
        buttonText: String!
        buttonUrl: String!
        id: ID!
        image: String!
    }

    """
    Configuration options for SOR V2
    """
    input GqlGraphTraversalConfigInput {
        """
        Max number of paths to return (can be less)

        Default: 5
        """
        approxPathsToReturn: Int

        """
        The max hops in a path.

        Default: 6
        """
        maxDepth: Int

        """
        Limit non boosted hop tokens in a boosted path.

        Default: 2
        """
        maxNonBoostedHopTokensInBoostedPath: Int

        """
        Limit of "non-boosted" pools for efficiency.

        Default: 6
        """
        maxNonBoostedPathDepth: Int
        poolIdsToInclude: [String]
    }

    type GqlHistoricalTokenPrice {
        address: String!
        chain: GqlChain!
        prices: [GqlHistoricalTokenPriceEntry!]!
    }

    type GqlHistoricalTokenPriceEntry {
        price: Float!
        timestamp: String!
        updatedAt: Int!
        updatedBy: String
    }

    type GqlLatestSyncedBlocks {
        poolSyncBlock: BigInt!
        userStakeSyncBlock: BigInt!
        userWalletSyncBlock: BigInt!
    }

    """
    All info on the nested pool if the token is a BPT. It will only support 1 level of nesting.
    """
    type GqlNestedPool {
        """
        Address of the pool.
        """
        address: Bytes!

        """
        Price rate of the Balancer Pool Token (BPT).
        """
        bptPriceRate: BigDecimal!

        """
        Timestamp of when the pool was created.
        """
        createTime: Int!

        """
        Address of the factory contract that created the pool, if applicable.
        """
        factory: Bytes

        """
        Unique identifier of the pool.
        """
        id: ID!

        """
        Name of the pool.
        """
        name: String!

        """
        Total liquidity of the parent pool in the nested pool in USD.
        """
        nestedLiquidity: BigDecimal!

        """
        Percentage of the parents pool shares inside the nested pool.
        """
        nestedPercentage: BigDecimal!

        """
        Number of shares of the parent pool in the nested pool.
        """
        nestedShares: BigDecimal!

        """
        Address of the pool's owner.
        """
        owner: Bytes!

        """
        Fee charged for swapping tokens in the pool as %. 0.01 -> 0.01%
        """
        swapFee: BigDecimal!

        """
        Symbol of the pool.
        """
        symbol: String!

        """
        List of all tokens in the pool.
        """
        tokens: [GqlPoolTokenDetail!]!

        """
        Total liquidity in the pool in USD.
        """
        totalLiquidity: BigDecimal!

        """
        Total number of shares in the pool.
        """
        totalShares: BigDecimal!

        """
        Type of the pool.
        """
        type: GqlPoolType!

        """
        Version of the pool.
        """
        version: Int!
    }

    type GqlPoolAddRemoveEventV3 implements GqlPoolEvent {
        blockNumber: Int!
        blockTimestamp: Int!
        chain: GqlChain!
        id: ID!
        logIndex: Int!
        poolId: String!
        sender: String!
        timestamp: Int!
        tokens: [GqlPoolEventAmount!]!
        tx: String!
        type: GqlPoolEventType!
        userAddress: String!
        valueUSD: Float!
    }

    type GqlPoolApr {
        apr: GqlPoolAprValue!
        hasRewardApr: Boolean!
        items: [GqlBalancePoolAprItem!]!
        nativeRewardApr: GqlPoolAprValue!
        swapApr: BigDecimal!
        thirdPartyApr: GqlPoolAprValue!
    }

    """
    All APRs for a pool
    """
    type GqlPoolAprItem {
        """
        The APR value in % -> 0.2 = 0.2%
        """
        apr: Float!

        """
        The id of the APR item
        """
        id: ID!

        """
        The title of the APR item, a human readable form
        """
        title: String!

        """
        Specific type of this APR
        """
        type: GqlPoolAprItemType!
    }

    """
    Enum representing the different types of the APR in a pool.
    """
    enum GqlPoolAprItemType {
        """
        APR that pools earns when BPT is staked on AURA.
        """
        AURA

        """
        Represents the yield from an IB (Interest-Bearing) asset APR in a pool.
        """
        IB_YIELD

        """
        APR in a pool that can be earned through locking, i.e. veBAL
        """
        LOCKING

        """
        Rewards distributed by merkl.xyz
        """
        MERKL

        """
        Represents if the APR items comes from a nested pool.
        """
        NESTED

        """
        Staking reward APR in a pool, i.e. BAL or BEETS.
        """
        STAKING

        """
        APR boost that can be earned, i.e. via veBAL or maBEETS.
        """
        STAKING_BOOST

        """
        Cow AMM specific APR
        """
        SURPLUS

        """
        Represents the swap fee APR in a pool.
        """
        SWAP_FEE

        """
        APR that can be earned thourgh voting, i.e. gauge votes
        """
        VOTING
    }

    type GqlPoolAprRange {
        max: BigDecimal!
        min: BigDecimal!
    }

    type GqlPoolAprTotal {
        total: BigDecimal!
    }

    union GqlPoolAprValue = GqlPoolAprRange | GqlPoolAprTotal

    """
    The base type as returned by poolGetPool (specific pool query)
    """
    interface GqlPoolBase {
        """
        The contract address of the pool.
        """
        address: Bytes!

        """
        Returns all pool tokens, including any nested tokens and phantom BPTs on one level.
        """
        allTokens: [GqlPoolTokenExpanded!]! @deprecated(reason: "Use poolTokens instead")

        """
        List of categories assigned by the team based on external factors
        """
        categories: [GqlPoolFilterCategory]

        """
        The chain on which the pool is deployed
        """
        chain: GqlChain!

        """
        The timestamp the pool was created.
        """
        createTime: Int!

        """
        The decimals of the BPT, usually 18
        """
        decimals: Int!

        """
        Only returns main tokens, also known as leave tokens. Wont return any nested BPTs. Used for displaying the tokens that the pool consists of.
        """
        displayTokens: [GqlPoolTokenDisplay!]! @deprecated(reason: "Use poolTokens instead")

        """
        Dynamic data such as token balances, swap fees or volume
        """
        dynamicData: GqlPoolDynamicData!

        """
        The factory contract address from which the pool was created.
        """
        factory: Bytes

        """
        The pool id. This is equal to the address for protocolVersion 3 pools
        """
        id: ID!

        """
        Deprecated
        """
        investConfig: GqlPoolInvestConfig! @deprecated(reason: "Removed without replacement")

        """
        The name of the pool as per contract
        """
        name: String!

        """
        The wallet address of the owner of the pool. Pool owners can set certain properties like swapFees or AMP.
        """
        owner: Bytes

        """
        Returns all pool tokens, including BPTs and nested pools if there are any. Only one nested level deep.
        """
        poolTokens: [GqlPoolTokenDetail!]!

        """
        The protocol version on which the pool is deployed, 1, 2 or 3
        """
        protocolVersion: Int!

        """
        Staking options of this pool which emit additional rewards
        """
        staking: GqlPoolStaking

        """
        The token symbol of the pool as per contract
        """
        symbol: String!

        """
        List of tags assigned by the team based on external factors
        """
        tags: [String]

        """
        The pool type, such as weighted, stable, etc.
        """
        type: GqlPoolType!

        """
        If a user address was provided in the query, the user balance is populated here
        """
        userBalance: GqlPoolUserBalance

        """
        The vault version on which the pool is deployed, 2 or 3
        """
        vaultVersion: Int! @deprecated(reason: "use protocolVersion instead")

        """
        The version of the pool type.
        """
        version: Int!

        """
        Deprecated
        """
        withdrawConfig: GqlPoolWithdrawConfig! @deprecated(reason: "Removed without replacement")
    }

    type GqlPoolBatchSwap {
        chain: GqlChain!
        id: ID!
        swaps: [GqlPoolBatchSwapSwap!]!
        timestamp: Int!
        tokenAmountIn: String!
        tokenAmountOut: String!
        tokenIn: String!
        tokenInPrice: Float!
        tokenOut: String!
        tokenOutPrice: Float!
        tx: String!
        userAddress: String!
        valueUSD: Float!
    }

    type GqlPoolBatchSwapPool {
        id: ID!
        tokens: [String!]!
    }

    type GqlPoolBatchSwapSwap {
        id: ID!
        pool: GqlPoolMinimal!
        timestamp: Int!
        tokenAmountIn: String!
        tokenAmountOut: String!
        tokenIn: String!
        tokenOut: String!
        tx: String!
        userAddress: String!
        valueUSD: Float!
    }

    type GqlPoolComposableStable implements GqlPoolBase {
        address: Bytes!
        allTokens: [GqlPoolTokenExpanded!]!
        amp: BigInt!
        bptPriceRate: BigDecimal!
        categories: [GqlPoolFilterCategory]
        chain: GqlChain!
        createTime: Int!
        decimals: Int!
        displayTokens: [GqlPoolTokenDisplay!]!
        dynamicData: GqlPoolDynamicData!
        factory: Bytes
        id: ID!
        investConfig: GqlPoolInvestConfig! @deprecated(reason: "Removed without replacement")
        name: String!
        nestingType: GqlPoolNestingType!
        owner: Bytes!
        poolTokens: [GqlPoolTokenDetail!]!
        protocolVersion: Int!
        staking: GqlPoolStaking
        symbol: String!
        tags: [String]

        """
        All tokens of the pool. If it is a nested pool, the nested pool is expanded with its own tokens again.
        """
        tokens: [GqlPoolTokenUnion!]! @deprecated(reason: "Use poolTokens instead")
        type: GqlPoolType!
        userBalance: GqlPoolUserBalance
        vaultVersion: Int! @deprecated(reason: "use protocolVersion instead")
        version: Int!
        withdrawConfig: GqlPoolWithdrawConfig! @deprecated(reason: "Removed without replacement")
    }

    type GqlPoolComposableStableNested {
        address: Bytes!
        amp: BigInt!
        bptPriceRate: BigDecimal!
        categories: [GqlPoolFilterCategory]
        createTime: Int!
        factory: Bytes
        id: ID!
        name: String!
        nestingType: GqlPoolNestingType!
        owner: Bytes!
        swapFee: BigDecimal!
        symbol: String!
        tags: [String]
        tokens: [GqlPoolTokenComposableStableNestedUnion!]! @deprecated(reason: "Use poolTokens instead")
        totalLiquidity: BigDecimal!
        totalShares: BigDecimal!
        type: GqlPoolType!
        version: Int!
    }

    type GqlPoolDynamicData {
        """
        Protocol and pool creator fees combined
        """
        aggregateSwapFee: BigDecimal!

        """
        Protocol and pool creator fees combined
        """
        aggregateYieldFee: BigDecimal!
        apr: GqlPoolApr! @deprecated(reason: "Use aprItems instead")
        aprItems: [GqlPoolAprItem!]!
        fees24h: BigDecimal!
        fees24hAth: BigDecimal!
        fees24hAthTimestamp: Int!
        fees24hAtl: BigDecimal!
        fees24hAtlTimestamp: Int!
        fees48h: BigDecimal!
        holdersCount: BigInt!

        """
        True for bricked pools
        """
        isInRecoveryMode: Boolean!
        isPaused: Boolean!
        lifetimeSwapFees: BigDecimal!
        lifetimeVolume: BigDecimal!
        poolId: ID!
        sharePriceAth: BigDecimal!
        sharePriceAthTimestamp: Int!
        sharePriceAtl: BigDecimal!
        sharePriceAtlTimestamp: Int!

        """
        CowAmm specific, equivalent of swap fees
        """
        surplus24h: BigDecimal!

        """
        CowAmm specific, equivalent of swap fees
        """
        surplus48h: BigDecimal!

        """
        Disabled for bricked pools
        """
        swapEnabled: Boolean!
        swapFee: BigDecimal!
        swapsCount: BigInt!
        totalLiquidity: BigDecimal!
        totalLiquidity24hAgo: BigDecimal!
        totalLiquidityAth: BigDecimal!
        totalLiquidityAthTimestamp: Int!
        totalLiquidityAtl: BigDecimal!
        totalLiquidityAtlTimestamp: Int!
        totalShares: BigDecimal!
        totalShares24hAgo: BigDecimal!
        volume24h: BigDecimal!
        volume24hAth: BigDecimal!
        volume24hAthTimestamp: Int!
        volume24hAtl: BigDecimal!
        volume24hAtlTimestamp: Int!
        volume48h: BigDecimal!
        yieldCapture24h: BigDecimal!
        yieldCapture48h: BigDecimal!
    }

    type GqlPoolElement implements GqlPoolBase {
        address: Bytes!
        allTokens: [GqlPoolTokenExpanded!]!
        baseToken: Bytes!
        categories: [GqlPoolFilterCategory]
        chain: GqlChain!
        createTime: Int!
        decimals: Int!
        displayTokens: [GqlPoolTokenDisplay!]!
        dynamicData: GqlPoolDynamicData!
        factory: Bytes
        id: ID!
        investConfig: GqlPoolInvestConfig! @deprecated(reason: "Removed without replacement")
        name: String!
        owner: Bytes!
        poolTokens: [GqlPoolTokenDetail!]!
        principalToken: Bytes!
        protocolVersion: Int!
        staking: GqlPoolStaking
        symbol: String!
        tags: [String]
        tokens: [GqlPoolToken!]! @deprecated(reason: "Use poolTokens instead")
        type: GqlPoolType!
        unitSeconds: BigInt!
        userBalance: GqlPoolUserBalance
        vaultVersion: Int! @deprecated(reason: "use protocolVersion instead")
        version: Int!
        withdrawConfig: GqlPoolWithdrawConfig! @deprecated(reason: "Removed without replacement")
    }

    interface GqlPoolEvent {
        blockNumber: Int!
        blockTimestamp: Int!
        chain: GqlChain!
        id: ID!
        logIndex: Int!
        poolId: String!
        sender: String!
        timestamp: Int!
        tx: String!
        type: GqlPoolEventType!
        userAddress: String!
        valueUSD: Float!
    }

    type GqlPoolEventAmount {
        address: String!
        amount: String!
        valueUSD: Float!
    }

    enum GqlPoolEventType {
        ADD
        REMOVE
        SWAP
    }

    enum GqlPoolEventsDataRange {
        NINETY_DAYS
        SEVEN_DAYS
        THIRTY_DAYS
    }

    input GqlPoolEventsFilter {
        chainIn: [GqlChain]
        poolIdIn: [String]
        range: GqlPoolEventsDataRange
        typeIn: [GqlPoolEventType]
        userAddress: String

        """
        USD value of the event
        """
        valueUSD_gt: Float

        """
        USD value of the event
        """
        valueUSD_gte: Float
    }

    type GqlPoolFeaturedPool {
        description: String!
        pool: GqlPoolBase!
        poolId: ID!
        primary: Boolean!
    }

    type GqlPoolFeaturedPoolGroup {
        icon: String!
        id: ID!
        items: [GqlPoolFeaturedPoolGroupItem!]!
        title: String!
    }

    union GqlPoolFeaturedPoolGroupItem = GqlFeaturePoolGroupItemExternalLink | GqlPoolMinimal

    input GqlPoolFilter {
        categoryIn: [GqlPoolFilterCategory!] @deprecated(reason: "Use tagIn instead")
        categoryNotIn: [GqlPoolFilterCategory!] @deprecated(reason: "Use tagNotIn instead")
        chainIn: [GqlChain!]
        chainNotIn: [GqlChain!]
        createTime: GqlPoolTimePeriod
        filterIn: [String!]
        filterNotIn: [String!]
        idIn: [String!]
        idNotIn: [String!]
        minTvl: Float
        poolTypeIn: [GqlPoolType!]
        poolTypeNotIn: [GqlPoolType!]
        protocolVersionIn: [Int!]

        """
        For list of tags see: https://github.com/balancer/metadata/blob/main/pools/index.json
        Use uppercase
        """
        tagIn: [String!]

        """
        For list of tags see: https://github.com/balancer/metadata/blob/main/pools/index.json
        Use uppercase
        """
        tagNotIn: [String!]
        tokensIn: [String!]
        tokensNotIn: [String!]
        userAddress: String
    }

    enum GqlPoolFilterCategory {
        BLACK_LISTED
        INCENTIVIZED
        LRT
        POINTS
        POINTS_EIGENLAYER
        POINTS_GYRO
        POINTS_KELP
        POINTS_RENZO
        POINTS_SWELL
        SUPERFEST
    }

    type GqlPoolFx implements GqlPoolBase {
        address: Bytes!
        allTokens: [GqlPoolTokenExpanded!]!
        alpha: String!
        beta: String!
        categories: [GqlPoolFilterCategory]
        chain: GqlChain!
        createTime: Int!
        decimals: Int!
        delta: String!
        displayTokens: [GqlPoolTokenDisplay!]!
        dynamicData: GqlPoolDynamicData!
        epsilon: String!
        factory: Bytes
        id: ID!
        investConfig: GqlPoolInvestConfig! @deprecated(reason: "Removed without replacement")
        lambda: String!
        name: String!
        owner: Bytes
        poolTokens: [GqlPoolTokenDetail!]!
        protocolVersion: Int!
        staking: GqlPoolStaking
        symbol: String!
        tags: [String]

        """
        All tokens of the pool. If it is a nested pool, the nested pool is expanded with its own tokens again.
        """
        tokens: [GqlPoolTokenUnion!]! @deprecated(reason: "Use poolTokens instead")
        type: GqlPoolType!
        userBalance: GqlPoolUserBalance
        vaultVersion: Int! @deprecated(reason: "use protocolVersion instead")
        version: Int!
        withdrawConfig: GqlPoolWithdrawConfig! @deprecated(reason: "Removed without replacement")
    }

    type GqlPoolGyro implements GqlPoolBase {
        address: Bytes!
        allTokens: [GqlPoolTokenExpanded!]!
        alpha: String!
        beta: String!
        c: String!
        categories: [GqlPoolFilterCategory]
        chain: GqlChain!
        createTime: Int!
        dSq: String!
        decimals: Int!
        displayTokens: [GqlPoolTokenDisplay!]!
        dynamicData: GqlPoolDynamicData!
        factory: Bytes
        id: ID!
        investConfig: GqlPoolInvestConfig! @deprecated(reason: "Removed without replacement")
        lambda: String!
        name: String!
        nestingType: GqlPoolNestingType!
        owner: Bytes!
        poolTokens: [GqlPoolTokenDetail!]!
        protocolVersion: Int!
        root3Alpha: String!
        s: String!
        sqrtAlpha: String!
        sqrtBeta: String!
        staking: GqlPoolStaking
        symbol: String!
        tags: [String]
        tauAlphaX: String!
        tauAlphaY: String!
        tauBetaX: String!
        tauBetaY: String!

        """
        All tokens of the pool. If it is a nested pool, the nested pool is expanded with its own tokens again.
        """
        tokens: [GqlPoolTokenUnion!]! @deprecated(reason: "Use poolTokens instead")
        type: GqlPoolType!
        u: String!
        userBalance: GqlPoolUserBalance
        v: String!
        vaultVersion: Int! @deprecated(reason: "use protocolVersion instead")
        version: Int!
        w: String!
        withdrawConfig: GqlPoolWithdrawConfig! @deprecated(reason: "Removed without replacement")
        z: String!
    }

    type GqlPoolInvestConfig {
        options: [GqlPoolInvestOption!]!
        proportionalEnabled: Boolean!
        singleAssetEnabled: Boolean!
    }

    type GqlPoolInvestOption {
        poolTokenAddress: String!
        poolTokenIndex: Int!
        tokenOptions: [GqlPoolToken!]!
    }

    type GqlPoolJoinExit {
        amounts: [GqlPoolJoinExitAmount!]!
        chain: GqlChain!
        id: ID!
        poolId: String!
        sender: String!
        timestamp: Int!
        tx: String!
        type: GqlPoolJoinExitType!
        valueUSD: String
    }

    type GqlPoolJoinExitAmount {
        address: String!
        amount: String!
    }

    input GqlPoolJoinExitFilter {
        chainIn: [GqlChain!]
        poolIdIn: [String!]
    }

    enum GqlPoolJoinExitType {
        Exit
        Join
    }

    type GqlPoolLiquidityBootstrapping implements GqlPoolBase {
        address: Bytes!
        allTokens: [GqlPoolTokenExpanded!]!
        categories: [GqlPoolFilterCategory]
        chain: GqlChain!
        createTime: Int!
        decimals: Int!
        displayTokens: [GqlPoolTokenDisplay!]!
        dynamicData: GqlPoolDynamicData!
        factory: Bytes
        id: ID!
        investConfig: GqlPoolInvestConfig! @deprecated(reason: "Removed without replacement")
        name: String!
        nestingType: GqlPoolNestingType!
        owner: Bytes!
        poolTokens: [GqlPoolTokenDetail!]!
        protocolVersion: Int!
        staking: GqlPoolStaking
        symbol: String!
        tags: [String]

        """
        All tokens of the pool. If it is a nested pool, the nested pool is expanded with its own tokens again.
        """
        tokens: [GqlPoolTokenUnion!]! @deprecated(reason: "Use poolTokens instead")
        type: GqlPoolType!
        userBalance: GqlPoolUserBalance
        vaultVersion: Int! @deprecated(reason: "use protocolVersion instead")
        version: Int!
        withdrawConfig: GqlPoolWithdrawConfig! @deprecated(reason: "Removed without replacement")
    }

    type GqlPoolMetaStable implements GqlPoolBase {
        address: Bytes!
        allTokens: [GqlPoolTokenExpanded!]!
        amp: BigInt!
        categories: [GqlPoolFilterCategory]
        chain: GqlChain!
        createTime: Int!
        decimals: Int!
        displayTokens: [GqlPoolTokenDisplay!]!
        dynamicData: GqlPoolDynamicData!
        factory: Bytes
        id: ID!
        investConfig: GqlPoolInvestConfig! @deprecated(reason: "Removed without replacement")
        name: String!
        owner: Bytes!
        poolTokens: [GqlPoolTokenDetail!]!
        protocolVersion: Int!
        staking: GqlPoolStaking
        symbol: String!
        tags: [String]
        tokens: [GqlPoolToken!]! @deprecated(reason: "Use poolTokens instead")
        type: GqlPoolType!
        userBalance: GqlPoolUserBalance
        vaultVersion: Int! @deprecated(reason: "use protocolVersion instead")
        version: Int!
        withdrawConfig: GqlPoolWithdrawConfig! @deprecated(reason: "Removed without replacement")
    }

    """
    The pool schema returned for poolGetPools (pool list query)
    """
    type GqlPoolMinimal {
        """
        The contract address of the pool.
        """
        address: Bytes!

        """
        Returns all pool tokens, including any nested tokens and phantom BPTs
        """
        allTokens: [GqlPoolTokenExpanded!]!

        """
        List of categories assigned by the team based on external factors
        """
        categories: [GqlPoolFilterCategory]

        """
        The chain on which the pool is deployed
        """
        chain: GqlChain!

        """
        The timestamp the pool was created.
        """
        createTime: Int!

        """
        The decimals of the BPT, usually 18
        """
        decimals: Int!

        """
        Only returns main or underlying tokens, also known as leave tokens. Wont return any nested BPTs. Used for displaying the tokens that the pool consists of.
        """
        displayTokens: [GqlPoolTokenDisplay!]!

        """
        Dynamic data such as token balances, swap fees or volume
        """
        dynamicData: GqlPoolDynamicData!

        """
        The factory contract address from which the pool was created.
        """
        factory: Bytes

        """
        Whether at least one token in this pool is considered an ERC4626 token.
        """
        hasErc4626: Boolean!

        """
        Hook assigned to a pool
        """
        hook: Hook

        """
        The pool id. This is equal to the address for protocolVersion 3 pools
        """
        id: ID!

        """
        Pool is receiving rewards when liquidity tokens are staked
        """
        incentivized: Boolean!

        """
        The name of the pool as per contract
        """
        name: String!

        """
        The wallet address of the owner of the pool. Pool owners can set certain properties like swapFees or AMP.
        """
        owner: Bytes

        """
        The protocol version on which the pool is deployed, 1, 2 or 3
        """
        protocolVersion: Int!

        """
        Staking options of this pool which emit additional rewards
        """
        staking: GqlPoolStaking

        """
        The token symbol of the pool as per contract
        """
        symbol: String!

        """
        List of tags assigned by the team based on external factors
        """
        tags: [String]

        """
        The pool type, such as weighted, stable, etc.
        """
        type: GqlPoolType!

        """
        If a user address was provided in the query, the user balance is populated here
        """
        userBalance: GqlPoolUserBalance

        """
        The vault version on which the pool is deployed, 2 or 3
        """
        vaultVersion: Int! @deprecated(reason: "use protocolVersion instead")

        """
        The version of the pool type.
        """
        version: Int!
    }

    """
    Result of the poolReloadPools mutation
    """
    type GqlPoolMutationResult {
        """
        The chain that was reloaded.
        """
        chain: GqlChain!

        """
        The error message
        """
        error: String

        """
        Whether it was successful or not.
        """
        success: Boolean!

        """
        The type of pools that were reloaded.
        """
        type: String!
    }

    union GqlPoolNestedUnion = GqlPoolComposableStableNested

    enum GqlPoolNestingType {
        HAS_ONLY_PHANTOM_BPT
        HAS_SOME_PHANTOM_BPT
        NO_NESTING
    }

    enum GqlPoolOrderBy {
        apr
        fees24h
        totalLiquidity
        totalShares
        userbalanceUsd
        volume24h
    }

    enum GqlPoolOrderDirection {
        asc
        desc
    }

    type GqlPoolSnapshot {
        amounts: [String!]!
        chain: GqlChain!
        fees24h: String!
        holdersCount: String!
        id: ID!
        poolId: String!
        sharePrice: String!
        surplus24h: String!
        swapsCount: String!
        timestamp: Int!
        totalLiquidity: String!
        totalShares: String!
        totalSurplus: String!
        totalSwapFee: String!
        totalSwapVolume: String!
        volume24h: String!
    }

    enum GqlPoolSnapshotDataRange {
        ALL_TIME
        NINETY_DAYS
        ONE_HUNDRED_EIGHTY_DAYS
        ONE_YEAR
        THIRTY_DAYS
    }

    type GqlPoolStable implements GqlPoolBase {
        address: Bytes!
        allTokens: [GqlPoolTokenExpanded!]!
        amp: BigInt!
        categories: [GqlPoolFilterCategory]
        chain: GqlChain!
        createTime: Int!
        decimals: Int!
        displayTokens: [GqlPoolTokenDisplay!]!
        dynamicData: GqlPoolDynamicData!
        factory: Bytes
        id: ID!
        investConfig: GqlPoolInvestConfig! @deprecated(reason: "Removed without replacement")
        name: String!
        owner: Bytes!
        poolTokens: [GqlPoolTokenDetail!]!
        protocolVersion: Int!
        staking: GqlPoolStaking
        symbol: String!
        tags: [String]
        tokens: [GqlPoolToken!]! @deprecated(reason: "Use poolTokens instead")
        type: GqlPoolType!
        userBalance: GqlPoolUserBalance
        vaultVersion: Int! @deprecated(reason: "use protocolVersion instead")
        version: Int!
        withdrawConfig: GqlPoolWithdrawConfig! @deprecated(reason: "Removed without replacement")
    }

    type GqlPoolStableComposablePoolData {
        address: String!
        balance: String!
        id: ID!
        symbol: String!
        tokens: [GqlPoolToken!]!
        totalSupply: String!
    }

    type GqlPoolStaking {
        address: String!
        aura: GqlPoolStakingAura
        chain: GqlChain!
        farm: GqlPoolStakingMasterChefFarm
        gauge: GqlPoolStakingGauge
        id: ID!
        reliquary: GqlPoolStakingReliquaryFarm
        type: GqlPoolStakingType!
        vebal: GqlPoolStakingVebal
    }

    type GqlPoolStakingAura {
        apr: Float!
        auraPoolAddress: String!
        auraPoolId: String!
        id: ID!
        isShutdown: Boolean!
    }

    type GqlPoolStakingFarmRewarder {
        address: String!
        id: ID!
        rewardPerSecond: String!
        tokenAddress: String!
    }

    type GqlPoolStakingGauge {
        gaugeAddress: String!
        id: ID!
        otherGauges: [GqlPoolStakingOtherGauge!]
        rewards: [GqlPoolStakingGaugeReward!]!
        status: GqlPoolStakingGaugeStatus!
        version: Int!
        workingSupply: String!
    }

    type GqlPoolStakingGaugeReward {
        id: ID!
        rewardPerSecond: String!
        tokenAddress: String!
    }

    enum GqlPoolStakingGaugeStatus {
        ACTIVE
        KILLED
        PREFERRED
    }

    type GqlPoolStakingMasterChefFarm {
        beetsPerBlock: String!
        id: ID!
        rewarders: [GqlPoolStakingFarmRewarder!]
    }

    type GqlPoolStakingOtherGauge {
        gaugeAddress: String!
        id: ID!
        rewards: [GqlPoolStakingGaugeReward!]!
        status: GqlPoolStakingGaugeStatus!
        version: Int!
    }

    type GqlPoolStakingReliquaryFarm {
        beetsPerSecond: String!
        id: ID!
        levels: [GqlPoolStakingReliquaryFarmLevel!]
        totalBalance: String!
        totalWeightedBalance: String!
    }

    type GqlPoolStakingReliquaryFarmLevel {
        allocationPoints: Int!
        apr: BigDecimal!
        balance: BigDecimal!
        id: ID!
        level: Int!
        requiredMaturity: Int!
    }

    enum GqlPoolStakingType {
        AURA
        FRESH_BEETS
        GAUGE
        MASTER_CHEF
        RELIQUARY
        VEBAL
    }

    type GqlPoolStakingVebal {
        id: ID!
        vebalAddress: String!
    }

    type GqlPoolSwap {
        chain: GqlChain!
        id: ID!
        poolId: String!
        timestamp: Int!
        tokenAmountIn: String!
        tokenAmountOut: String!
        tokenIn: String!
        tokenOut: String!
        tx: String!
        userAddress: String!
        valueUSD: Float!
    }

    type GqlPoolSwapEventV3 implements GqlPoolEvent {
        blockNumber: Int!
        blockTimestamp: Int!
        chain: GqlChain!
        id: ID!
        logIndex: Int!
        poolId: String!
        sender: String!
        timestamp: Int!
        tokenIn: GqlPoolEventAmount!
        tokenOut: GqlPoolEventAmount!
        tx: String!
        type: GqlPoolEventType!
        userAddress: String!
        valueUSD: Float!
    }

    input GqlPoolSwapFilter {
        chainIn: [GqlChain!]
        poolIdIn: [String!]
        tokenInIn: [String!]
        tokenOutIn: [String!]
    }

    input GqlPoolTimePeriod {
        gt: Int
        lt: Int
    }

    type GqlPoolToken implements GqlPoolTokenBase {
        address: String!
        balance: BigDecimal!
        decimals: Int!
        id: ID!
        index: Int!
        name: String!
        priceRate: BigDecimal!
        priceRateProvider: String
        symbol: String!
        totalBalance: BigDecimal!
        weight: BigDecimal
    }

    interface GqlPoolTokenBase {
        address: String!
        balance: BigDecimal!
        decimals: Int!
        id: ID!
        index: Int!
        name: String!
        priceRate: BigDecimal!
        priceRateProvider: String
        symbol: String!
        totalBalance: BigDecimal!
        weight: BigDecimal
    }

    type GqlPoolTokenComposableStable implements GqlPoolTokenBase {
        address: String!
        balance: BigDecimal!
        decimals: Int!
        id: ID!
        index: Int!
        name: String!
        pool: GqlPoolComposableStableNested!
        priceRate: BigDecimal!
        priceRateProvider: String
        symbol: String!
        totalBalance: BigDecimal!
        weight: BigDecimal
    }

    union GqlPoolTokenComposableStableNestedUnion = GqlPoolToken

    """
    All info on the pool token. It will also include the nested pool if the token is a BPT. It will only support 1 level of nesting.
    A second (unsupported) level of nesting is shown by having hasNestedPool = true but nestedPool = null.
    """
    type GqlPoolTokenDetail {
        """
        Address of the pool token.
        """
        address: String!

        """
        Balance of the pool token inside the pool.
        """
        balance: BigDecimal!

        """
        USD Balance of the pool token.
        """
        balanceUSD: BigDecimal!

        """
        Decimals of the pool token.
        """
        decimals: Int!

        """
        Indicates whether this token is a BPT and therefor has a nested pool.
        """
        hasNestedPool: Boolean!

        """
        Id of the token. A combination of pool id and token address.
        """
        id: ID!

        """
        Index of the pool token in the pool as returned by the vault.
        """
        index: Int!

        """
        Whether the token is in the allow list.
        """
        isAllowed: Boolean!

        """
        Whether the token is considered an ERC4626 token.
        """
        isErc4626: Boolean!

        """
        Name of the pool token.
        """
        name: String!

        """
        Additional data for the nested pool if the token is a BPT. Null otherwise.
        """
        nestedPool: GqlNestedPool

        """
        If it is an appreciating token, it shows the current price rate. 1 otherwise.
        """
        priceRate: BigDecimal!

        """
        The address of the price rate provider.
        """
        priceRateProvider: String

        """
        Additional data for the price rate provider, such as reviews or warnings.
        """
        priceRateProviderData: GqlPriceRateProviderData

        """
        Symbol of the pool token.
        """
        symbol: String!

        """
        If it is an Erc4262, this will be the underlying token if present in the API.
        """
        underlyingToken: GqlToken

        """
        The weight of the token in the pool if it is a weighted pool, null otherwise
        """
        weight: BigDecimal
    }

    type GqlPoolTokenDisplay {
        address: String!
        id: ID!
        name: String!
        nestedTokens: [GqlPoolTokenDisplay!]
        symbol: String!
        weight: BigDecimal
    }

    type GqlPoolTokenExpanded {
        address: String!
        decimals: Int!
        id: ID!
        isErc4626: Boolean!
        isMainToken: Boolean!
        isNested: Boolean!
        isPhantomBpt: Boolean!
        name: String!
        symbol: String!
        weight: String
    }

    union GqlPoolTokenUnion = GqlPoolToken | GqlPoolTokenComposableStable

    """
    Supported pool types
    """
    enum GqlPoolType {
        COMPOSABLE_STABLE
        COW_AMM
        ELEMENT
        FX
        GYRO
        GYRO3
        GYROE
        INVESTMENT
        LIQUIDITY_BOOTSTRAPPING
        META_STABLE
        PHANTOM_STABLE
        STABLE
        UNKNOWN
        WEIGHTED
    }

    union GqlPoolUnion =
          GqlPoolComposableStable
        | GqlPoolElement
        | GqlPoolFx
        | GqlPoolGyro
        | GqlPoolLiquidityBootstrapping
        | GqlPoolMetaStable
        | GqlPoolStable
        | GqlPoolWeighted

    """
    If a user address was provided in the query, the user balance is populated here
    """
    type GqlPoolUserBalance {
        """
        The staked BPT balances of the user.
        """
        stakedBalances: [GqlUserStakedBalance!]!

        """
        Total balance (wallet + staked) as float
        """
        totalBalance: AmountHumanReadable!

        """
        Total balance (wallet + staked) in USD as float
        """
        totalBalanceUsd: Float!

        """
        The wallet balance (BPT in wallet) as float.
        """
        walletBalance: AmountHumanReadable!

        """
        The wallet balance (BPT in wallet) in USD as float.
        """
        walletBalanceUsd: Float!
    }

    type GqlPoolUserSwapVolume {
        swapVolumeUSD: BigDecimal!
        userAddress: String!
    }

    type GqlPoolWeighted implements GqlPoolBase {
        address: Bytes!
        allTokens: [GqlPoolTokenExpanded!]!
        categories: [GqlPoolFilterCategory]
        chain: GqlChain!
        createTime: Int!
        decimals: Int!
        displayTokens: [GqlPoolTokenDisplay!]!
        dynamicData: GqlPoolDynamicData!
        factory: Bytes
        id: ID!
        investConfig: GqlPoolInvestConfig! @deprecated(reason: "Removed without replacement")
        name: String!
        nestingType: GqlPoolNestingType!
        owner: Bytes!
        poolTokens: [GqlPoolTokenDetail!]!
        protocolVersion: Int!
        staking: GqlPoolStaking
        symbol: String!
        tags: [String]

        """
        All tokens of the pool. If it is a nested pool, the nested pool is expanded with its own tokens again.
        """
        tokens: [GqlPoolTokenUnion!]! @deprecated(reason: "Use poolTokens instead")
        type: GqlPoolType!
        userBalance: GqlPoolUserBalance
        vaultVersion: Int! @deprecated(reason: "use protocolVersion instead")
        version: Int!
        withdrawConfig: GqlPoolWithdrawConfig! @deprecated(reason: "Removed without replacement")
    }

    type GqlPoolWithdrawConfig {
        options: [GqlPoolWithdrawOption!]!
        proportionalEnabled: Boolean!
        singleAssetEnabled: Boolean!
    }

    type GqlPoolWithdrawOption {
        poolTokenAddress: String!
        poolTokenIndex: Int!
        tokenOptions: [GqlPoolToken!]!
    }

    """
    Returns the price impact of the path. If there is an error in the price impact calculation, priceImpact will be undefined but the error string is populated.
    """
    type GqlPriceImpact {
        """
        If priceImpact cant be calculated and is returned as undefined, the error string will be populated.
        """
        error: String

        """
        Price impact in percent 0.01 -> 0.01%; undefined if an error happened.
        """
        priceImpact: AmountHumanReadable
    }

    """
    Represents the data of a price rate provider
    """
    type GqlPriceRateProviderData {
        """
        The address of the price rate provider
        """
        address: String!

        """
        The factory used to create the price rate provider, if applicable
        """
        factory: String

        """
        The name of the price rate provider
        """
        name: String

        """
        The filename of the review of the price rate provider
        """
        reviewFile: String

        """
        Indicates if the price rate provider has been reviewed
        """
        reviewed: Boolean!

        """
        A summary of the price rate provider, usually just says safe or unsafe
        """
        summary: String

        """
        Upgradeable components of the price rate provider
        """
        upgradeableComponents: [GqlPriceRateProviderUpgradeableComponent]

        """
        Warnings associated with the price rate provider
        """
        warnings: [String!]
    }

    """
    Represents an upgradeable component of a price rate provider
    """
    type GqlPriceRateProviderUpgradeableComponent {
        """
        The entry point / proxy of the upgradeable component
        """
        entryPoint: String!

        """
        Indicates if the implementation of the component has been reviewed
        """
        implementationReviewed: String!
    }

    type GqlProtocolMetricsAggregated {
        chains: [GqlProtocolMetricsChain!]!
        numLiquidityProviders: BigInt!
        poolCount: BigInt!
        swapFee24h: BigDecimal!
        swapVolume24h: BigDecimal!
        totalLiquidity: BigDecimal!
        totalSwapFee: BigDecimal!
        totalSwapVolume: BigDecimal!
        yieldCapture24h: BigDecimal!
    }

    type GqlProtocolMetricsChain {
        chainId: String!
        numLiquidityProviders: BigInt!
        poolCount: BigInt!
        swapFee24h: BigDecimal!
        swapVolume24h: BigDecimal!
        totalLiquidity: BigDecimal!
        totalSwapFee: BigDecimal!
        totalSwapVolume: BigDecimal!
        yieldCapture24h: BigDecimal!
    }

    type GqlRelicSnapshot {
        balance: String!
        entryTimestamp: Int!
        farmId: String!
        level: Int!
        relicId: Int!
    }

    type GqlReliquaryFarmLevelSnapshot {
        balance: String!
        id: ID!
        level: String!
    }

    type GqlReliquaryFarmSnapshot {
        dailyDeposited: String!
        dailyWithdrawn: String!
        farmId: String!
        id: ID!
        levelBalances: [GqlReliquaryFarmLevelSnapshot!]!
        relicCount: String!
        timestamp: Int!
        tokenBalances: [GqlReliquaryTokenBalanceSnapshot!]!
        totalBalance: String!
        totalLiquidity: String!
        userCount: String!
    }

    type GqlReliquaryTokenBalanceSnapshot {
        address: String!
        balance: String!
        decimals: Int!
        id: ID!
        name: String!
        symbol: String!
    }

    type GqlSftmxStakingData {
        """
        Current exchange rate for sFTMx -> FTM
        """
        exchangeRate: String!

        """
        Whether maintenance is paused. This pauses reward claiming or harvesting and withdrawing from matured vaults.
        """
        maintenancePaused: Boolean!

        """
        The maximum FTM amount to depost.
        """
        maxDepositLimit: AmountHumanReadable!

        """
        The minimum FTM amount to deposit.
        """
        minDepositLimit: AmountHumanReadable!

        """
        Number of vaults that delegated to validators.
        """
        numberOfVaults: Int!

        """
        The current rebasing APR for sFTMx.
        """
        stakingApr: String!

        """
        Total amount of FTM in custody of sFTMx. Staked FTM plus free pool FTM.
        """
        totalFtmAmount: AmountHumanReadable!

        """
        Total amount of FTM in the free pool.
        """
        totalFtmAmountInPool: AmountHumanReadable!

        """
        Total amount of FTM staked/delegated to validators.
        """
        totalFtmAmountStaked: AmountHumanReadable!

        """
        Whether undelegation is paused. Undelegate is the first step to redeem sFTMx.
        """
        undelegatePaused: Boolean!

        """
        A list of all the vaults that delegated to validators.
        """
        vaults: [GqlSftmxStakingVault!]!

        """
        Whether withdrawals are paused. Withdraw is the second and final step to redeem sFTMx.
        """
        withdrawPaused: Boolean!

        """
        Delay to wait between undelegate (1st step) and withdraw (2nd step).
        """
        withdrawalDelay: Int!
    }

    type GqlSftmxStakingSnapshot {
        """
        Current exchange rate for sFTMx -> FTM
        """
        exchangeRate: String!
        id: ID!

        """
        The timestamp of the snapshot. Timestamp is end of day midnight.
        """
        timestamp: Int!

        """
        Total amount of FTM in custody of sFTMx. Staked FTM plus free pool FTM.
        """
        totalFtmAmount: AmountHumanReadable!

        """
        Total amount of FTM in the free pool.
        """
        totalFtmAmountInPool: AmountHumanReadable!

        """
        Total amount of FTM staked/delegated to validators.
        """
        totalFtmAmountStaked: AmountHumanReadable!
    }

    enum GqlSftmxStakingSnapshotDataRange {
        ALL_TIME
        NINETY_DAYS
        ONE_HUNDRED_EIGHTY_DAYS
        ONE_YEAR
        THIRTY_DAYS
    }

    type GqlSftmxStakingVault {
        """
        The amount of FTM that has been delegated via this vault.
        """
        ftmAmountStaked: AmountHumanReadable!

        """
        Whether the vault is matured, meaning whether unlock time has passed.
        """
        isMatured: Boolean!

        """
        Timestamp when the delegated FTM unlocks, matures.
        """
        unlockTimestamp: Int!

        """
        The address of the validator that the vault has delegated to.
        """
        validatorAddress: String!

        """
        The ID of the validator that the vault has delegated to.
        """
        validatorId: String!

        """
        The contract address of the vault.
        """
        vaultAddress: String!

        """
        The internal index of the vault.
        """
        vaultIndex: Int!
    }

    type GqlSftmxWithdrawalRequests {
        """
        Amount of sFTMx that is being redeemed.
        """
        amountSftmx: AmountHumanReadable!

        """
        The Withdrawal ID, used for interactions.
        """
        id: String!

        """
        Whether the requests is finished and the user has withdrawn.
        """
        isWithdrawn: Boolean!

        """
        The timestamp when the request was placed. There is a delay until the user can withdraw. See withdrawalDelay.
        """
        requestTimestamp: Int!

        """
        The user address that this request belongs to.
        """
        user: String!
    }

    type GqlSorCallData {
        """
        The call data that needs to be sent to the RPC
        """
        callData: String!

        """
        Maximum amount to be sent for exact out orders
        """
        maxAmountInRaw: String

        """
        Minimum amount received for exact in orders
        """
        minAmountOutRaw: String

        """
        The target contract to send the call data to
        """
        to: String!

        """
        Value in ETH that needs to be sent for native swaps
        """
        value: BigDecimal!
    }

    """
    The swap paths for a swap
    """
    type GqlSorGetSwapPaths {
        """
        Transaction data that can be posted to an RPC to execute the swap.
        """
        callData: GqlSorCallData

        """
        The price of tokenOut in tokenIn.
        """
        effectivePrice: AmountHumanReadable!

        """
        The price of tokenIn in tokenOut.
        """
        effectivePriceReversed: AmountHumanReadable!

        """
        The found paths as needed as input for the b-sdk to execute the swap
        """
        paths: [GqlSorPath!]!

        """
        Price impact of the path
        """
        priceImpact: GqlPriceImpact!

        """
        The version of the protocol these paths are from
        """
        protocolVersion: Int!

        """
        The return amount in human form. Return amount is either tokenOutAmount (if swapType is exactIn) or tokenInAmount (if swapType is exactOut)
        """
        returnAmount: AmountHumanReadable!

        """
        The return amount in a raw form
        """
        returnAmountRaw: BigDecimal!

        """
        The swap routes including pool information. Used to display by the UI
        """
        routes: [GqlSorSwapRoute!]!

        """
        The swap amount in human form. Swap amount is either tokenInAmount (if swapType is exactIn) or tokenOutAmount (if swapType is exactOut)
        """
        swapAmount: AmountHumanReadable!

        """
        The swap amount in a raw form
        """
        swapAmountRaw: BigDecimal!

        """
        The swapType that was provided, exact_in vs exact_out (givenIn vs givenOut)
        """
        swapType: GqlSorSwapType!

        """
        Swaps as needed for the vault swap input to execute the swap
        """
        swaps: [GqlSorSwap!]!

        """
        All token addresses (or assets) as needed for the vault swap input to execute the swap
        """
        tokenAddresses: [String!]!

        """
        The token address of the tokenIn provided
        """
        tokenIn: String!

        """
        The amount of tokenIn in human form
        """
        tokenInAmount: AmountHumanReadable!

        """
        The token address of the tokenOut provided
        """
        tokenOut: String!

        """
        The amount of tokenOut in human form
        """
        tokenOutAmount: AmountHumanReadable!

        """
        The version of the vault these paths are from
        """
        vaultVersion: Int! @deprecated(reason: "Use protocolVersion instead")
    }

    type GqlSorGetSwapsResponse {
        effectivePrice: AmountHumanReadable!
        effectivePriceReversed: AmountHumanReadable!
        marketSp: String!
        priceImpact: AmountHumanReadable!
        returnAmount: AmountHumanReadable!
        returnAmountConsideringFees: BigDecimal!
        returnAmountFromSwaps: BigDecimal
        returnAmountScaled: BigDecimal!
        routes: [GqlSorSwapRoute!]!
        swapAmount: AmountHumanReadable!
        swapAmountForSwaps: BigDecimal
        swapAmountScaled: BigDecimal!
        swapType: GqlSorSwapType!
        swaps: [GqlSorSwap!]!
        tokenAddresses: [String!]!
        tokenIn: String!
        tokenInAmount: AmountHumanReadable!
        tokenOut: String!
        tokenOutAmount: AmountHumanReadable!
    }

    """
    A path of a swap. A swap can have multiple paths. Used as input to execute the swap via b-sdk
    """
    type GqlSorPath {
        """
        Input amount of this path in scaled form
        """
        inputAmountRaw: String!

        """
        Output amount of this path in scaled form
        """
        outputAmountRaw: String!

        """
        A sorted list of pool ids that are used in this path
        """
        pools: [String]!

        """
        The version of the protocol these paths are from
        """
        protocolVersion: Int!

        """
        A sorted list of tokens that are ussed in this path
        """
        tokens: [Token]!

        """
        Vault version of this path.
        """
        vaultVersion: Int! @deprecated(reason: "Use protocolVersion instead")
    }

    """
    A single swap step as used for input to the vault to execute a swap
    """
    type GqlSorSwap {
        """
        Amount to be swapped in this step. 0 for chained swap.
        """
        amount: String!

        """
        Index of the asset used in the tokenAddress array.
        """
        assetInIndex: Int!

        """
        Index of the asset used in the tokenAddress array.
        """
        assetOutIndex: Int!

        """
        Pool id used in this swap step
        """
        poolId: String!

        """
        UserData used in this swap, generally uses defaults.
        """
        userData: String!
    }

    input GqlSorSwapOptionsInput {
        forceRefresh: Boolean
        maxPools: Int
        queryBatchSwap: Boolean
        timestamp: Int
    }

    """
    The swap routes including pool information. Used to display by the UI
    """
    type GqlSorSwapRoute {
        """
        The hops this route takes
        """
        hops: [GqlSorSwapRouteHop!]!

        """
        Share of this route of the total swap
        """
        share: Float!

        """
        Address of the tokenIn
        """
        tokenIn: String!

        """
        Amount of the tokenIn in human form
        """
        tokenInAmount: AmountHumanReadable!

        """
        Address of the tokenOut
        """
        tokenOut: String!

        """
        Amount of the tokenOut in human form
        """
        tokenOutAmount: AmountHumanReadable!
    }

    """
    A hop of a route. A route can have many hops meaning it traverses more than one pool.
    """
    type GqlSorSwapRouteHop {
        """
        The pool entity of this hop.
        """
        pool: GqlPoolMinimal!

        """
        The pool id of this hop.
        """
        poolId: String!

        """
        Address of the tokenIn
        """
        tokenIn: String!

        """
        Amount of the tokenIn in human form
        """
        tokenInAmount: AmountHumanReadable!

        """
        Address of the tokenOut
        """
        tokenOut: String!

        """
        Amount of the tokenOut in human form
        """
        tokenOutAmount: AmountHumanReadable!
    }

    enum GqlSorSwapType {
        EXACT_IN
        EXACT_OUT
    }

    """
    Inputs for the call data to create the swap transaction. If this input is given, call data is added to the response.
    """
    input GqlSwapCallDataInput {
        """
        How long the swap should be valid, provide a timestamp. "999999999999999999" for infinite. Default: infinite
        """
        deadline: Int

        """
        Who receives the output amount.
        """
        receiver: String!

        """
        Who sends the input amount.
        """
        sender: String!

        """
        The max slippage in percent 0.01 -> 0.01%
        """
        slippagePercentage: String!
    }

    """
    Represents a token
    """
    type GqlToken {
        """
        The address of the token
        """
        address: String!

        """
        The chain of the token
        """
        chain: GqlChain!

        """
        The chain ID of the token
        """
        chainId: Int!

        """
        The coingecko ID for this token, if present
        """
        coingeckoId: String

        """
        The number of decimal places for the token
        """
        decimals: Int!

        """
        The description of the token
        """
        description: String

        """
        The Discord URL of the token
        """
        discordUrl: String

        """
        Whether the token is considered an ERC4626 token.
        """
        isErc4626: Boolean!

        """
        The logo URI of the token
        """
        logoURI: String

        """
        The name of the token
        """
        name: String!

        """
        The rate provider data for the token
        """
        priceRateProviderData: GqlPriceRateProviderData

        """
        The priority of the token, can be used for sorting.
        """
        priority: Int!

        """
        The rate provider data for the token
        """
        rateProviderData: GqlPriceRateProviderData

        """
        The symbol of the token
        """
        symbol: String!

        """
        The Telegram URL of the token
        """
        telegramUrl: String

        """
        Indicates if the token is tradable
        """
        tradable: Boolean!

        """
        The Twitter username of the token
        """
        twitterUsername: String

        """
        The website URL of the token
        """
        websiteUrl: String
    }

    input GqlTokenAmountHumanReadable {
        address: String!
        amount: AmountHumanReadable!
    }

    type GqlTokenCandlestickChartDataItem {
        close: AmountHumanReadable!
        high: AmountHumanReadable!
        id: ID!
        low: AmountHumanReadable!
        open: AmountHumanReadable!
        timestamp: Int!
    }

    enum GqlTokenChartDataRange {
        NINETY_DAY
        ONE_HUNDRED_EIGHTY_DAY
        ONE_YEAR
        SEVEN_DAY
        THIRTY_DAY
    }

    type GqlTokenData {
        description: String
        discordUrl: String
        id: ID!
        telegramUrl: String
        tokenAddress: String!
        twitterUsername: String
        websiteUrl: String
    }

    """
    Represents additional data for a token
    """
    type GqlTokenDynamicData {
        """
        The all-time high price of the token
        """
        ath: Float!

        """
        The all-time low price of the token
        """
        atl: Float!

        """
        The fully diluted valuation of the token
        """
        fdv: String

        """
        The highest price in the last 24 hours
        """
        high24h: Float!

        """
        The unique identifier of the dynamic data
        """
        id: String!

        """
        The lowest price in the last 24 hours
        """
        low24h: Float!

        """
        The market capitalization of the token
        """
        marketCap: String

        """
        The current price of the token
        """
        price: Float!

        """
        The price change in the last 24 hours
        """
        priceChange24h: Float!

        """
        The percentage price change in the last 7 days
        """
        priceChangePercent7d: Float

        """
        The percentage price change in the last 14 days
        """
        priceChangePercent14d: Float

        """
        The percentage price change in the last 24 hours
        """
        priceChangePercent24h: Float!

        """
        The percentage price change in the last 30 days
        """
        priceChangePercent30d: Float

        """
        The address of the token
        """
        tokenAddress: String!

        """
        The timestamp when the data was last updated
        """
        updatedAt: String!
    }

    """
    Result of the poolReloadPools mutation
    """
    type GqlTokenMutationResult {
        """
        The chain that was reloaded.
        """
        chain: GqlChain!

        """
        The error message
        """
        error: String

        """
        Whether it was successful or not.
        """
        success: Boolean!
    }

    type GqlTokenPrice {
        address: String!
        chain: GqlChain!
        price: Float!
        updatedAt: Int!
        updatedBy: String
    }

    type GqlTokenPriceChartDataItem {
        id: ID!
        price: AmountHumanReadable!
        timestamp: Int!
    }

    enum GqlTokenType {
        BPT
        PHANTOM_BPT
        WHITE_LISTED
    }

    type GqlUserFbeetsBalance {
        id: String!
        stakedBalance: AmountHumanReadable!
        totalBalance: AmountHumanReadable!
        walletBalance: AmountHumanReadable!
    }

    type GqlUserPoolBalance {
        chain: GqlChain!
        poolId: String!
        stakedBalance: AmountHumanReadable!
        tokenAddress: String!
        tokenPrice: Float!
        totalBalance: AmountHumanReadable!
        walletBalance: AmountHumanReadable!
    }

    type GqlUserStakedBalance {
        """
        The staked BPT balance as float.
        """
        balance: AmountHumanReadable!

        """
        The steaked BPT balance in USD as float.
        """
        balanceUsd: Float!

        """
        The id of the staking to match with GqlPoolStaking.id.
        """
        stakingId: String!

        """
        The staking type (Gauge, farm, aura, etc.) in which this balance is staked.
        """
        stakingType: GqlPoolStakingType!
    }

    input GqlUserSwapVolumeFilter {
        poolIdIn: [String!]
        tokenInIn: [String!]
        tokenOutIn: [String!]
    }

    type GqlVeBalBalance {
        balance: AmountHumanReadable!
        chain: GqlChain!
        locked: AmountHumanReadable!
        lockedUsd: AmountHumanReadable!
    }

    type GqlVeBalUserData {
        balance: AmountHumanReadable!
        locked: AmountHumanReadable!
        lockedUsd: AmountHumanReadable!
        rank: Int
    }

    """
    The Gauge that can be voted on through veBAL and that will ultimately receive the rewards.
    """
    type GqlVotingGauge {
        """
        The timestamp the gauge was added.
        """
        addedTimestamp: Int

        """
        The address of the root gauge on Ethereum mainnet.
        """
        address: Bytes!

        """
        The address of the child gauge on the specific chain.
        """
        childGaugeAddress: Bytes

        """
        Whether the gauge is killed or not.
        """
        isKilled: Boolean!

        """
        The relative weight the gauge received this epoch (not more than 1.0).
        """
        relativeWeight: String!

        """
        The relative weight cap. 1.0 for uncapped.
        """
        relativeWeightCap: String
    }

    """
    A token inside of a pool with a voting gauge.
    """
    type GqlVotingGaugeToken {
        """
        The address of the token.
        """
        address: String!

        """
        The URL to the token logo.
        """
        logoURI: String!

        """
        The symbol of the token.
        """
        symbol: String!

        """
        If it is a weighted pool, the weigh of the token is shown here in %. 0.5 = 50%.
        """
        weight: String
    }

    """
    The pool that can be voted on through veBAL
    """
    type GqlVotingPool {
        """
        The address of the pool.
        """
        address: Bytes!

        """
        The chain this pool is on.
        """
        chain: GqlChain!

        """
        The gauge that is connected to the pool and that will receive the rewards.
        """
        gauge: GqlVotingGauge!

        """
        Pool ID
        """
        id: ID!

        """
        The symbol of the pool.
        """
        symbol: String!

        """
        The tokens inside the pool.
        """
        tokens: [GqlVotingGaugeToken!]!

        """
        The type of the pool.
        """
        type: GqlPoolType!
    }

    """
    Hook data
    """
    type Hook {
        address: String!
        chain: GqlChain!

        """
        Data points changing over time
        """
        dynamicData: HookData

        """
        True when hook can change the amounts send to the vault. Necessary to deduct the fees.
        """
        enableHookAdjustedAmounts: Boolean!

        """
        List of pools using the hook
        """
        poolsIds: [String]
        shouldCallAfterAddLiquidity: Boolean!
        shouldCallAfterInitialize: Boolean!
        shouldCallAfterRemoveLiquidity: Boolean!
        shouldCallAfterSwap: Boolean!
        shouldCallBeforeAddLiquidity: Boolean!
        shouldCallBeforeInitialize: Boolean!
        shouldCallBeforeRemoveLiquidity: Boolean!
        shouldCallBeforeSwap: Boolean!
        shouldCallComputeDynamicSwapFee: Boolean!
    }

    """
    Collection of hook specific data. Percentage format is 0.01 -> 0.01%.
    """
    type HookData {
        addLiquidityFeePercentage: String
        removeLiquidityFeePercentage: String
        swapFeePercentage: String
    }

    scalar JSON

    type Mutation {
        beetsPoolLoadReliquarySnapshotsForAllFarms: String!
        beetsSyncFbeetsRatio: String!
        cacheAverageBlockTime: String!
        poolBlackListAddPool(poolId: String!): String!
        poolBlackListRemovePool(poolId: String!): String!
        poolDeletePool(poolId: String!): String!
        poolInitOnChainDataForAllPools: String!
        poolInitializeSnapshotsForPool(poolId: String!): String!
        poolLoadOnChainDataForAllPools: String!
        poolLoadOnChainDataForPoolsWithActiveUpdates: String!
        poolLoadSnapshotsForAllPools: String!
        poolLoadSnapshotsForPools(poolIds: [String!]!, reload: Boolean): String!
        poolReloadAllPoolAprs(chain: GqlChain!): String!
        poolReloadAllTokenNestedPoolIds: String!
        poolReloadPools(chains: [GqlChain!]!): [GqlPoolMutationResult!]!
        poolReloadStakingForAllPools(stakingTypes: [GqlPoolStakingType!]!): String!
        poolSyncAllCowSnapshots(chains: [GqlChain!]!): [GqlPoolMutationResult!]!
        poolSyncAllPoolsFromSubgraph: [String!]!
        poolSyncLatestSnapshotsForAllPools(chain: GqlChain!): String!
        poolSyncNewPoolsFromSubgraph: [String!]!
        poolSyncPool(poolId: String!): String!
        poolSyncPoolAllTokensRelationship: String!
        poolSyncSanityPoolData: String!
        poolSyncStakingForPools: String!
        poolSyncSwapsForLast48Hours: String!
        poolSyncTotalShares: String!
        poolUpdateAprs(chain: GqlChain!): String!
        poolUpdateLifetimeValuesForAllPools: String!
        poolUpdateLiquidity24hAgoForAllPools: String!
        poolUpdateLiquidityValuesForAllPools: String!
        poolUpdateVolumeAndFeeValuesForAllPools: String!
        protocolCacheMetrics: String!
        sftmxSyncStakingData: String!
        sftmxSyncWithdrawalRequests: String!
        tokenDeleteTokenType(tokenAddress: String!, type: GqlTokenType!): String!
        tokenReloadAllTokenTypes: String!
        tokenReloadErc4626Tokens(chains: [GqlChain!]!): [GqlTokenMutationResult!]!
        tokenReloadTokenPrices(chains: [GqlChain!]!): Boolean
        tokenSyncLatestFxPrices(chain: GqlChain!): String!
        tokenSyncTokenDefinitions: String!
        userInitStakedBalances(stakingTypes: [GqlPoolStakingType!]!): String!
        userInitWalletBalancesForAllPools: String!
        userInitWalletBalancesForPool(poolId: String!): String!
        userSyncBalance(poolId: String!): String!
        userSyncBalanceAllPools: String!
        userSyncChangedStakedBalances: String!
        userSyncChangedWalletBalancesForAllPools: String!
        veBalSyncAllUserBalances: String!
        veBalSyncTotalSupply: String!
    }

    type Query {
        beetsGetFbeetsRatio: String!
        beetsPoolGetReliquaryFarmSnapshots(id: String!, range: GqlPoolSnapshotDataRange!): [GqlReliquaryFarmSnapshot!]!
        blocksGetAverageBlockTime: Float!
        blocksGetBlocksPerDay: Float!
        blocksGetBlocksPerSecond: Float!
        blocksGetBlocksPerYear: Float!
        contentGetNewsItems(chain: GqlChain): [GqlContentNewsItem!]!

        """
        Returns list of hooks.
        """
        hooks(chain: GqlChain): [Hook!]
        latestSyncedBlocks: GqlLatestSyncedBlocks!

        """
        Getting swap, add and remove events with paging
        """
        poolEvents(first: Int, skip: Int, where: GqlPoolEventsFilter): [GqlPoolEvent!]!

        """
        Will de deprecated in favor of poolEvents
        """
        poolGetBatchSwaps(first: Int, skip: Int, where: GqlPoolSwapFilter): [GqlPoolBatchSwap!]!
            @deprecated(reason: "Use poolEvents instead")

        """
        Getting swap, add and remove events with range
        """
        poolGetEvents(
            chain: GqlChain!
            poolId: String!
            range: GqlPoolEventsDataRange!
            typeIn: [GqlPoolEventType!]!
            userAddress: String
        ): [GqlPoolEvent!]!

        """
        Will de deprecated in favor of poolGetFeaturedPools
        """
        poolGetFeaturedPoolGroups(chains: [GqlChain!]): [GqlPoolFeaturedPoolGroup!]!
            @deprecated(reason: "Use poolGetFeaturedPools instead")

        """
        Returns the list of featured pools for chains
        """
        poolGetFeaturedPools(chains: [GqlChain!]!): [GqlPoolFeaturedPool!]!

        """
        Will de deprecated in favor of poolEvents
        """
        poolGetJoinExits(first: Int, skip: Int, where: GqlPoolJoinExitFilter): [GqlPoolJoinExit!]!
            @deprecated(reason: "Use poolEvents instead")

        """
        Returns one pool. If a user address is provided, the user balances for the given pool will also be returned.
        """
        poolGetPool(chain: GqlChain, id: String!, userAddress: String): GqlPoolBase!

        """
        Returns all pools for a given filter
        """
        poolGetPools(
            first: Int
            orderBy: GqlPoolOrderBy
            orderDirection: GqlPoolOrderDirection
            skip: Int
            textSearch: String
            where: GqlPoolFilter
        ): [GqlPoolMinimal!]!

        """
        Returns the number of pools for a given filter.
        """
        poolGetPoolsCount(
            first: Int
            orderBy: GqlPoolOrderBy
            orderDirection: GqlPoolOrderDirection
            skip: Int
            textSearch: String
            where: GqlPoolFilter
        ): Int!

        """
        Gets all the snapshots for a given pool on a chain for a certain range
        """
        poolGetSnapshots(chain: GqlChain, id: String!, range: GqlPoolSnapshotDataRange!): [GqlPoolSnapshot!]!

        """
        Will de deprecated in favor of poolEvents
        """
        poolGetSwaps(first: Int, skip: Int, where: GqlPoolSwapFilter): [GqlPoolSwap!]!
            @deprecated(reason: "Use poolEvents instead")
        protocolMetricsAggregated(chains: [GqlChain!]): GqlProtocolMetricsAggregated!
        protocolMetricsChain(chain: GqlChain): GqlProtocolMetricsChain!

        """
        Get the staking data and status for sFTMx
        """
        sftmxGetStakingData: GqlSftmxStakingData!

        """
        Get snapshots for sftmx staking for a specific range
        """
        sftmxGetStakingSnapshots(range: GqlSftmxStakingSnapshotDataRange!): [GqlSftmxStakingSnapshot!]!

        """
        Retrieve the withdrawalrequests from a user
        """
        sftmxGetWithdrawalRequests(user: String!): [GqlSftmxWithdrawalRequests!]!

        """
        Get swap quote from the SOR v2 for the V2 vault
        """
        sorGetSwapPaths(
            """
            Input data to create and return transaction data. If this config is given, call data is added to the response.
            """
            callDataInput: GqlSwapCallDataInput

            """
            The Chain to query
            """
            chain: GqlChain!

            """
            Whether to run queryBatchSwap to update the return amount with most up-to-date on-chain values, default: false
            """
            queryBatchSwap: Boolean

            """
            The amount to swap, in human form.
            """
            swapAmount: AmountHumanReadable!

            """
            SwapType either exact_in or exact_out (also givenIn or givenOut)
            """
            swapType: GqlSorSwapType!

            """
            Token address of the tokenIn
            """
            tokenIn: String!

            """
            Token address of the tokenOut
            """
            tokenOut: String!

            """
            Which protocol version to use (currently 2 and 3). If none provided, will chose the better return from any version
            """
            useProtocolVersion: Int
        ): GqlSorGetSwapPaths!

        """
        Get swap quote from the SOR, queries both the old and new SOR
        """
        sorGetSwaps(
            """
            The Chain to query
            """
            chain: GqlChain

            """
            The amount to swap, in human form.
            """
            swapAmount: BigDecimal!

            """
            Options for the swap
            """
            swapOptions: GqlSorSwapOptionsInput!

            """
            SwapType either exact_in or exact_out (also givenIn or givenOut)
            """
            swapType: GqlSorSwapType!

            """
            Token address of the tokenIn
            """
            tokenIn: String!

            """
            Token address of the tokenOut
            """
            tokenOut: String!
        ): GqlSorGetSwapsResponse!

        """
        Returns the candlestick chart data for a token for a given range.
        """
        tokenGetCandlestickChartData(
            address: String!
            chain: GqlChain
            range: GqlTokenChartDataRange!
        ): [GqlTokenCandlestickChartDataItem!]! @deprecated(reason: "Use tokenGetHistoricalPrices instead")

        """
        Returns all current prices for allowed tokens for a given chain or chains
        """
        tokenGetCurrentPrices(chains: [GqlChain!]): [GqlTokenPrice!]!

        """
        Returns the historical prices for a given set of tokens for a given chain and range
        """
        tokenGetHistoricalPrices(
            addresses: [String!]!
            chain: GqlChain!
            range: GqlTokenChartDataRange!
        ): [GqlHistoricalTokenPrice!]!

        """
        DEPRECATED: Returns pricing data for a given token for a given range
        """
        tokenGetPriceChartData(
            address: String!
            chain: GqlChain
            range: GqlTokenChartDataRange!
        ): [GqlTokenPriceChartDataItem!]! @deprecated(reason: "Use tokenGetHistoricalPrices instead")

        """
        Returns the price of either BAL or BEETS depending on chain
        """
        tokenGetProtocolTokenPrice(chain: GqlChain): AmountHumanReadable!
            @deprecated(reason: "Use tokenGetTokensDynamicData instead")

        """
        Returns the price of a token priced in another token for a given range.
        """
        tokenGetRelativePriceChartData(
            chain: GqlChain
            range: GqlTokenChartDataRange!
            tokenIn: String!
            tokenOut: String!
        ): [GqlTokenPriceChartDataItem!]!

        """
        Returns meta data for a given token such as description, website, etc.
        """
        tokenGetTokenData(address: String!, chain: GqlChain): GqlTokenData
            @deprecated(reason: "Use tokenGetTokens instead")

        """
        Returns dynamic data of a token such as price, market cap, etc.
        """
        tokenGetTokenDynamicData(address: String!, chain: GqlChain): GqlTokenDynamicData

        """
        Returns all allowed tokens for a given chain or chains
        """
        tokenGetTokens(chains: [GqlChain!]): [GqlToken!]!

        """
        Returns meta data for a given set of tokens such as description, website, etc.
        """
        tokenGetTokensData(addresses: [String!]!): [GqlTokenData!]! @deprecated(reason: "Use tokenGetTokens instead")

        """
        Returns dynamic data of a set of tokens such as price, market cap, etc.
        """
        tokenGetTokensDynamicData(addresses: [String!]!, chain: GqlChain): [GqlTokenDynamicData!]!
        userGetFbeetsBalance: GqlUserFbeetsBalance!
        userGetPoolBalances(address: String, chains: [GqlChain!]): [GqlUserPoolBalance!]!

        """
        Will de deprecated in favor of poolGetEvents
        """
        userGetPoolJoinExits(
            address: String
            chain: GqlChain
            first: Int = 10
            poolId: String!
            skip: Int = 0
        ): [GqlPoolJoinExit!]!
        userGetStaking(address: String, chains: [GqlChain!]): [GqlPoolStaking!]!

        """
        Will de deprecated in favor of poolGetEvents
        """
        userGetSwaps(address: String, chain: GqlChain, first: Int = 10, poolId: String!, skip: Int = 0): [GqlPoolSwap!]!
        veBalGetTotalSupply(chain: GqlChain): AmountHumanReadable!
        veBalGetUser(address: String!, chain: GqlChain): GqlVeBalUserData!
        veBalGetUserBalance(address: String, chain: GqlChain): AmountHumanReadable!
        veBalGetUserBalances(address: String!, chains: [GqlChain!]): [GqlVeBalBalance!]!

        """
        Returns all pools with veBAL gauges that can be voted on.
        """
        veBalGetVotingList: [GqlVotingPool!]!
    }

    type Token {
        address: String!
        decimals: Int!
    }
`;
