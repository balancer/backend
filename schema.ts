/*
 * THIS FILE IS AUTOGENERATED â€” DO NOT EDIT IT
 */
import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
import { ResolverContext } from './apps/api/gql/resolver-context';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type RequireFields<T, K extends keyof T> = { [X in Exclude<keyof T, K>]?: T[X] } & {
    [P in K]-?: NonNullable<T[P]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export interface Scalars {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    AmountHumanReadable: string;
    BigDecimal: string;
    BigInt: string;
    Bytes: string;
    Date: Date;
    GqlBigNumber: string;
    JSON: any;
}

export interface GqlBalancePoolAprItem {
    __typename?: 'GqlBalancePoolAprItem';
    apr: GqlPoolAprValue;
    id: Scalars['ID'];
    subItems?: Maybe<Array<GqlBalancePoolAprSubItem>>;
    title: Scalars['String'];
}

export interface GqlBalancePoolAprSubItem {
    __typename?: 'GqlBalancePoolAprSubItem';
    apr: GqlPoolAprValue;
    id: Scalars['ID'];
    title: Scalars['String'];
}

export type GqlChain =
    | 'ARBITRUM'
    | 'AVALANCHE'
    | 'BASE'
    | 'FANTOM'
    | 'FRAXTAL'
    | 'GNOSIS'
    | 'MAINNET'
    | 'MODE'
    | 'OPTIMISM'
    | 'POLYGON'
    | 'SEPOLIA'
    | 'ZKEVM';

export interface GqlContentNewsItem {
    __typename?: 'GqlContentNewsItem';
    discussionUrl?: Maybe<Scalars['String']>;
    id: Scalars['ID'];
    image?: Maybe<Scalars['String']>;
    source: GqlContentNewsItemSource;
    text: Scalars['String'];
    timestamp: Scalars['String'];
    url: Scalars['String'];
}

export type GqlContentNewsItemSource = 'discord' | 'medium' | 'twitter';

export interface GqlFeaturePoolGroupItemExternalLink {
    __typename?: 'GqlFeaturePoolGroupItemExternalLink';
    buttonText: Scalars['String'];
    buttonUrl: Scalars['String'];
    id: Scalars['ID'];
    image: Scalars['String'];
}

/** Configuration options for SOR V2 */
export interface GqlGraphTraversalConfigInput {
    /**
     * Max number of paths to return (can be less)
     *
     * Default: 5
     */
    approxPathsToReturn?: InputMaybe<Scalars['Int']>;
    /**
     * The max hops in a path.
     *
     * Default: 6
     */
    maxDepth?: InputMaybe<Scalars['Int']>;
    /**
     * Limit non boosted hop tokens in a boosted path.
     *
     * Default: 2
     */
    maxNonBoostedHopTokensInBoostedPath?: InputMaybe<Scalars['Int']>;
    /**
     * Limit of "non-boosted" pools for efficiency.
     *
     * Default: 6
     */
    maxNonBoostedPathDepth?: InputMaybe<Scalars['Int']>;
    poolIdsToInclude?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
}

export interface GqlHistoricalTokenPrice {
    __typename?: 'GqlHistoricalTokenPrice';
    address: Scalars['String'];
    chain: GqlChain;
    prices: Array<GqlHistoricalTokenPriceEntry>;
}

export interface GqlHistoricalTokenPriceEntry {
    __typename?: 'GqlHistoricalTokenPriceEntry';
    price: Scalars['Float'];
    timestamp: Scalars['String'];
    updatedAt: Scalars['Int'];
    updatedBy?: Maybe<Scalars['String']>;
}

export interface GqlLatestSyncedBlocks {
    __typename?: 'GqlLatestSyncedBlocks';
    poolSyncBlock: Scalars['BigInt'];
    userStakeSyncBlock: Scalars['BigInt'];
    userWalletSyncBlock: Scalars['BigInt'];
}

/** All info on the nested pool if the token is a BPT. It will only support 1 level of nesting. */
export interface GqlNestedPool {
    __typename?: 'GqlNestedPool';
    /** Address of the pool. */
    address: Scalars['Bytes'];
    /** Price rate of the Balancer Pool Token (BPT). */
    bptPriceRate: Scalars['BigDecimal'];
    /** Timestamp of when the pool was created. */
    createTime: Scalars['Int'];
    /** Address of the factory contract that created the pool, if applicable. */
    factory?: Maybe<Scalars['Bytes']>;
    /** Unique identifier of the pool. */
    id: Scalars['ID'];
    /** Name of the pool. */
    name: Scalars['String'];
    /** Total liquidity of the parent pool in the nested pool in USD. */
    nestedLiquidity: Scalars['BigDecimal'];
    /** Percentage of the parents pool shares inside the nested pool. */
    nestedPercentage: Scalars['BigDecimal'];
    /** Number of shares of the parent pool in the nested pool. */
    nestedShares: Scalars['BigDecimal'];
    /** Address of the pool's owner. */
    owner: Scalars['Bytes'];
    /** Fee charged for swapping tokens in the pool as %. 0.01 -> 0.01% */
    swapFee: Scalars['BigDecimal'];
    /** Symbol of the pool. */
    symbol: Scalars['String'];
    /** List of all tokens in the pool. */
    tokens: Array<GqlPoolTokenDetail>;
    /** Total liquidity in the pool in USD. */
    totalLiquidity: Scalars['BigDecimal'];
    /** Total number of shares in the pool. */
    totalShares: Scalars['BigDecimal'];
    /** Type of the pool. */
    type: GqlPoolType;
    /** Version of the pool. */
    version: Scalars['Int'];
}

/** Represents an event that occurs when liquidity is added or removed from a pool. */
export interface GqlPoolAddRemoveEventV3 extends GqlPoolEvent {
    __typename?: 'GqlPoolAddRemoveEventV3';
    /** The block number of the event. */
    blockNumber: Scalars['Int'];
    /** The block timestamp of the event. */
    blockTimestamp: Scalars['Int'];
    /** The chain on which the event occurred. */
    chain: GqlChain;
    /** The unique identifier of the event. */
    id: Scalars['ID'];
    /** The log index of the event. */
    logIndex: Scalars['Int'];
    /** The pool ID associated with the event. */
    poolId: Scalars['String'];
    /** The sender of the event. */
    sender: Scalars['String'];
    /** The timestamp of the event. */
    timestamp: Scalars['Int'];
    /** The tokens involved in the event. Ordered by poolToken index. */
    tokens: Array<GqlPoolEventAmount>;
    /** The transaction hash of the event. */
    tx: Scalars['String'];
    /** The type of the event. */
    type: GqlPoolEventType;
    /** The user address associated with the event. */
    userAddress: Scalars['String'];
    /** The value of the event in USD. */
    valueUSD: Scalars['Float'];
}

export interface GqlPoolAggregator {
    __typename?: 'GqlPoolAggregator';
    /** The contract address of the pool. */
    address: Scalars['Bytes'];
    /** Data specific to gyro/fx pools */
    alpha?: Maybe<Scalars['String']>;
    /** Data specific to stable pools */
    amp?: Maybe<Scalars['BigInt']>;
    /** Data specific to gyro/fx pools */
    beta?: Maybe<Scalars['String']>;
    /** Data specific to gyro pools */
    c?: Maybe<Scalars['String']>;
    /** The chain on which the pool is deployed */
    chain: GqlChain;
    /** The timestamp the pool was created. */
    createTime: Scalars['Int'];
    /** Data specific to gyro pools */
    dSq?: Maybe<Scalars['String']>;
    /** The decimals of the BPT, usually 18 */
    decimals: Scalars['Int'];
    /** Data specific to fx pools */
    delta?: Maybe<Scalars['String']>;
    /** Dynamic data such as token balances, swap fees or volume */
    dynamicData: GqlPoolDynamicData;
    /** Data specific to fx pools */
    epsilon?: Maybe<Scalars['String']>;
    /** The factory contract address from which the pool was created. */
    factory?: Maybe<Scalars['Bytes']>;
    /** The pool id. This is equal to the address for protocolVersion 3 pools */
    id: Scalars['ID'];
    /** Data specific to gyro/fx pools */
    lambda?: Maybe<Scalars['String']>;
    /** The name of the pool as per contract */
    name: Scalars['String'];
    /** The wallet address of the owner of the pool. Pool owners can set certain properties like swapFees or AMP. */
    owner?: Maybe<Scalars['Bytes']>;
    /** Returns all pool tokens, including BPTs and nested pools if there are any. Only one nested level deep. */
    poolTokens: Array<GqlPoolTokenDetail>;
    /** The protocol version on which the pool is deployed, 1, 2 or 3 */
    protocolVersion: Scalars['Int'];
    /** Data specific to gyro pools */
    root3Alpha?: Maybe<Scalars['String']>;
    /** Data specific to gyro pools */
    s?: Maybe<Scalars['String']>;
    /** Data specific to gyro pools */
    sqrtAlpha?: Maybe<Scalars['String']>;
    /** Data specific to gyro pools */
    sqrtBeta?: Maybe<Scalars['String']>;
    /** The token symbol of the pool as per contract */
    symbol: Scalars['String'];
    /** Data specific to gyro pools */
    tauAlphaX?: Maybe<Scalars['String']>;
    /** Data specific to gyro pools */
    tauAlphaY?: Maybe<Scalars['String']>;
    /** Data specific to gyro pools */
    tauBetaX?: Maybe<Scalars['String']>;
    /** Data specific to gyro pools */
    tauBetaY?: Maybe<Scalars['String']>;
    /** The pool type, such as weighted, stable, etc. */
    type: GqlPoolType;
    /** Data specific to gyro pools */
    u?: Maybe<Scalars['String']>;
    /** Data specific to gyro pools */
    v?: Maybe<Scalars['String']>;
    /** The version of the pool type. */
    version: Scalars['Int'];
    /** Data specific to gyro pools */
    w?: Maybe<Scalars['String']>;
    /** Data specific to gyro pools */
    z?: Maybe<Scalars['String']>;
}

export interface GqlPoolApr {
    __typename?: 'GqlPoolApr';
    apr: GqlPoolAprValue;
    hasRewardApr: Scalars['Boolean'];
    items: Array<GqlBalancePoolAprItem>;
    nativeRewardApr: GqlPoolAprValue;
    swapApr: Scalars['BigDecimal'];
    thirdPartyApr: GqlPoolAprValue;
}

/** All APRs for a pool */
export interface GqlPoolAprItem {
    __typename?: 'GqlPoolAprItem';
    /** The APR value in % -> 0.2 = 0.2% */
    apr: Scalars['Float'];
    /** The id of the APR item */
    id: Scalars['ID'];
    /** The reward token address, if the APR originates from token emissions */
    rewardTokenAddress?: Maybe<Scalars['String']>;
    /** The reward token symbol, if the APR originates from token emissions */
    rewardTokenSymbol?: Maybe<Scalars['String']>;
    /**
     * The title of the APR item, a human readable form
     * @deprecated No replacement, should be built client side
     */
    title: Scalars['String'];
    /** Specific type of this APR */
    type: GqlPoolAprItemType;
}

/** Enum representing the different types of the APR in a pool. */
export type GqlPoolAprItemType =
    /** APR that pools earns when BPT is staked on AURA. */
    | 'AURA'
    /** Represents the yield from an IB (Interest-Bearing) asset APR in a pool. */
    | 'IB_YIELD'
    /** APR in a pool that can be earned through locking, i.e. veBAL */
    | 'LOCKING'
    /** Reward APR in a pool from maBEETS emissions allocated by gauge votes. Emitted in BEETS. */
    | 'MABEETS_EMISSIONS'
    /** Rewards distributed by merkl.xyz */
    | 'MERKL'
    /** Represents if the APR items comes from a nested pool. */
    | 'NESTED'
    /** Staking reward APR in a pool from a reward token. */
    | 'STAKING'
    /** APR boost that can be earned, i.e. via veBAL or maBEETS. */
    | 'STAKING_BOOST'
    /** Cow AMM specific APR */
    | 'SURPLUS'
    /** Represents the swap fee APR in a pool. */
    | 'SWAP_FEE'
    /** Reward APR in a pool from veBAL emissions allocated by gauge votes. Emitted in BAL. */
    | 'VEBAL_EMISSIONS'
    /** APR that can be earned thourgh voting, i.e. gauge votes */
    | 'VOTING';

export interface GqlPoolAprRange {
    __typename?: 'GqlPoolAprRange';
    max: Scalars['BigDecimal'];
    min: Scalars['BigDecimal'];
}

export interface GqlPoolAprTotal {
    __typename?: 'GqlPoolAprTotal';
    total: Scalars['BigDecimal'];
}

export type GqlPoolAprValue = GqlPoolAprRange | GqlPoolAprTotal;

/** The base type as returned by poolGetPool (specific pool query) */
export interface GqlPoolBase {
    /** The contract address of the pool. */
    address: Scalars['Bytes'];
    /**
     * Returns all pool tokens, including any nested tokens and phantom BPTs on one level.
     * @deprecated Use poolTokens instead
     */
    allTokens: Array<GqlPoolTokenExpanded>;
    /** List of categories assigned by the team based on external factors */
    categories?: Maybe<Array<Maybe<GqlPoolFilterCategory>>>;
    /** The chain on which the pool is deployed */
    chain: GqlChain;
    /** The timestamp the pool was created. */
    createTime: Scalars['Int'];
    /** The decimals of the BPT, usually 18 */
    decimals: Scalars['Int'];
    /**
     * Only returns main tokens, also known as leave tokens. Wont return any nested BPTs. Used for displaying the tokens that the pool consists of.
     * @deprecated Use poolTokens instead
     */
    displayTokens: Array<GqlPoolTokenDisplay>;
    /** Dynamic data such as token balances, swap fees or volume */
    dynamicData: GqlPoolDynamicData;
    /** The factory contract address from which the pool was created. */
    factory?: Maybe<Scalars['Bytes']>;
    /** The pool id. This is equal to the address for protocolVersion 3 pools */
    id: Scalars['ID'];
    /**
     * Deprecated
     * @deprecated Removed without replacement
     */
    investConfig: GqlPoolInvestConfig;
    /** The name of the pool as per contract */
    name: Scalars['String'];
    /** The wallet address of the owner of the pool. Pool owners can set certain properties like swapFees or AMP. */
    owner?: Maybe<Scalars['Bytes']>;
    /** Returns all pool tokens, including BPTs and nested pools if there are any. Only one nested level deep. */
    poolTokens: Array<GqlPoolTokenDetail>;
    /** The protocol version on which the pool is deployed, 1, 2 or 3 */
    protocolVersion: Scalars['Int'];
    /** Staking options of this pool which emit additional rewards */
    staking?: Maybe<GqlPoolStaking>;
    /** The token symbol of the pool as per contract */
    symbol: Scalars['String'];
    /** List of tags assigned by the team based on external factors */
    tags?: Maybe<Array<Maybe<Scalars['String']>>>;
    /** The pool type, such as weighted, stable, etc. */
    type: GqlPoolType;
    /** If a user address was provided in the query, the user balance is populated here */
    userBalance?: Maybe<GqlPoolUserBalance>;
    /**
     * The vault version on which the pool is deployed, 2 or 3
     * @deprecated use protocolVersion instead
     */
    vaultVersion: Scalars['Int'];
    /** The version of the pool type. */
    version: Scalars['Int'];
    /**
     * Deprecated
     * @deprecated Removed without replacement
     */
    withdrawConfig: GqlPoolWithdrawConfig;
}

export interface GqlPoolBatchSwap {
    __typename?: 'GqlPoolBatchSwap';
    chain: GqlChain;
    id: Scalars['ID'];
    swaps: Array<GqlPoolBatchSwapSwap>;
    timestamp: Scalars['Int'];
    tokenAmountIn: Scalars['String'];
    tokenAmountOut: Scalars['String'];
    tokenIn: Scalars['String'];
    tokenInPrice: Scalars['Float'];
    tokenOut: Scalars['String'];
    tokenOutPrice: Scalars['Float'];
    tx: Scalars['String'];
    userAddress: Scalars['String'];
    valueUSD: Scalars['Float'];
}

export interface GqlPoolBatchSwapPool {
    __typename?: 'GqlPoolBatchSwapPool';
    id: Scalars['ID'];
    tokens: Array<Scalars['String']>;
}

export interface GqlPoolBatchSwapSwap {
    __typename?: 'GqlPoolBatchSwapSwap';
    id: Scalars['ID'];
    pool: GqlPoolMinimal;
    timestamp: Scalars['Int'];
    tokenAmountIn: Scalars['String'];
    tokenAmountOut: Scalars['String'];
    tokenIn: Scalars['String'];
    tokenOut: Scalars['String'];
    tx: Scalars['String'];
    userAddress: Scalars['String'];
    valueUSD: Scalars['Float'];
}

export interface GqlPoolComposableStable extends GqlPoolBase {
    __typename?: 'GqlPoolComposableStable';
    address: Scalars['Bytes'];
    allTokens: Array<GqlPoolTokenExpanded>;
    amp: Scalars['BigInt'];
    bptPriceRate: Scalars['BigDecimal'];
    categories?: Maybe<Array<Maybe<GqlPoolFilterCategory>>>;
    chain: GqlChain;
    createTime: Scalars['Int'];
    decimals: Scalars['Int'];
    displayTokens: Array<GqlPoolTokenDisplay>;
    dynamicData: GqlPoolDynamicData;
    factory?: Maybe<Scalars['Bytes']>;
    id: Scalars['ID'];
    /** @deprecated Removed without replacement */
    investConfig: GqlPoolInvestConfig;
    name: Scalars['String'];
    nestingType: GqlPoolNestingType;
    owner: Scalars['Bytes'];
    poolTokens: Array<GqlPoolTokenDetail>;
    protocolVersion: Scalars['Int'];
    staking?: Maybe<GqlPoolStaking>;
    symbol: Scalars['String'];
    tags?: Maybe<Array<Maybe<Scalars['String']>>>;
    /**
     * All tokens of the pool. If it is a nested pool, the nested pool is expanded with its own tokens again.
     * @deprecated Use poolTokens instead
     */
    tokens: Array<GqlPoolTokenUnion>;
    type: GqlPoolType;
    userBalance?: Maybe<GqlPoolUserBalance>;
    /** @deprecated use protocolVersion instead */
    vaultVersion: Scalars['Int'];
    version: Scalars['Int'];
    /** @deprecated Removed without replacement */
    withdrawConfig: GqlPoolWithdrawConfig;
}

export interface GqlPoolComposableStableNested {
    __typename?: 'GqlPoolComposableStableNested';
    address: Scalars['Bytes'];
    amp: Scalars['BigInt'];
    bptPriceRate: Scalars['BigDecimal'];
    categories?: Maybe<Array<Maybe<GqlPoolFilterCategory>>>;
    createTime: Scalars['Int'];
    factory?: Maybe<Scalars['Bytes']>;
    id: Scalars['ID'];
    name: Scalars['String'];
    nestingType: GqlPoolNestingType;
    owner: Scalars['Bytes'];
    swapFee: Scalars['BigDecimal'];
    symbol: Scalars['String'];
    tags?: Maybe<Array<Maybe<Scalars['String']>>>;
    /** @deprecated Use poolTokens instead */
    tokens: Array<GqlPoolTokenComposableStableNestedUnion>;
    totalLiquidity: Scalars['BigDecimal'];
    totalShares: Scalars['BigDecimal'];
    type: GqlPoolType;
    version: Scalars['Int'];
}

export interface GqlPoolDynamicData {
    __typename?: 'GqlPoolDynamicData';
    /** Protocol and pool creator fees combined */
    aggregateSwapFee: Scalars['BigDecimal'];
    /** Protocol and pool creator fees combined */
    aggregateYieldFee: Scalars['BigDecimal'];
    /** @deprecated Use aprItems instead */
    apr: GqlPoolApr;
    aprItems: Array<GqlPoolAprItem>;
    fees24h: Scalars['BigDecimal'];
    fees24hAth: Scalars['BigDecimal'];
    fees24hAthTimestamp: Scalars['Int'];
    fees24hAtl: Scalars['BigDecimal'];
    fees24hAtlTimestamp: Scalars['Int'];
    fees48h: Scalars['BigDecimal'];
    holdersCount: Scalars['BigInt'];
    /** True for bricked pools */
    isInRecoveryMode: Scalars['Boolean'];
    isPaused: Scalars['Boolean'];
    lifetimeSwapFees: Scalars['BigDecimal'];
    lifetimeVolume: Scalars['BigDecimal'];
    poolId: Scalars['ID'];
    sharePriceAth: Scalars['BigDecimal'];
    sharePriceAthTimestamp: Scalars['Int'];
    sharePriceAtl: Scalars['BigDecimal'];
    sharePriceAtlTimestamp: Scalars['Int'];
    /** CowAmm specific, equivalent of swap fees */
    surplus24h: Scalars['BigDecimal'];
    /** CowAmm specific, equivalent of swap fees */
    surplus48h: Scalars['BigDecimal'];
    /** Disabled for bricked pools */
    swapEnabled: Scalars['Boolean'];
    swapFee: Scalars['BigDecimal'];
    swapsCount: Scalars['BigInt'];
    totalLiquidity: Scalars['BigDecimal'];
    totalLiquidity24hAgo: Scalars['BigDecimal'];
    totalLiquidityAth: Scalars['BigDecimal'];
    totalLiquidityAthTimestamp: Scalars['Int'];
    totalLiquidityAtl: Scalars['BigDecimal'];
    totalLiquidityAtlTimestamp: Scalars['Int'];
    totalShares: Scalars['BigDecimal'];
    totalShares24hAgo: Scalars['BigDecimal'];
    volume24h: Scalars['BigDecimal'];
    volume24hAth: Scalars['BigDecimal'];
    volume24hAthTimestamp: Scalars['Int'];
    volume24hAtl: Scalars['BigDecimal'];
    volume24hAtlTimestamp: Scalars['Int'];
    volume48h: Scalars['BigDecimal'];
    yieldCapture24h: Scalars['BigDecimal'];
    yieldCapture48h: Scalars['BigDecimal'];
}

export interface GqlPoolElement extends GqlPoolBase {
    __typename?: 'GqlPoolElement';
    address: Scalars['Bytes'];
    allTokens: Array<GqlPoolTokenExpanded>;
    baseToken: Scalars['Bytes'];
    categories?: Maybe<Array<Maybe<GqlPoolFilterCategory>>>;
    chain: GqlChain;
    createTime: Scalars['Int'];
    decimals: Scalars['Int'];
    displayTokens: Array<GqlPoolTokenDisplay>;
    dynamicData: GqlPoolDynamicData;
    factory?: Maybe<Scalars['Bytes']>;
    id: Scalars['ID'];
    /** @deprecated Removed without replacement */
    investConfig: GqlPoolInvestConfig;
    name: Scalars['String'];
    owner: Scalars['Bytes'];
    poolTokens: Array<GqlPoolTokenDetail>;
    principalToken: Scalars['Bytes'];
    protocolVersion: Scalars['Int'];
    staking?: Maybe<GqlPoolStaking>;
    symbol: Scalars['String'];
    tags?: Maybe<Array<Maybe<Scalars['String']>>>;
    /** @deprecated Use poolTokens instead */
    tokens: Array<GqlPoolToken>;
    type: GqlPoolType;
    unitSeconds: Scalars['BigInt'];
    userBalance?: Maybe<GqlPoolUserBalance>;
    /** @deprecated use protocolVersion instead */
    vaultVersion: Scalars['Int'];
    version: Scalars['Int'];
    /** @deprecated Removed without replacement */
    withdrawConfig: GqlPoolWithdrawConfig;
}

/** Represents an event that occurs in a pool. */
export interface GqlPoolEvent {
    /** The block number of the event. */
    blockNumber: Scalars['Int'];
    /** The block timestamp of the event. */
    blockTimestamp: Scalars['Int'];
    /** The chain on which the event occurred. */
    chain: GqlChain;
    /** The unique identifier of the event. */
    id: Scalars['ID'];
    /** The log index of the event. */
    logIndex: Scalars['Int'];
    /** The pool ID associated with the event. */
    poolId: Scalars['String'];
    /** The sender of the event. */
    sender: Scalars['String'];
    /** The timestamp of the event. */
    timestamp: Scalars['Int'];
    /** The transaction hash of the event. */
    tx: Scalars['String'];
    /** The type of the event. */
    type: GqlPoolEventType;
    /** The user address associated with the event. */
    userAddress: Scalars['String'];
    /** The USD value of this event. */
    valueUSD: Scalars['Float'];
}

export interface GqlPoolEventAmount {
    __typename?: 'GqlPoolEventAmount';
    address: Scalars['String'];
    amount: Scalars['String'];
    valueUSD: Scalars['Float'];
}

export type GqlPoolEventType = 'ADD' | 'REMOVE' | 'SWAP';

export type GqlPoolEventsDataRange = 'NINETY_DAYS' | 'SEVEN_DAYS' | 'THIRTY_DAYS';

export interface GqlPoolEventsFilter {
    chainIn?: InputMaybe<Array<InputMaybe<GqlChain>>>;
    poolIdIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
    range?: InputMaybe<GqlPoolEventsDataRange>;
    typeIn?: InputMaybe<Array<InputMaybe<GqlPoolEventType>>>;
    userAddress?: InputMaybe<Scalars['String']>;
    /** USD value of the event */
    valueUSD_gt?: InputMaybe<Scalars['Float']>;
    /** USD value of the event */
    valueUSD_gte?: InputMaybe<Scalars['Float']>;
}

export interface GqlPoolFeaturedPool {
    __typename?: 'GqlPoolFeaturedPool';
    description: Scalars['String'];
    pool: GqlPoolBase;
    poolId: Scalars['ID'];
    primary: Scalars['Boolean'];
}

export interface GqlPoolFeaturedPoolGroup {
    __typename?: 'GqlPoolFeaturedPoolGroup';
    icon: Scalars['String'];
    id: Scalars['ID'];
    items: Array<GqlPoolFeaturedPoolGroupItem>;
    title: Scalars['String'];
}

export type GqlPoolFeaturedPoolGroupItem = GqlFeaturePoolGroupItemExternalLink | GqlPoolMinimal;

export interface GqlPoolFilter {
    categoryIn?: InputMaybe<Array<GqlPoolFilterCategory>>;
    categoryNotIn?: InputMaybe<Array<GqlPoolFilterCategory>>;
    chainIn?: InputMaybe<Array<GqlChain>>;
    chainNotIn?: InputMaybe<Array<GqlChain>>;
    createTime?: InputMaybe<GqlPoolTimePeriod>;
    filterIn?: InputMaybe<Array<Scalars['String']>>;
    filterNotIn?: InputMaybe<Array<Scalars['String']>>;
    idIn?: InputMaybe<Array<Scalars['String']>>;
    idNotIn?: InputMaybe<Array<Scalars['String']>>;
    minTvl?: InputMaybe<Scalars['Float']>;
    poolTypeIn?: InputMaybe<Array<GqlPoolType>>;
    poolTypeNotIn?: InputMaybe<Array<GqlPoolType>>;
    protocolVersionIn?: InputMaybe<Array<Scalars['Int']>>;
    /**
     * For list of tags see: https://github.com/balancer/metadata/blob/main/pools/index.json
     * Use uppercase
     */
    tagIn?: InputMaybe<Array<Scalars['String']>>;
    /**
     * For list of tags see: https://github.com/balancer/metadata/blob/main/pools/index.json
     * Use uppercase
     */
    tagNotIn?: InputMaybe<Array<Scalars['String']>>;
    tokensIn?: InputMaybe<Array<Scalars['String']>>;
    tokensNotIn?: InputMaybe<Array<Scalars['String']>>;
    userAddress?: InputMaybe<Scalars['String']>;
}

export type GqlPoolFilterCategory =
    | 'BLACK_LISTED'
    | 'INCENTIVIZED'
    | 'LRT'
    | 'POINTS'
    | 'POINTS_EIGENLAYER'
    | 'POINTS_GYRO'
    | 'POINTS_KELP'
    | 'POINTS_RENZO'
    | 'POINTS_SWELL'
    | 'SUPERFEST';

export interface GqlPoolFx extends GqlPoolBase {
    __typename?: 'GqlPoolFx';
    address: Scalars['Bytes'];
    allTokens: Array<GqlPoolTokenExpanded>;
    alpha: Scalars['String'];
    beta: Scalars['String'];
    categories?: Maybe<Array<Maybe<GqlPoolFilterCategory>>>;
    chain: GqlChain;
    createTime: Scalars['Int'];
    decimals: Scalars['Int'];
    delta: Scalars['String'];
    displayTokens: Array<GqlPoolTokenDisplay>;
    dynamicData: GqlPoolDynamicData;
    epsilon: Scalars['String'];
    factory?: Maybe<Scalars['Bytes']>;
    id: Scalars['ID'];
    /** @deprecated Removed without replacement */
    investConfig: GqlPoolInvestConfig;
    lambda: Scalars['String'];
    name: Scalars['String'];
    owner?: Maybe<Scalars['Bytes']>;
    poolTokens: Array<GqlPoolTokenDetail>;
    protocolVersion: Scalars['Int'];
    staking?: Maybe<GqlPoolStaking>;
    symbol: Scalars['String'];
    tags?: Maybe<Array<Maybe<Scalars['String']>>>;
    /**
     * All tokens of the pool. If it is a nested pool, the nested pool is expanded with its own tokens again.
     * @deprecated Use poolTokens instead
     */
    tokens: Array<GqlPoolTokenUnion>;
    type: GqlPoolType;
    userBalance?: Maybe<GqlPoolUserBalance>;
    /** @deprecated use protocolVersion instead */
    vaultVersion: Scalars['Int'];
    version: Scalars['Int'];
    /** @deprecated Removed without replacement */
    withdrawConfig: GqlPoolWithdrawConfig;
}

export interface GqlPoolGyro extends GqlPoolBase {
    __typename?: 'GqlPoolGyro';
    address: Scalars['Bytes'];
    allTokens: Array<GqlPoolTokenExpanded>;
    alpha: Scalars['String'];
    beta: Scalars['String'];
    c: Scalars['String'];
    categories?: Maybe<Array<Maybe<GqlPoolFilterCategory>>>;
    chain: GqlChain;
    createTime: Scalars['Int'];
    dSq: Scalars['String'];
    decimals: Scalars['Int'];
    displayTokens: Array<GqlPoolTokenDisplay>;
    dynamicData: GqlPoolDynamicData;
    factory?: Maybe<Scalars['Bytes']>;
    id: Scalars['ID'];
    /** @deprecated Removed without replacement */
    investConfig: GqlPoolInvestConfig;
    lambda: Scalars['String'];
    name: Scalars['String'];
    nestingType: GqlPoolNestingType;
    owner: Scalars['Bytes'];
    poolTokens: Array<GqlPoolTokenDetail>;
    protocolVersion: Scalars['Int'];
    root3Alpha: Scalars['String'];
    s: Scalars['String'];
    sqrtAlpha: Scalars['String'];
    sqrtBeta: Scalars['String'];
    staking?: Maybe<GqlPoolStaking>;
    symbol: Scalars['String'];
    tags?: Maybe<Array<Maybe<Scalars['String']>>>;
    tauAlphaX: Scalars['String'];
    tauAlphaY: Scalars['String'];
    tauBetaX: Scalars['String'];
    tauBetaY: Scalars['String'];
    /**
     * All tokens of the pool. If it is a nested pool, the nested pool is expanded with its own tokens again.
     * @deprecated Use poolTokens instead
     */
    tokens: Array<GqlPoolTokenUnion>;
    type: GqlPoolType;
    u: Scalars['String'];
    userBalance?: Maybe<GqlPoolUserBalance>;
    v: Scalars['String'];
    /** @deprecated use protocolVersion instead */
    vaultVersion: Scalars['Int'];
    version: Scalars['Int'];
    w: Scalars['String'];
    /** @deprecated Removed without replacement */
    withdrawConfig: GqlPoolWithdrawConfig;
    z: Scalars['String'];
}

export interface GqlPoolInvestConfig {
    __typename?: 'GqlPoolInvestConfig';
    options: Array<GqlPoolInvestOption>;
    proportionalEnabled: Scalars['Boolean'];
    singleAssetEnabled: Scalars['Boolean'];
}

export interface GqlPoolInvestOption {
    __typename?: 'GqlPoolInvestOption';
    poolTokenAddress: Scalars['String'];
    poolTokenIndex: Scalars['Int'];
    tokenOptions: Array<GqlPoolToken>;
}

export interface GqlPoolJoinExit {
    __typename?: 'GqlPoolJoinExit';
    amounts: Array<GqlPoolJoinExitAmount>;
    chain: GqlChain;
    id: Scalars['ID'];
    poolId: Scalars['String'];
    sender: Scalars['String'];
    timestamp: Scalars['Int'];
    tx: Scalars['String'];
    type: GqlPoolJoinExitType;
    valueUSD?: Maybe<Scalars['String']>;
}

export interface GqlPoolJoinExitAmount {
    __typename?: 'GqlPoolJoinExitAmount';
    address: Scalars['String'];
    amount: Scalars['String'];
}

export interface GqlPoolJoinExitFilter {
    chainIn?: InputMaybe<Array<GqlChain>>;
    poolIdIn?: InputMaybe<Array<Scalars['String']>>;
}

export type GqlPoolJoinExitType = 'Exit' | 'Join';

export interface GqlPoolLiquidityBootstrapping extends GqlPoolBase {
    __typename?: 'GqlPoolLiquidityBootstrapping';
    address: Scalars['Bytes'];
    allTokens: Array<GqlPoolTokenExpanded>;
    categories?: Maybe<Array<Maybe<GqlPoolFilterCategory>>>;
    chain: GqlChain;
    createTime: Scalars['Int'];
    decimals: Scalars['Int'];
    displayTokens: Array<GqlPoolTokenDisplay>;
    dynamicData: GqlPoolDynamicData;
    factory?: Maybe<Scalars['Bytes']>;
    id: Scalars['ID'];
    /** @deprecated Removed without replacement */
    investConfig: GqlPoolInvestConfig;
    name: Scalars['String'];
    nestingType: GqlPoolNestingType;
    owner: Scalars['Bytes'];
    poolTokens: Array<GqlPoolTokenDetail>;
    protocolVersion: Scalars['Int'];
    staking?: Maybe<GqlPoolStaking>;
    symbol: Scalars['String'];
    tags?: Maybe<Array<Maybe<Scalars['String']>>>;
    /**
     * All tokens of the pool. If it is a nested pool, the nested pool is expanded with its own tokens again.
     * @deprecated Use poolTokens instead
     */
    tokens: Array<GqlPoolTokenUnion>;
    type: GqlPoolType;
    userBalance?: Maybe<GqlPoolUserBalance>;
    /** @deprecated use protocolVersion instead */
    vaultVersion: Scalars['Int'];
    version: Scalars['Int'];
    /** @deprecated Removed without replacement */
    withdrawConfig: GqlPoolWithdrawConfig;
}

export interface GqlPoolMetaStable extends GqlPoolBase {
    __typename?: 'GqlPoolMetaStable';
    address: Scalars['Bytes'];
    allTokens: Array<GqlPoolTokenExpanded>;
    amp: Scalars['BigInt'];
    categories?: Maybe<Array<Maybe<GqlPoolFilterCategory>>>;
    chain: GqlChain;
    createTime: Scalars['Int'];
    decimals: Scalars['Int'];
    displayTokens: Array<GqlPoolTokenDisplay>;
    dynamicData: GqlPoolDynamicData;
    factory?: Maybe<Scalars['Bytes']>;
    id: Scalars['ID'];
    /** @deprecated Removed without replacement */
    investConfig: GqlPoolInvestConfig;
    name: Scalars['String'];
    owner: Scalars['Bytes'];
    poolTokens: Array<GqlPoolTokenDetail>;
    protocolVersion: Scalars['Int'];
    staking?: Maybe<GqlPoolStaking>;
    symbol: Scalars['String'];
    tags?: Maybe<Array<Maybe<Scalars['String']>>>;
    /** @deprecated Use poolTokens instead */
    tokens: Array<GqlPoolToken>;
    type: GqlPoolType;
    userBalance?: Maybe<GqlPoolUserBalance>;
    /** @deprecated use protocolVersion instead */
    vaultVersion: Scalars['Int'];
    version: Scalars['Int'];
    /** @deprecated Removed without replacement */
    withdrawConfig: GqlPoolWithdrawConfig;
}

/** The pool schema returned for poolGetPools (pool list query) */
export interface GqlPoolMinimal {
    __typename?: 'GqlPoolMinimal';
    /** The contract address of the pool. */
    address: Scalars['Bytes'];
    /** Returns all pool tokens, including any nested tokens and phantom BPTs */
    allTokens: Array<GqlPoolTokenExpanded>;
    /** List of categories assigned by the team based on external factors */
    categories?: Maybe<Array<Maybe<GqlPoolFilterCategory>>>;
    /** The chain on which the pool is deployed */
    chain: GqlChain;
    /** The timestamp the pool was created. */
    createTime: Scalars['Int'];
    /** The decimals of the BPT, usually 18 */
    decimals: Scalars['Int'];
    /** Only returns main or underlying tokens, also known as leave tokens. Wont return any nested BPTs. Used for displaying the tokens that the pool consists of. */
    displayTokens: Array<GqlPoolTokenDisplay>;
    /** Dynamic data such as token balances, swap fees or volume */
    dynamicData: GqlPoolDynamicData;
    /** The factory contract address from which the pool was created. */
    factory?: Maybe<Scalars['Bytes']>;
    /** Whether at least one token in this pool is considered an ERC4626 token. */
    hasErc4626: Scalars['Boolean'];
    /** Hook assigned to a pool */
    hook?: Maybe<Hook>;
    /** The pool id. This is equal to the address for protocolVersion 3 pools */
    id: Scalars['ID'];
    /** Pool is receiving rewards when liquidity tokens are staked */
    incentivized: Scalars['Boolean'];
    /** The name of the pool as per contract */
    name: Scalars['String'];
    /** The wallet address of the owner of the pool. Pool owners can set certain properties like swapFees or AMP. */
    owner?: Maybe<Scalars['Bytes']>;
    /** The protocol version on which the pool is deployed, 1, 2 or 3 */
    protocolVersion: Scalars['Int'];
    /** Staking options of this pool which emit additional rewards */
    staking?: Maybe<GqlPoolStaking>;
    /** The token symbol of the pool as per contract */
    symbol: Scalars['String'];
    /** List of tags assigned by the team based on external factors */
    tags?: Maybe<Array<Maybe<Scalars['String']>>>;
    /** The pool type, such as weighted, stable, etc. */
    type: GqlPoolType;
    /** If a user address was provided in the query, the user balance is populated here */
    userBalance?: Maybe<GqlPoolUserBalance>;
    /**
     * The vault version on which the pool is deployed, 2 or 3
     * @deprecated use protocolVersion instead
     */
    vaultVersion: Scalars['Int'];
    /** The version of the pool type. */
    version: Scalars['Int'];
}

/** Result of the poolReloadPools mutation */
export interface GqlPoolMutationResult {
    __typename?: 'GqlPoolMutationResult';
    /** The chain that was reloaded. */
    chain: GqlChain;
    /** The error message */
    error?: Maybe<Scalars['String']>;
    /** Whether it was successful or not. */
    success: Scalars['Boolean'];
    /** The type of pools that were reloaded. */
    type: Scalars['String'];
}

export type GqlPoolNestedUnion = GqlPoolComposableStableNested;

export type GqlPoolNestingType = 'HAS_ONLY_PHANTOM_BPT' | 'HAS_SOME_PHANTOM_BPT' | 'NO_NESTING';

export type GqlPoolOrderBy = 'apr' | 'fees24h' | 'totalLiquidity' | 'totalShares' | 'userbalanceUsd' | 'volume24h';

export type GqlPoolOrderDirection = 'asc' | 'desc';

export interface GqlPoolSnapshot {
    __typename?: 'GqlPoolSnapshot';
    amounts: Array<Scalars['String']>;
    chain: GqlChain;
    fees24h: Scalars['String'];
    holdersCount: Scalars['String'];
    id: Scalars['ID'];
    poolId: Scalars['String'];
    sharePrice: Scalars['String'];
    surplus24h: Scalars['String'];
    swapsCount: Scalars['String'];
    timestamp: Scalars['Int'];
    totalLiquidity: Scalars['String'];
    totalShares: Scalars['String'];
    totalSurplus: Scalars['String'];
    totalSwapFee: Scalars['String'];
    totalSwapVolume: Scalars['String'];
    volume24h: Scalars['String'];
}

export type GqlPoolSnapshotDataRange =
    | 'ALL_TIME'
    | 'NINETY_DAYS'
    | 'ONE_HUNDRED_EIGHTY_DAYS'
    | 'ONE_YEAR'
    | 'THIRTY_DAYS';

export interface GqlPoolStable extends GqlPoolBase {
    __typename?: 'GqlPoolStable';
    address: Scalars['Bytes'];
    allTokens: Array<GqlPoolTokenExpanded>;
    amp: Scalars['BigInt'];
    categories?: Maybe<Array<Maybe<GqlPoolFilterCategory>>>;
    chain: GqlChain;
    createTime: Scalars['Int'];
    decimals: Scalars['Int'];
    displayTokens: Array<GqlPoolTokenDisplay>;
    dynamicData: GqlPoolDynamicData;
    factory?: Maybe<Scalars['Bytes']>;
    id: Scalars['ID'];
    /** @deprecated Removed without replacement */
    investConfig: GqlPoolInvestConfig;
    name: Scalars['String'];
    owner: Scalars['Bytes'];
    poolTokens: Array<GqlPoolTokenDetail>;
    protocolVersion: Scalars['Int'];
    staking?: Maybe<GqlPoolStaking>;
    symbol: Scalars['String'];
    tags?: Maybe<Array<Maybe<Scalars['String']>>>;
    /** @deprecated Use poolTokens instead */
    tokens: Array<GqlPoolToken>;
    type: GqlPoolType;
    userBalance?: Maybe<GqlPoolUserBalance>;
    /** @deprecated use protocolVersion instead */
    vaultVersion: Scalars['Int'];
    version: Scalars['Int'];
    /** @deprecated Removed without replacement */
    withdrawConfig: GqlPoolWithdrawConfig;
}

export interface GqlPoolStableComposablePoolData {
    __typename?: 'GqlPoolStableComposablePoolData';
    address: Scalars['String'];
    balance: Scalars['String'];
    id: Scalars['ID'];
    symbol: Scalars['String'];
    tokens: Array<GqlPoolToken>;
    totalSupply: Scalars['String'];
}

export interface GqlPoolStaking {
    __typename?: 'GqlPoolStaking';
    address: Scalars['String'];
    aura?: Maybe<GqlPoolStakingAura>;
    chain: GqlChain;
    farm?: Maybe<GqlPoolStakingMasterChefFarm>;
    gauge?: Maybe<GqlPoolStakingGauge>;
    id: Scalars['ID'];
    reliquary?: Maybe<GqlPoolStakingReliquaryFarm>;
    type: GqlPoolStakingType;
    vebal?: Maybe<GqlPoolStakingVebal>;
}

export interface GqlPoolStakingAura {
    __typename?: 'GqlPoolStakingAura';
    apr: Scalars['Float'];
    auraPoolAddress: Scalars['String'];
    auraPoolId: Scalars['String'];
    id: Scalars['ID'];
    isShutdown: Scalars['Boolean'];
}

export interface GqlPoolStakingFarmRewarder {
    __typename?: 'GqlPoolStakingFarmRewarder';
    address: Scalars['String'];
    id: Scalars['ID'];
    rewardPerSecond: Scalars['String'];
    tokenAddress: Scalars['String'];
}

export interface GqlPoolStakingGauge {
    __typename?: 'GqlPoolStakingGauge';
    gaugeAddress: Scalars['String'];
    id: Scalars['ID'];
    otherGauges?: Maybe<Array<GqlPoolStakingOtherGauge>>;
    rewards: Array<GqlPoolStakingGaugeReward>;
    status: GqlPoolStakingGaugeStatus;
    version: Scalars['Int'];
    workingSupply: Scalars['String'];
}

export interface GqlPoolStakingGaugeReward {
    __typename?: 'GqlPoolStakingGaugeReward';
    id: Scalars['ID'];
    rewardPerSecond: Scalars['String'];
    tokenAddress: Scalars['String'];
}

export type GqlPoolStakingGaugeStatus = 'ACTIVE' | 'KILLED' | 'PREFERRED';

export interface GqlPoolStakingMasterChefFarm {
    __typename?: 'GqlPoolStakingMasterChefFarm';
    beetsPerBlock: Scalars['String'];
    id: Scalars['ID'];
    rewarders?: Maybe<Array<GqlPoolStakingFarmRewarder>>;
}

export interface GqlPoolStakingOtherGauge {
    __typename?: 'GqlPoolStakingOtherGauge';
    gaugeAddress: Scalars['String'];
    id: Scalars['ID'];
    rewards: Array<GqlPoolStakingGaugeReward>;
    status: GqlPoolStakingGaugeStatus;
    version: Scalars['Int'];
}

export interface GqlPoolStakingReliquaryFarm {
    __typename?: 'GqlPoolStakingReliquaryFarm';
    beetsPerSecond: Scalars['String'];
    id: Scalars['ID'];
    levels?: Maybe<Array<GqlPoolStakingReliquaryFarmLevel>>;
    totalBalance: Scalars['String'];
    totalWeightedBalance: Scalars['String'];
}

export interface GqlPoolStakingReliquaryFarmLevel {
    __typename?: 'GqlPoolStakingReliquaryFarmLevel';
    allocationPoints: Scalars['Int'];
    apr: Scalars['BigDecimal'];
    balance: Scalars['BigDecimal'];
    id: Scalars['ID'];
    level: Scalars['Int'];
    requiredMaturity: Scalars['Int'];
}

export type GqlPoolStakingType = 'AURA' | 'FRESH_BEETS' | 'GAUGE' | 'MASTER_CHEF' | 'RELIQUARY' | 'VEBAL';

export interface GqlPoolStakingVebal {
    __typename?: 'GqlPoolStakingVebal';
    id: Scalars['ID'];
    vebalAddress: Scalars['String'];
}

export interface GqlPoolSwap {
    __typename?: 'GqlPoolSwap';
    chain: GqlChain;
    id: Scalars['ID'];
    poolId: Scalars['String'];
    timestamp: Scalars['Int'];
    tokenAmountIn: Scalars['String'];
    tokenAmountOut: Scalars['String'];
    tokenIn: Scalars['String'];
    tokenOut: Scalars['String'];
    tx: Scalars['String'];
    userAddress: Scalars['String'];
    valueUSD: Scalars['Float'];
}

/** Represents an event that occurs when a swap is made in a pool using the CowAmm protocol. */
export interface GqlPoolSwapEventCowAmm extends GqlPoolEvent {
    __typename?: 'GqlPoolSwapEventCowAmm';
    /** The block number of the event. */
    blockNumber: Scalars['Int'];
    /** The block timestamp of the event. */
    blockTimestamp: Scalars['Int'];
    /** The chain on which the event occurred. */
    chain: GqlChain;
    /** The fee that this swap generated. */
    fee: GqlPoolEventAmount;
    /** The unique identifier of the event. */
    id: Scalars['ID'];
    /** The log index of the event. */
    logIndex: Scalars['Int'];
    /** The pool ID associated with the event. */
    poolId: Scalars['String'];
    /** The sender of the event. */
    sender: Scalars['String'];
    /** The surplus generated by the swap. */
    surplus: GqlPoolEventAmount;
    /** The timestamp of the event. */
    timestamp: Scalars['Int'];
    /** The token that was swapped in the event. */
    tokenIn: GqlPoolEventAmount;
    /** The token that was swapped out in the event. */
    tokenOut: GqlPoolEventAmount;
    /** The transaction hash of the event. */
    tx: Scalars['String'];
    /** The type of the event. */
    type: GqlPoolEventType;
    /** The user address associated with the event. */
    userAddress: Scalars['String'];
    /** The value of the event in USD. */
    valueUSD: Scalars['Float'];
}

/** Represents an event that occurs when a swap is made in a pool. */
export interface GqlPoolSwapEventV3 extends GqlPoolEvent {
    __typename?: 'GqlPoolSwapEventV3';
    /** The block number of the event. */
    blockNumber: Scalars['Int'];
    /** The block timestamp of the event. */
    blockTimestamp: Scalars['Int'];
    /** The chain on which the event occurred. */
    chain: GqlChain;
    /** The fee that this swap generated. */
    fee: GqlPoolEventAmount;
    /** The unique identifier of the event. */
    id: Scalars['ID'];
    /** The log index of the event. */
    logIndex: Scalars['Int'];
    /** The pool ID associated with the event. */
    poolId: Scalars['String'];
    /** The sender of the event. */
    sender: Scalars['String'];
    /** The timestamp of the event. */
    timestamp: Scalars['Int'];
    /** The token that was swapped in the event. */
    tokenIn: GqlPoolEventAmount;
    /** The token that was swapped out in the event. */
    tokenOut: GqlPoolEventAmount;
    /** The transaction hash of the event. */
    tx: Scalars['String'];
    /** The type of the event. */
    type: GqlPoolEventType;
    /** The user address associated with the event. */
    userAddress: Scalars['String'];
    /** The value of the event in USD. */
    valueUSD: Scalars['Float'];
}

export interface GqlPoolSwapFilter {
    chainIn?: InputMaybe<Array<GqlChain>>;
    poolIdIn?: InputMaybe<Array<Scalars['String']>>;
    tokenInIn?: InputMaybe<Array<Scalars['String']>>;
    tokenOutIn?: InputMaybe<Array<Scalars['String']>>;
}

export interface GqlPoolTimePeriod {
    gt?: InputMaybe<Scalars['Int']>;
    lt?: InputMaybe<Scalars['Int']>;
}

export interface GqlPoolToken extends GqlPoolTokenBase {
    __typename?: 'GqlPoolToken';
    address: Scalars['String'];
    balance: Scalars['BigDecimal'];
    decimals: Scalars['Int'];
    id: Scalars['ID'];
    index: Scalars['Int'];
    name: Scalars['String'];
    priceRate: Scalars['BigDecimal'];
    priceRateProvider?: Maybe<Scalars['String']>;
    symbol: Scalars['String'];
    totalBalance: Scalars['BigDecimal'];
    weight?: Maybe<Scalars['BigDecimal']>;
}

export interface GqlPoolTokenBase {
    address: Scalars['String'];
    balance: Scalars['BigDecimal'];
    decimals: Scalars['Int'];
    id: Scalars['ID'];
    index: Scalars['Int'];
    name: Scalars['String'];
    priceRate: Scalars['BigDecimal'];
    priceRateProvider?: Maybe<Scalars['String']>;
    symbol: Scalars['String'];
    totalBalance: Scalars['BigDecimal'];
    weight?: Maybe<Scalars['BigDecimal']>;
}

export interface GqlPoolTokenComposableStable extends GqlPoolTokenBase {
    __typename?: 'GqlPoolTokenComposableStable';
    address: Scalars['String'];
    balance: Scalars['BigDecimal'];
    decimals: Scalars['Int'];
    id: Scalars['ID'];
    index: Scalars['Int'];
    name: Scalars['String'];
    pool: GqlPoolComposableStableNested;
    priceRate: Scalars['BigDecimal'];
    priceRateProvider?: Maybe<Scalars['String']>;
    symbol: Scalars['String'];
    totalBalance: Scalars['BigDecimal'];
    weight?: Maybe<Scalars['BigDecimal']>;
}

export type GqlPoolTokenComposableStableNestedUnion = GqlPoolToken;

/**
 * All info on the pool token. It will also include the nested pool if the token is a BPT. It will only support 1 level of nesting.
 * A second (unsupported) level of nesting is shown by having hasNestedPool = true but nestedPool = null.
 */
export interface GqlPoolTokenDetail {
    __typename?: 'GqlPoolTokenDetail';
    /** Address of the pool token. */
    address: Scalars['String'];
    /** Balance of the pool token inside the pool. */
    balance: Scalars['BigDecimal'];
    /** USD Balance of the pool token. */
    balanceUSD: Scalars['BigDecimal'];
    /** Decimals of the pool token. */
    decimals: Scalars['Int'];
    /** Indicates whether this token is a BPT and therefor has a nested pool. */
    hasNestedPool: Scalars['Boolean'];
    /** Id of the token. A combination of pool id and token address. */
    id: Scalars['ID'];
    /** Index of the pool token in the pool as returned by the vault. */
    index: Scalars['Int'];
    /** Whether the token is in the allow list. */
    isAllowed: Scalars['Boolean'];
    /** Whether the token is considered an ERC4626 token. */
    isErc4626: Scalars['Boolean'];
    /** Name of the pool token. */
    name: Scalars['String'];
    /** Additional data for the nested pool if the token is a BPT. Null otherwise. */
    nestedPool?: Maybe<GqlNestedPool>;
    /** If it is an appreciating token, it shows the current price rate. 1 otherwise. */
    priceRate: Scalars['BigDecimal'];
    /** The address of the price rate provider. */
    priceRateProvider?: Maybe<Scalars['String']>;
    /** Additional data for the price rate provider, such as reviews or warnings. */
    priceRateProviderData?: Maybe<GqlPriceRateProviderData>;
    /** Symbol of the pool token. */
    symbol: Scalars['String'];
    /** If it is an Erc4262, this will be the underlying token if present in the API. */
    underlyingToken?: Maybe<GqlToken>;
    /** The weight of the token in the pool if it is a weighted pool, null otherwise */
    weight?: Maybe<Scalars['BigDecimal']>;
}

export interface GqlPoolTokenDisplay {
    __typename?: 'GqlPoolTokenDisplay';
    address: Scalars['String'];
    id: Scalars['ID'];
    name: Scalars['String'];
    nestedTokens?: Maybe<Array<GqlPoolTokenDisplay>>;
    symbol: Scalars['String'];
    weight?: Maybe<Scalars['BigDecimal']>;
}

export interface GqlPoolTokenExpanded {
    __typename?: 'GqlPoolTokenExpanded';
    address: Scalars['String'];
    decimals: Scalars['Int'];
    id: Scalars['ID'];
    isErc4626: Scalars['Boolean'];
    isMainToken: Scalars['Boolean'];
    isNested: Scalars['Boolean'];
    isPhantomBpt: Scalars['Boolean'];
    name: Scalars['String'];
    symbol: Scalars['String'];
    weight?: Maybe<Scalars['String']>;
}

export type GqlPoolTokenUnion = GqlPoolToken | GqlPoolTokenComposableStable;

/** Supported pool types */
export type GqlPoolType =
    | 'COMPOSABLE_STABLE'
    | 'COW_AMM'
    | 'ELEMENT'
    | 'FX'
    | 'GYRO'
    | 'GYRO3'
    | 'GYROE'
    | 'INVESTMENT'
    | 'LIQUIDITY_BOOTSTRAPPING'
    | 'META_STABLE'
    | 'PHANTOM_STABLE'
    | 'STABLE'
    | 'UNKNOWN'
    | 'WEIGHTED';

export type GqlPoolUnion =
    | GqlPoolComposableStable
    | GqlPoolElement
    | GqlPoolFx
    | GqlPoolGyro
    | GqlPoolLiquidityBootstrapping
    | GqlPoolMetaStable
    | GqlPoolStable
    | GqlPoolWeighted;

/** If a user address was provided in the query, the user balance is populated here */
export interface GqlPoolUserBalance {
    __typename?: 'GqlPoolUserBalance';
    /** The staked BPT balances of the user. */
    stakedBalances: Array<GqlUserStakedBalance>;
    /** Total balance (wallet + staked) as float */
    totalBalance: Scalars['AmountHumanReadable'];
    /** Total balance (wallet + staked) in USD as float */
    totalBalanceUsd: Scalars['Float'];
    /** The wallet balance (BPT in wallet) as float. */
    walletBalance: Scalars['AmountHumanReadable'];
    /** The wallet balance (BPT in wallet) in USD as float. */
    walletBalanceUsd: Scalars['Float'];
}

export interface GqlPoolUserSwapVolume {
    __typename?: 'GqlPoolUserSwapVolume';
    swapVolumeUSD: Scalars['BigDecimal'];
    userAddress: Scalars['String'];
}

export interface GqlPoolWeighted extends GqlPoolBase {
    __typename?: 'GqlPoolWeighted';
    address: Scalars['Bytes'];
    allTokens: Array<GqlPoolTokenExpanded>;
    categories?: Maybe<Array<Maybe<GqlPoolFilterCategory>>>;
    chain: GqlChain;
    createTime: Scalars['Int'];
    decimals: Scalars['Int'];
    displayTokens: Array<GqlPoolTokenDisplay>;
    dynamicData: GqlPoolDynamicData;
    factory?: Maybe<Scalars['Bytes']>;
    id: Scalars['ID'];
    /** @deprecated Removed without replacement */
    investConfig: GqlPoolInvestConfig;
    name: Scalars['String'];
    nestingType: GqlPoolNestingType;
    owner: Scalars['Bytes'];
    poolTokens: Array<GqlPoolTokenDetail>;
    protocolVersion: Scalars['Int'];
    staking?: Maybe<GqlPoolStaking>;
    symbol: Scalars['String'];
    tags?: Maybe<Array<Maybe<Scalars['String']>>>;
    /**
     * All tokens of the pool. If it is a nested pool, the nested pool is expanded with its own tokens again.
     * @deprecated Use poolTokens instead
     */
    tokens: Array<GqlPoolTokenUnion>;
    type: GqlPoolType;
    userBalance?: Maybe<GqlPoolUserBalance>;
    /** @deprecated use protocolVersion instead */
    vaultVersion: Scalars['Int'];
    version: Scalars['Int'];
    /** @deprecated Removed without replacement */
    withdrawConfig: GqlPoolWithdrawConfig;
}

export interface GqlPoolWithdrawConfig {
    __typename?: 'GqlPoolWithdrawConfig';
    options: Array<GqlPoolWithdrawOption>;
    proportionalEnabled: Scalars['Boolean'];
    singleAssetEnabled: Scalars['Boolean'];
}

export interface GqlPoolWithdrawOption {
    __typename?: 'GqlPoolWithdrawOption';
    poolTokenAddress: Scalars['String'];
    poolTokenIndex: Scalars['Int'];
    tokenOptions: Array<GqlPoolToken>;
}

/** Returns the price impact of the path. If there is an error in the price impact calculation, priceImpact will be undefined but the error string is populated. */
export interface GqlPriceImpact {
    __typename?: 'GqlPriceImpact';
    /** If priceImpact cant be calculated and is returned as undefined, the error string will be populated. */
    error?: Maybe<Scalars['String']>;
    /** Price impact in percent 0.01 -> 0.01%; undefined if an error happened. */
    priceImpact?: Maybe<Scalars['AmountHumanReadable']>;
}

/** Represents the data of a price rate provider */
export interface GqlPriceRateProviderData {
    __typename?: 'GqlPriceRateProviderData';
    /** The address of the price rate provider */
    address: Scalars['String'];
    /** The factory used to create the price rate provider, if applicable */
    factory?: Maybe<Scalars['String']>;
    /** The name of the price rate provider */
    name?: Maybe<Scalars['String']>;
    /** The filename of the review of the price rate provider */
    reviewFile?: Maybe<Scalars['String']>;
    /** Indicates if the price rate provider has been reviewed */
    reviewed: Scalars['Boolean'];
    /** A summary of the price rate provider, usually just says safe or unsafe */
    summary?: Maybe<Scalars['String']>;
    /** Upgradeable components of the price rate provider */
    upgradeableComponents?: Maybe<Array<Maybe<GqlPriceRateProviderUpgradeableComponent>>>;
    /** Warnings associated with the price rate provider */
    warnings?: Maybe<Array<Scalars['String']>>;
}

/** Represents an upgradeable component of a price rate provider */
export interface GqlPriceRateProviderUpgradeableComponent {
    __typename?: 'GqlPriceRateProviderUpgradeableComponent';
    /** The entry point / proxy of the upgradeable component */
    entryPoint: Scalars['String'];
    /** Indicates if the implementation of the component has been reviewed */
    implementationReviewed: Scalars['String'];
}

export interface GqlProtocolMetricsAggregated {
    __typename?: 'GqlProtocolMetricsAggregated';
    chains: Array<GqlProtocolMetricsChain>;
    numLiquidityProviders: Scalars['BigInt'];
    poolCount: Scalars['BigInt'];
    swapFee24h: Scalars['BigDecimal'];
    swapVolume24h: Scalars['BigDecimal'];
    totalLiquidity: Scalars['BigDecimal'];
    totalSwapFee: Scalars['BigDecimal'];
    totalSwapVolume: Scalars['BigDecimal'];
    yieldCapture24h: Scalars['BigDecimal'];
}

export interface GqlProtocolMetricsChain {
    __typename?: 'GqlProtocolMetricsChain';
    chainId: Scalars['String'];
    numLiquidityProviders: Scalars['BigInt'];
    poolCount: Scalars['BigInt'];
    swapFee24h: Scalars['BigDecimal'];
    swapVolume24h: Scalars['BigDecimal'];
    totalLiquidity: Scalars['BigDecimal'];
    totalSwapFee: Scalars['BigDecimal'];
    totalSwapVolume: Scalars['BigDecimal'];
    yieldCapture24h: Scalars['BigDecimal'];
}

export interface GqlRelicSnapshot {
    __typename?: 'GqlRelicSnapshot';
    balance: Scalars['String'];
    entryTimestamp: Scalars['Int'];
    farmId: Scalars['String'];
    level: Scalars['Int'];
    relicId: Scalars['Int'];
}

export interface GqlReliquaryFarmLevelSnapshot {
    __typename?: 'GqlReliquaryFarmLevelSnapshot';
    balance: Scalars['String'];
    id: Scalars['ID'];
    level: Scalars['String'];
}

export interface GqlReliquaryFarmSnapshot {
    __typename?: 'GqlReliquaryFarmSnapshot';
    dailyDeposited: Scalars['String'];
    dailyWithdrawn: Scalars['String'];
    farmId: Scalars['String'];
    id: Scalars['ID'];
    levelBalances: Array<GqlReliquaryFarmLevelSnapshot>;
    relicCount: Scalars['String'];
    timestamp: Scalars['Int'];
    tokenBalances: Array<GqlReliquaryTokenBalanceSnapshot>;
    totalBalance: Scalars['String'];
    totalLiquidity: Scalars['String'];
    userCount: Scalars['String'];
}

export interface GqlReliquaryTokenBalanceSnapshot {
    __typename?: 'GqlReliquaryTokenBalanceSnapshot';
    address: Scalars['String'];
    balance: Scalars['String'];
    decimals: Scalars['Int'];
    id: Scalars['ID'];
    name: Scalars['String'];
    symbol: Scalars['String'];
}

export interface GqlSftmxStakingData {
    __typename?: 'GqlSftmxStakingData';
    /** Current exchange rate for sFTMx -> FTM */
    exchangeRate: Scalars['String'];
    /** Whether maintenance is paused. This pauses reward claiming or harvesting and withdrawing from matured vaults. */
    maintenancePaused: Scalars['Boolean'];
    /** The maximum FTM amount to depost. */
    maxDepositLimit: Scalars['AmountHumanReadable'];
    /** The minimum FTM amount to deposit. */
    minDepositLimit: Scalars['AmountHumanReadable'];
    /** Number of vaults that delegated to validators. */
    numberOfVaults: Scalars['Int'];
    /** The current rebasing APR for sFTMx. */
    stakingApr: Scalars['String'];
    /** Total amount of FTM in custody of sFTMx. Staked FTM plus free pool FTM. */
    totalFtmAmount: Scalars['AmountHumanReadable'];
    /** Total amount of FTM in the free pool. */
    totalFtmAmountInPool: Scalars['AmountHumanReadable'];
    /** Total amount of FTM staked/delegated to validators. */
    totalFtmAmountStaked: Scalars['AmountHumanReadable'];
    /** Whether undelegation is paused. Undelegate is the first step to redeem sFTMx. */
    undelegatePaused: Scalars['Boolean'];
    /** A list of all the vaults that delegated to validators. */
    vaults: Array<GqlSftmxStakingVault>;
    /** Whether withdrawals are paused. Withdraw is the second and final step to redeem sFTMx. */
    withdrawPaused: Scalars['Boolean'];
    /** Delay to wait between undelegate (1st step) and withdraw (2nd step). */
    withdrawalDelay: Scalars['Int'];
}

export interface GqlSftmxStakingSnapshot {
    __typename?: 'GqlSftmxStakingSnapshot';
    /** Current exchange rate for sFTMx -> FTM */
    exchangeRate: Scalars['String'];
    id: Scalars['ID'];
    /** The timestamp of the snapshot. Timestamp is end of day midnight. */
    timestamp: Scalars['Int'];
    /** Total amount of FTM in custody of sFTMx. Staked FTM plus free pool FTM. */
    totalFtmAmount: Scalars['AmountHumanReadable'];
    /** Total amount of FTM in the free pool. */
    totalFtmAmountInPool: Scalars['AmountHumanReadable'];
    /** Total amount of FTM staked/delegated to validators. */
    totalFtmAmountStaked: Scalars['AmountHumanReadable'];
}

export type GqlSftmxStakingSnapshotDataRange =
    | 'ALL_TIME'
    | 'NINETY_DAYS'
    | 'ONE_HUNDRED_EIGHTY_DAYS'
    | 'ONE_YEAR'
    | 'THIRTY_DAYS';

export interface GqlSftmxStakingVault {
    __typename?: 'GqlSftmxStakingVault';
    /** The amount of FTM that has been delegated via this vault. */
    ftmAmountStaked: Scalars['AmountHumanReadable'];
    /** Whether the vault is matured, meaning whether unlock time has passed. */
    isMatured: Scalars['Boolean'];
    /** Timestamp when the delegated FTM unlocks, matures. */
    unlockTimestamp: Scalars['Int'];
    /** The address of the validator that the vault has delegated to. */
    validatorAddress: Scalars['String'];
    /** The ID of the validator that the vault has delegated to. */
    validatorId: Scalars['String'];
    /** The contract address of the vault. */
    vaultAddress: Scalars['String'];
    /** The internal index of the vault. */
    vaultIndex: Scalars['Int'];
}

export interface GqlSftmxWithdrawalRequests {
    __typename?: 'GqlSftmxWithdrawalRequests';
    /** Amount of sFTMx that is being redeemed. */
    amountSftmx: Scalars['AmountHumanReadable'];
    /** The Withdrawal ID, used for interactions. */
    id: Scalars['String'];
    /** Whether the requests is finished and the user has withdrawn. */
    isWithdrawn: Scalars['Boolean'];
    /** The timestamp when the request was placed. There is a delay until the user can withdraw. See withdrawalDelay. */
    requestTimestamp: Scalars['Int'];
    /** The user address that this request belongs to. */
    user: Scalars['String'];
}

export interface GqlSorCallData {
    __typename?: 'GqlSorCallData';
    /** The call data that needs to be sent to the RPC */
    callData: Scalars['String'];
    /** Maximum amount to be sent for exact out orders */
    maxAmountInRaw?: Maybe<Scalars['String']>;
    /** Minimum amount received for exact in orders */
    minAmountOutRaw?: Maybe<Scalars['String']>;
    /** The target contract to send the call data to */
    to: Scalars['String'];
    /** Value in ETH that needs to be sent for native swaps */
    value: Scalars['BigDecimal'];
}

/** The swap paths for a swap */
export interface GqlSorGetSwapPaths {
    __typename?: 'GqlSorGetSwapPaths';
    /** Transaction data that can be posted to an RPC to execute the swap. */
    callData?: Maybe<GqlSorCallData>;
    /** The price of tokenOut in tokenIn. */
    effectivePrice: Scalars['AmountHumanReadable'];
    /** The price of tokenIn in tokenOut. */
    effectivePriceReversed: Scalars['AmountHumanReadable'];
    /** The found paths as needed as input for the b-sdk to execute the swap */
    paths: Array<GqlSorPath>;
    /** Price impact of the path */
    priceImpact: GqlPriceImpact;
    /** The version of the protocol these paths are from */
    protocolVersion: Scalars['Int'];
    /** The return amount in human form. Return amount is either tokenOutAmount (if swapType is exactIn) or tokenInAmount (if swapType is exactOut) */
    returnAmount: Scalars['AmountHumanReadable'];
    /** The return amount in a raw form */
    returnAmountRaw: Scalars['BigDecimal'];
    /** The swap routes including pool information. Used to display by the UI */
    routes: Array<GqlSorSwapRoute>;
    /** The swap amount in human form. Swap amount is either tokenInAmount (if swapType is exactIn) or tokenOutAmount (if swapType is exactOut) */
    swapAmount: Scalars['AmountHumanReadable'];
    /** The swap amount in a raw form */
    swapAmountRaw: Scalars['BigDecimal'];
    /** The swapType that was provided, exact_in vs exact_out (givenIn vs givenOut) */
    swapType: GqlSorSwapType;
    /** Swaps as needed for the vault swap input to execute the swap */
    swaps: Array<GqlSorSwap>;
    /** All token addresses (or assets) as needed for the vault swap input to execute the swap */
    tokenAddresses: Array<Scalars['String']>;
    /** The token address of the tokenIn provided */
    tokenIn: Scalars['String'];
    /** The amount of tokenIn in human form */
    tokenInAmount: Scalars['AmountHumanReadable'];
    /** The token address of the tokenOut provided */
    tokenOut: Scalars['String'];
    /** The amount of tokenOut in human form */
    tokenOutAmount: Scalars['AmountHumanReadable'];
    /**
     * The version of the vault these paths are from
     * @deprecated Use protocolVersion instead
     */
    vaultVersion: Scalars['Int'];
}

export interface GqlSorGetSwapsResponse {
    __typename?: 'GqlSorGetSwapsResponse';
    effectivePrice: Scalars['AmountHumanReadable'];
    effectivePriceReversed: Scalars['AmountHumanReadable'];
    marketSp: Scalars['String'];
    priceImpact: Scalars['AmountHumanReadable'];
    returnAmount: Scalars['AmountHumanReadable'];
    returnAmountConsideringFees: Scalars['BigDecimal'];
    returnAmountFromSwaps?: Maybe<Scalars['BigDecimal']>;
    returnAmountScaled: Scalars['BigDecimal'];
    routes: Array<GqlSorSwapRoute>;
    swapAmount: Scalars['AmountHumanReadable'];
    swapAmountForSwaps?: Maybe<Scalars['BigDecimal']>;
    swapAmountScaled: Scalars['BigDecimal'];
    swapType: GqlSorSwapType;
    swaps: Array<GqlSorSwap>;
    tokenAddresses: Array<Scalars['String']>;
    tokenIn: Scalars['String'];
    tokenInAmount: Scalars['AmountHumanReadable'];
    tokenOut: Scalars['String'];
    tokenOutAmount: Scalars['AmountHumanReadable'];
}

/** A path of a swap. A swap can have multiple paths. Used as input to execute the swap via b-sdk */
export interface GqlSorPath {
    __typename?: 'GqlSorPath';
    /** Input amount of this path in scaled form */
    inputAmountRaw: Scalars['String'];
    /** A sorted list of booleans that indicate if the respective pool is a buffer */
    isBuffer: Array<Maybe<Scalars['Boolean']>>;
    /** Output amount of this path in scaled form */
    outputAmountRaw: Scalars['String'];
    /** A sorted list of pool ids that are used in this path */
    pools: Array<Maybe<Scalars['String']>>;
    /** The version of the protocol these paths are from */
    protocolVersion: Scalars['Int'];
    /** A sorted list of tokens that are ussed in this path */
    tokens: Array<Maybe<Token>>;
    /**
     * Vault version of this path.
     * @deprecated Use protocolVersion instead
     */
    vaultVersion: Scalars['Int'];
}

/** A single swap step as used for input to the vault to execute a swap */
export interface GqlSorSwap {
    __typename?: 'GqlSorSwap';
    /** Amount to be swapped in this step. 0 for chained swap. */
    amount: Scalars['String'];
    /** Index of the asset used in the tokenAddress array. */
    assetInIndex: Scalars['Int'];
    /** Index of the asset used in the tokenAddress array. */
    assetOutIndex: Scalars['Int'];
    /** Pool id used in this swap step */
    poolId: Scalars['String'];
    /** UserData used in this swap, generally uses defaults. */
    userData: Scalars['String'];
}

export interface GqlSorSwapOptionsInput {
    forceRefresh?: InputMaybe<Scalars['Boolean']>;
    maxPools?: InputMaybe<Scalars['Int']>;
    queryBatchSwap?: InputMaybe<Scalars['Boolean']>;
    timestamp?: InputMaybe<Scalars['Int']>;
}

/** The swap routes including pool information. Used to display by the UI */
export interface GqlSorSwapRoute {
    __typename?: 'GqlSorSwapRoute';
    /** The hops this route takes */
    hops: Array<GqlSorSwapRouteHop>;
    /** Share of this route of the total swap */
    share: Scalars['Float'];
    /** Address of the tokenIn */
    tokenIn: Scalars['String'];
    /** Amount of the tokenIn in human form */
    tokenInAmount: Scalars['AmountHumanReadable'];
    /** Address of the tokenOut */
    tokenOut: Scalars['String'];
    /** Amount of the tokenOut in human form */
    tokenOutAmount: Scalars['AmountHumanReadable'];
}

/** A hop of a route. A route can have many hops meaning it traverses more than one pool. */
export interface GqlSorSwapRouteHop {
    __typename?: 'GqlSorSwapRouteHop';
    /** The pool entity of this hop. */
    pool: GqlPoolMinimal;
    /** The pool id of this hop. */
    poolId: Scalars['String'];
    /** Address of the tokenIn */
    tokenIn: Scalars['String'];
    /** Amount of the tokenIn in human form */
    tokenInAmount: Scalars['AmountHumanReadable'];
    /** Address of the tokenOut */
    tokenOut: Scalars['String'];
    /** Amount of the tokenOut in human form */
    tokenOutAmount: Scalars['AmountHumanReadable'];
}

export type GqlSorSwapType = 'EXACT_IN' | 'EXACT_OUT';

/** Inputs for the call data to create the swap transaction. If this input is given, call data is added to the response. */
export interface GqlSwapCallDataInput {
    /** How long the swap should be valid, provide a timestamp. "999999999999999999" for infinite. Default: infinite */
    deadline?: InputMaybe<Scalars['Int']>;
    /** Who receives the output amount. */
    receiver: Scalars['String'];
    /** Who sends the input amount. */
    sender: Scalars['String'];
    /** The max slippage in percent 0.01 -> 0.01% */
    slippagePercentage: Scalars['String'];
}

/** Represents a token */
export interface GqlToken {
    __typename?: 'GqlToken';
    /** The address of the token */
    address: Scalars['String'];
    /** The chain of the token */
    chain: GqlChain;
    /** The chain ID of the token */
    chainId: Scalars['Int'];
    /** The coingecko ID for this token, if present */
    coingeckoId?: Maybe<Scalars['String']>;
    /** The number of decimal places for the token */
    decimals: Scalars['Int'];
    /** The description of the token */
    description?: Maybe<Scalars['String']>;
    /** The Discord URL of the token */
    discordUrl?: Maybe<Scalars['String']>;
    /** Whether the token is considered an ERC4626 token. */
    isErc4626: Scalars['Boolean'];
    /** The logo URI of the token */
    logoURI?: Maybe<Scalars['String']>;
    /** The name of the token */
    name: Scalars['String'];
    /** The rate provider data for the token */
    priceRateProviderData?: Maybe<GqlPriceRateProviderData>;
    /** The priority of the token, can be used for sorting. */
    priority: Scalars['Int'];
    /** The rate provider data for the token */
    rateProviderData?: Maybe<GqlPriceRateProviderData>;
    /** The symbol of the token */
    symbol: Scalars['String'];
    /** The Telegram URL of the token */
    telegramUrl?: Maybe<Scalars['String']>;
    /** Indicates if the token is tradable */
    tradable: Scalars['Boolean'];
    /** The Twitter username of the token */
    twitterUsername?: Maybe<Scalars['String']>;
    /** The website URL of the token */
    websiteUrl?: Maybe<Scalars['String']>;
}

export interface GqlTokenAmountHumanReadable {
    address: Scalars['String'];
    amount: Scalars['AmountHumanReadable'];
}

export interface GqlTokenCandlestickChartDataItem {
    __typename?: 'GqlTokenCandlestickChartDataItem';
    close: Scalars['AmountHumanReadable'];
    high: Scalars['AmountHumanReadable'];
    id: Scalars['ID'];
    low: Scalars['AmountHumanReadable'];
    open: Scalars['AmountHumanReadable'];
    timestamp: Scalars['Int'];
}

export type GqlTokenChartDataRange = 'NINETY_DAY' | 'ONE_HUNDRED_EIGHTY_DAY' | 'ONE_YEAR' | 'SEVEN_DAY' | 'THIRTY_DAY';

export interface GqlTokenData {
    __typename?: 'GqlTokenData';
    description?: Maybe<Scalars['String']>;
    discordUrl?: Maybe<Scalars['String']>;
    id: Scalars['ID'];
    telegramUrl?: Maybe<Scalars['String']>;
    tokenAddress: Scalars['String'];
    twitterUsername?: Maybe<Scalars['String']>;
    websiteUrl?: Maybe<Scalars['String']>;
}

/** Represents additional data for a token */
export interface GqlTokenDynamicData {
    __typename?: 'GqlTokenDynamicData';
    /** The all-time high price of the token */
    ath: Scalars['Float'];
    /** The all-time low price of the token */
    atl: Scalars['Float'];
    /** The fully diluted valuation of the token */
    fdv?: Maybe<Scalars['String']>;
    /** The highest price in the last 24 hours */
    high24h: Scalars['Float'];
    /** The unique identifier of the dynamic data */
    id: Scalars['String'];
    /** The lowest price in the last 24 hours */
    low24h: Scalars['Float'];
    /** The market capitalization of the token */
    marketCap?: Maybe<Scalars['String']>;
    /** The current price of the token */
    price: Scalars['Float'];
    /** The price change in the last 24 hours */
    priceChange24h: Scalars['Float'];
    /** The percentage price change in the last 7 days */
    priceChangePercent7d?: Maybe<Scalars['Float']>;
    /** The percentage price change in the last 14 days */
    priceChangePercent14d?: Maybe<Scalars['Float']>;
    /** The percentage price change in the last 24 hours */
    priceChangePercent24h: Scalars['Float'];
    /** The percentage price change in the last 30 days */
    priceChangePercent30d?: Maybe<Scalars['Float']>;
    /** The address of the token */
    tokenAddress: Scalars['String'];
    /** The timestamp when the data was last updated */
    updatedAt: Scalars['String'];
}

/** Result of the poolReloadPools mutation */
export interface GqlTokenMutationResult {
    __typename?: 'GqlTokenMutationResult';
    /** The chain that was reloaded. */
    chain: GqlChain;
    /** The error message */
    error?: Maybe<Scalars['String']>;
    /** Whether it was successful or not. */
    success: Scalars['Boolean'];
}

export interface GqlTokenPrice {
    __typename?: 'GqlTokenPrice';
    address: Scalars['String'];
    chain: GqlChain;
    price: Scalars['Float'];
    updatedAt: Scalars['Int'];
    updatedBy?: Maybe<Scalars['String']>;
}

export interface GqlTokenPriceChartDataItem {
    __typename?: 'GqlTokenPriceChartDataItem';
    id: Scalars['ID'];
    price: Scalars['AmountHumanReadable'];
    timestamp: Scalars['Int'];
}

export type GqlTokenType = 'BPT' | 'PHANTOM_BPT' | 'WHITE_LISTED';

export interface GqlUserFbeetsBalance {
    __typename?: 'GqlUserFbeetsBalance';
    id: Scalars['String'];
    stakedBalance: Scalars['AmountHumanReadable'];
    totalBalance: Scalars['AmountHumanReadable'];
    walletBalance: Scalars['AmountHumanReadable'];
}

export interface GqlUserPoolBalance {
    __typename?: 'GqlUserPoolBalance';
    chain: GqlChain;
    poolId: Scalars['String'];
    stakedBalance: Scalars['AmountHumanReadable'];
    tokenAddress: Scalars['String'];
    tokenPrice: Scalars['Float'];
    totalBalance: Scalars['AmountHumanReadable'];
    walletBalance: Scalars['AmountHumanReadable'];
}

export interface GqlUserStakedBalance {
    __typename?: 'GqlUserStakedBalance';
    /** The staked BPT balance as float. */
    balance: Scalars['AmountHumanReadable'];
    /** The steaked BPT balance in USD as float. */
    balanceUsd: Scalars['Float'];
    /** The id of the staking to match with GqlPoolStaking.id. */
    stakingId: Scalars['String'];
    /** The staking type (Gauge, farm, aura, etc.) in which this balance is staked. */
    stakingType: GqlPoolStakingType;
}

export interface GqlUserSwapVolumeFilter {
    poolIdIn?: InputMaybe<Array<Scalars['String']>>;
    tokenInIn?: InputMaybe<Array<Scalars['String']>>;
    tokenOutIn?: InputMaybe<Array<Scalars['String']>>;
}

export interface GqlVeBalBalance {
    __typename?: 'GqlVeBalBalance';
    balance: Scalars['AmountHumanReadable'];
    chain: GqlChain;
    locked: Scalars['AmountHumanReadable'];
    lockedUsd: Scalars['AmountHumanReadable'];
}

export interface GqlVeBalUserData {
    __typename?: 'GqlVeBalUserData';
    balance: Scalars['AmountHumanReadable'];
    locked: Scalars['AmountHumanReadable'];
    lockedUsd: Scalars['AmountHumanReadable'];
    rank?: Maybe<Scalars['Int']>;
}

/** The Gauge that can be voted on through veBAL and that will ultimately receive the rewards. */
export interface GqlVotingGauge {
    __typename?: 'GqlVotingGauge';
    /** The timestamp the gauge was added. */
    addedTimestamp?: Maybe<Scalars['Int']>;
    /** The address of the root gauge on Ethereum mainnet. */
    address: Scalars['Bytes'];
    /** The address of the child gauge on the specific chain. */
    childGaugeAddress?: Maybe<Scalars['Bytes']>;
    /** Whether the gauge is killed or not. */
    isKilled: Scalars['Boolean'];
    /** The relative weight the gauge received this epoch (not more than 1.0). */
    relativeWeight: Scalars['String'];
    /** The relative weight cap. 1.0 for uncapped. */
    relativeWeightCap?: Maybe<Scalars['String']>;
}

/** A token inside of a pool with a voting gauge. */
export interface GqlVotingGaugeToken {
    __typename?: 'GqlVotingGaugeToken';
    /** The address of the token. */
    address: Scalars['String'];
    /** The URL to the token logo. */
    logoURI: Scalars['String'];
    /** The symbol of the token. */
    symbol: Scalars['String'];
    /** If it is a weighted pool, the weigh of the token is shown here in %. 0.5 = 50%. */
    weight?: Maybe<Scalars['String']>;
}

/** The pool that can be voted on through veBAL */
export interface GqlVotingPool {
    __typename?: 'GqlVotingPool';
    /** The address of the pool. */
    address: Scalars['Bytes'];
    /** The chain this pool is on. */
    chain: GqlChain;
    /** The gauge that is connected to the pool and that will receive the rewards. */
    gauge: GqlVotingGauge;
    /** Pool ID */
    id: Scalars['ID'];
    /** The symbol of the pool. */
    symbol: Scalars['String'];
    /** The tokens inside the pool. */
    tokens: Array<GqlVotingGaugeToken>;
    /** The type of the pool. */
    type: GqlPoolType;
}

/** Hook data */
export interface Hook {
    __typename?: 'Hook';
    address: Scalars['String'];
    chain: GqlChain;
    /** Data points changing over time */
    dynamicData?: Maybe<HookData>;
    /** True when hook can change the amounts send to the vault. Necessary to deduct the fees. */
    enableHookAdjustedAmounts: Scalars['Boolean'];
    /** List of pools using the hook */
    poolsIds?: Maybe<Array<Maybe<Scalars['String']>>>;
    shouldCallAfterAddLiquidity: Scalars['Boolean'];
    shouldCallAfterInitialize: Scalars['Boolean'];
    shouldCallAfterRemoveLiquidity: Scalars['Boolean'];
    shouldCallAfterSwap: Scalars['Boolean'];
    shouldCallBeforeAddLiquidity: Scalars['Boolean'];
    shouldCallBeforeInitialize: Scalars['Boolean'];
    shouldCallBeforeRemoveLiquidity: Scalars['Boolean'];
    shouldCallBeforeSwap: Scalars['Boolean'];
    shouldCallComputeDynamicSwapFee: Scalars['Boolean'];
}

/** Collection of hook specific data. Percentage format is 0.01 -> 0.01%. */
export interface HookData {
    __typename?: 'HookData';
    addLiquidityFeePercentage?: Maybe<Scalars['String']>;
    removeLiquidityFeePercentage?: Maybe<Scalars['String']>;
    swapFeePercentage?: Maybe<Scalars['String']>;
}

export interface Mutation {
    __typename?: 'Mutation';
    beetsPoolLoadReliquarySnapshotsForAllFarms: Scalars['String'];
    beetsSyncFbeetsRatio: Scalars['String'];
    cacheAverageBlockTime: Scalars['String'];
    poolBlackListAddPool: Scalars['String'];
    poolBlackListRemovePool: Scalars['String'];
    poolDeletePool: Scalars['String'];
    poolInitOnChainDataForAllPools: Scalars['String'];
    poolInitializeSnapshotsForPool: Scalars['String'];
    poolLoadOnChainDataForAllPools: Scalars['String'];
    poolLoadOnChainDataForPoolsWithActiveUpdates: Scalars['String'];
    poolLoadSnapshotsForAllPools: Scalars['String'];
    poolLoadSnapshotsForPools: Scalars['String'];
    poolReloadAllPoolAprs: Scalars['String'];
    poolReloadAllTokenNestedPoolIds: Scalars['String'];
    poolReloadPools: Array<GqlPoolMutationResult>;
    poolReloadStakingForAllPools: Scalars['String'];
    poolSyncAllCowSnapshots: Array<GqlPoolMutationResult>;
    poolSyncAllPoolsFromSubgraph: Array<Scalars['String']>;
    poolSyncLatestSnapshotsForAllPools: Scalars['String'];
    poolSyncNewPoolsFromSubgraph: Array<Scalars['String']>;
    poolSyncPool: Scalars['String'];
    poolSyncPoolAllTokensRelationship: Scalars['String'];
    poolSyncSanityPoolData: Scalars['String'];
    poolSyncStakingForPools: Scalars['String'];
    poolSyncSwapsForLast48Hours: Scalars['String'];
    poolSyncTotalShares: Scalars['String'];
    poolUpdateAprs: Scalars['String'];
    poolUpdateLifetimeValuesForAllPools: Scalars['String'];
    poolUpdateLiquidity24hAgoForAllPools: Scalars['String'];
    poolUpdateLiquidityValuesForAllPools: Scalars['String'];
    poolUpdateVolumeAndFeeValuesForAllPools: Scalars['String'];
    protocolCacheMetrics: Scalars['String'];
    sftmxSyncStakingData: Scalars['String'];
    sftmxSyncWithdrawalRequests: Scalars['String'];
    tokenDeleteTokenType: Scalars['String'];
    tokenReloadAllTokenTypes: Scalars['String'];
    tokenReloadErc4626Tokens: Array<GqlTokenMutationResult>;
    tokenReloadTokenPrices?: Maybe<Scalars['Boolean']>;
    tokenSyncLatestFxPrices: Scalars['String'];
    tokenSyncTokenDefinitions: Scalars['String'];
    userInitStakedBalances: Scalars['String'];
    userInitWalletBalancesForAllPools: Scalars['String'];
    userInitWalletBalancesForPool: Scalars['String'];
    userSyncBalance: Scalars['String'];
    userSyncBalanceAllPools: Scalars['String'];
    userSyncChangedStakedBalances: Scalars['String'];
    userSyncChangedWalletBalancesForAllPools: Scalars['String'];
    veBalSyncAllUserBalances: Scalars['String'];
    veBalSyncTotalSupply: Scalars['String'];
}

export interface MutationPoolBlackListAddPoolArgs {
    poolId: Scalars['String'];
}

export interface MutationPoolBlackListRemovePoolArgs {
    poolId: Scalars['String'];
}

export interface MutationPoolDeletePoolArgs {
    poolId: Scalars['String'];
}

export interface MutationPoolInitializeSnapshotsForPoolArgs {
    poolId: Scalars['String'];
}

export interface MutationPoolLoadSnapshotsForPoolsArgs {
    poolIds: Array<Scalars['String']>;
    reload?: InputMaybe<Scalars['Boolean']>;
}

export interface MutationPoolReloadAllPoolAprsArgs {
    chain: GqlChain;
}

export interface MutationPoolReloadPoolsArgs {
    chains: Array<GqlChain>;
}

export interface MutationPoolReloadStakingForAllPoolsArgs {
    stakingTypes: Array<GqlPoolStakingType>;
}

export interface MutationPoolSyncAllCowSnapshotsArgs {
    chains: Array<GqlChain>;
}

export interface MutationPoolSyncLatestSnapshotsForAllPoolsArgs {
    chain: GqlChain;
}

export interface MutationPoolSyncPoolArgs {
    poolId: Scalars['String'];
}

export interface MutationPoolUpdateAprsArgs {
    chain: GqlChain;
}

export interface MutationTokenDeleteTokenTypeArgs {
    tokenAddress: Scalars['String'];
    type: GqlTokenType;
}

export interface MutationTokenReloadErc4626TokensArgs {
    chains: Array<GqlChain>;
}

export interface MutationTokenReloadTokenPricesArgs {
    chains: Array<GqlChain>;
}

export interface MutationTokenSyncLatestFxPricesArgs {
    chain: GqlChain;
}

export interface MutationUserInitStakedBalancesArgs {
    stakingTypes: Array<GqlPoolStakingType>;
}

export interface MutationUserInitWalletBalancesForPoolArgs {
    poolId: Scalars['String'];
}

export interface MutationUserSyncBalanceArgs {
    poolId: Scalars['String'];
}

export interface Query {
    __typename?: 'Query';
    beetsGetFbeetsRatio: Scalars['String'];
    beetsPoolGetReliquaryFarmSnapshots: Array<GqlReliquaryFarmSnapshot>;
    blocksGetAverageBlockTime: Scalars['Float'];
    blocksGetBlocksPerDay: Scalars['Float'];
    blocksGetBlocksPerSecond: Scalars['Float'];
    blocksGetBlocksPerYear: Scalars['Float'];
    contentGetNewsItems: Array<GqlContentNewsItem>;
    /** Returns list of hooks. */
    hooks?: Maybe<Array<Hook>>;
    latestSyncedBlocks: GqlLatestSyncedBlocks;
    /** Getting swap, add and remove events with paging */
    poolEvents: Array<GqlPoolEvent>;
    /** Returns all pools for a given filter, specific for aggregators */
    poolGetAggregatorPools: Array<GqlPoolAggregator>;
    /**
     * Will de deprecated in favor of poolEvents
     * @deprecated Use poolEvents instead
     */
    poolGetBatchSwaps: Array<GqlPoolBatchSwap>;
    /** Getting swap, add and remove events with range */
    poolGetEvents: Array<GqlPoolEvent>;
    /**
     * Will de deprecated in favor of poolGetFeaturedPools
     * @deprecated Use poolGetFeaturedPools instead
     */
    poolGetFeaturedPoolGroups: Array<GqlPoolFeaturedPoolGroup>;
    /** Returns the list of featured pools for chains */
    poolGetFeaturedPools: Array<GqlPoolFeaturedPool>;
    /**
     * Will de deprecated in favor of poolEvents
     * @deprecated Use poolEvents instead
     */
    poolGetJoinExits: Array<GqlPoolJoinExit>;
    /** Returns one pool. If a user address is provided, the user balances for the given pool will also be returned. */
    poolGetPool: GqlPoolBase;
    /** Returns all pools for a given filter */
    poolGetPools: Array<GqlPoolMinimal>;
    /** Returns the number of pools for a given filter. */
    poolGetPoolsCount: Scalars['Int'];
    /** Gets all the snapshots for a given pool on a chain for a certain range */
    poolGetSnapshots: Array<GqlPoolSnapshot>;
    /**
     * Will de deprecated in favor of poolEvents
     * @deprecated Use poolEvents instead
     */
    poolGetSwaps: Array<GqlPoolSwap>;
    protocolMetricsAggregated: GqlProtocolMetricsAggregated;
    protocolMetricsChain: GqlProtocolMetricsChain;
    /** Get the staking data and status for sFTMx */
    sftmxGetStakingData: GqlSftmxStakingData;
    /** Get snapshots for sftmx staking for a specific range */
    sftmxGetStakingSnapshots: Array<GqlSftmxStakingSnapshot>;
    /** Retrieve the withdrawalrequests from a user */
    sftmxGetWithdrawalRequests: Array<GqlSftmxWithdrawalRequests>;
    /** Get swap quote from the SOR v2 for the V2 vault */
    sorGetSwapPaths: GqlSorGetSwapPaths;
    /** Get swap quote from the SOR, queries both the old and new SOR */
    sorGetSwaps: GqlSorGetSwapsResponse;
    /**
     * Returns the candlestick chart data for a token for a given range.
     * @deprecated Use tokenGetHistoricalPrices instead
     */
    tokenGetCandlestickChartData: Array<GqlTokenCandlestickChartDataItem>;
    /** Returns all current prices for allowed tokens for a given chain or chains */
    tokenGetCurrentPrices: Array<GqlTokenPrice>;
    /** Returns the historical prices for a given set of tokens for a given chain and range */
    tokenGetHistoricalPrices: Array<GqlHistoricalTokenPrice>;
    /**
     * DEPRECATED: Returns pricing data for a given token for a given range
     * @deprecated Use tokenGetHistoricalPrices instead
     */
    tokenGetPriceChartData: Array<GqlTokenPriceChartDataItem>;
    /**
     * Returns the price of either BAL or BEETS depending on chain
     * @deprecated Use tokenGetTokensDynamicData instead
     */
    tokenGetProtocolTokenPrice: Scalars['AmountHumanReadable'];
    /** Returns the price of a token priced in another token for a given range. */
    tokenGetRelativePriceChartData: Array<GqlTokenPriceChartDataItem>;
    /**
     * Returns meta data for a given token such as description, website, etc.
     * @deprecated Use tokenGetTokens instead
     */
    tokenGetTokenData?: Maybe<GqlTokenData>;
    /** Returns dynamic data of a token such as price, market cap, etc. */
    tokenGetTokenDynamicData?: Maybe<GqlTokenDynamicData>;
    /** Returns all allowed tokens for a given chain or chains */
    tokenGetTokens: Array<GqlToken>;
    /**
     * Returns meta data for a given set of tokens such as description, website, etc.
     * @deprecated Use tokenGetTokens instead
     */
    tokenGetTokensData: Array<GqlTokenData>;
    /** Returns dynamic data of a set of tokens such as price, market cap, etc. */
    tokenGetTokensDynamicData: Array<GqlTokenDynamicData>;
    userGetFbeetsBalance: GqlUserFbeetsBalance;
    userGetPoolBalances: Array<GqlUserPoolBalance>;
    /** Will de deprecated in favor of poolGetEvents */
    userGetPoolJoinExits: Array<GqlPoolJoinExit>;
    userGetStaking: Array<GqlPoolStaking>;
    /** Will de deprecated in favor of poolGetEvents */
    userGetSwaps: Array<GqlPoolSwap>;
    veBalGetTotalSupply: Scalars['AmountHumanReadable'];
    veBalGetUser: GqlVeBalUserData;
    veBalGetUserBalance: Scalars['AmountHumanReadable'];
    veBalGetUserBalances: Array<GqlVeBalBalance>;
    /** Returns all pools with veBAL gauges that can be voted on. */
    veBalGetVotingList: Array<GqlVotingPool>;
}

export interface QueryBeetsPoolGetReliquaryFarmSnapshotsArgs {
    id: Scalars['String'];
    range: GqlPoolSnapshotDataRange;
}

export interface QueryContentGetNewsItemsArgs {
    chain?: InputMaybe<GqlChain>;
}

export interface QueryHooksArgs {
    chain?: InputMaybe<GqlChain>;
}

export interface QueryPoolEventsArgs {
    first?: InputMaybe<Scalars['Int']>;
    skip?: InputMaybe<Scalars['Int']>;
    where?: InputMaybe<GqlPoolEventsFilter>;
}

export interface QueryPoolGetAggregatorPoolsArgs {
    first?: InputMaybe<Scalars['Int']>;
    orderBy?: InputMaybe<GqlPoolOrderBy>;
    orderDirection?: InputMaybe<GqlPoolOrderDirection>;
    skip?: InputMaybe<Scalars['Int']>;
    where?: InputMaybe<GqlPoolFilter>;
}

export interface QueryPoolGetBatchSwapsArgs {
    first?: InputMaybe<Scalars['Int']>;
    skip?: InputMaybe<Scalars['Int']>;
    where?: InputMaybe<GqlPoolSwapFilter>;
}

export interface QueryPoolGetEventsArgs {
    chain: GqlChain;
    poolId: Scalars['String'];
    range: GqlPoolEventsDataRange;
    typeIn: Array<GqlPoolEventType>;
    userAddress?: InputMaybe<Scalars['String']>;
}

export interface QueryPoolGetFeaturedPoolGroupsArgs {
    chains?: InputMaybe<Array<GqlChain>>;
}

export interface QueryPoolGetFeaturedPoolsArgs {
    chains: Array<GqlChain>;
}

export interface QueryPoolGetJoinExitsArgs {
    first?: InputMaybe<Scalars['Int']>;
    skip?: InputMaybe<Scalars['Int']>;
    where?: InputMaybe<GqlPoolJoinExitFilter>;
}

export interface QueryPoolGetPoolArgs {
    chain?: InputMaybe<GqlChain>;
    id: Scalars['String'];
    userAddress?: InputMaybe<Scalars['String']>;
}

export interface QueryPoolGetPoolsArgs {
    first?: InputMaybe<Scalars['Int']>;
    orderBy?: InputMaybe<GqlPoolOrderBy>;
    orderDirection?: InputMaybe<GqlPoolOrderDirection>;
    skip?: InputMaybe<Scalars['Int']>;
    textSearch?: InputMaybe<Scalars['String']>;
    where?: InputMaybe<GqlPoolFilter>;
}

export interface QueryPoolGetPoolsCountArgs {
    first?: InputMaybe<Scalars['Int']>;
    orderBy?: InputMaybe<GqlPoolOrderBy>;
    orderDirection?: InputMaybe<GqlPoolOrderDirection>;
    skip?: InputMaybe<Scalars['Int']>;
    textSearch?: InputMaybe<Scalars['String']>;
    where?: InputMaybe<GqlPoolFilter>;
}

export interface QueryPoolGetSnapshotsArgs {
    chain?: InputMaybe<GqlChain>;
    id: Scalars['String'];
    range: GqlPoolSnapshotDataRange;
}

export interface QueryPoolGetSwapsArgs {
    first?: InputMaybe<Scalars['Int']>;
    skip?: InputMaybe<Scalars['Int']>;
    where?: InputMaybe<GqlPoolSwapFilter>;
}

export interface QueryProtocolMetricsAggregatedArgs {
    chains?: InputMaybe<Array<GqlChain>>;
}

export interface QueryProtocolMetricsChainArgs {
    chain?: InputMaybe<GqlChain>;
}

export interface QuerySftmxGetStakingSnapshotsArgs {
    range: GqlSftmxStakingSnapshotDataRange;
}

export interface QuerySftmxGetWithdrawalRequestsArgs {
    user: Scalars['String'];
}

export interface QuerySorGetSwapPathsArgs {
    callDataInput?: InputMaybe<GqlSwapCallDataInput>;
    chain: GqlChain;
    queryBatchSwap?: InputMaybe<Scalars['Boolean']>;
    swapAmount: Scalars['AmountHumanReadable'];
    swapType: GqlSorSwapType;
    tokenIn: Scalars['String'];
    tokenOut: Scalars['String'];
    useProtocolVersion?: InputMaybe<Scalars['Int']>;
}

export interface QuerySorGetSwapsArgs {
    chain?: InputMaybe<GqlChain>;
    swapAmount: Scalars['BigDecimal'];
    swapOptions: GqlSorSwapOptionsInput;
    swapType: GqlSorSwapType;
    tokenIn: Scalars['String'];
    tokenOut: Scalars['String'];
}

export interface QueryTokenGetCandlestickChartDataArgs {
    address: Scalars['String'];
    chain?: InputMaybe<GqlChain>;
    range: GqlTokenChartDataRange;
}

export interface QueryTokenGetCurrentPricesArgs {
    chains?: InputMaybe<Array<GqlChain>>;
}

export interface QueryTokenGetHistoricalPricesArgs {
    addresses: Array<Scalars['String']>;
    chain: GqlChain;
    range: GqlTokenChartDataRange;
}

export interface QueryTokenGetPriceChartDataArgs {
    address: Scalars['String'];
    chain?: InputMaybe<GqlChain>;
    range: GqlTokenChartDataRange;
}

export interface QueryTokenGetProtocolTokenPriceArgs {
    chain?: InputMaybe<GqlChain>;
}

export interface QueryTokenGetRelativePriceChartDataArgs {
    chain?: InputMaybe<GqlChain>;
    range: GqlTokenChartDataRange;
    tokenIn: Scalars['String'];
    tokenOut: Scalars['String'];
}

export interface QueryTokenGetTokenDataArgs {
    address: Scalars['String'];
    chain?: InputMaybe<GqlChain>;
}

export interface QueryTokenGetTokenDynamicDataArgs {
    address: Scalars['String'];
    chain?: InputMaybe<GqlChain>;
}

export interface QueryTokenGetTokensArgs {
    chains?: InputMaybe<Array<GqlChain>>;
}

export interface QueryTokenGetTokensDataArgs {
    addresses: Array<Scalars['String']>;
}

export interface QueryTokenGetTokensDynamicDataArgs {
    addresses: Array<Scalars['String']>;
    chain?: InputMaybe<GqlChain>;
}

export interface QueryUserGetPoolBalancesArgs {
    address?: InputMaybe<Scalars['String']>;
    chains?: InputMaybe<Array<GqlChain>>;
}

export interface QueryUserGetPoolJoinExitsArgs {
    address?: InputMaybe<Scalars['String']>;
    chain?: InputMaybe<GqlChain>;
    first?: InputMaybe<Scalars['Int']>;
    poolId: Scalars['String'];
    skip?: InputMaybe<Scalars['Int']>;
}

export interface QueryUserGetStakingArgs {
    address?: InputMaybe<Scalars['String']>;
    chains?: InputMaybe<Array<GqlChain>>;
}

export interface QueryUserGetSwapsArgs {
    address?: InputMaybe<Scalars['String']>;
    chain?: InputMaybe<GqlChain>;
    first?: InputMaybe<Scalars['Int']>;
    poolId: Scalars['String'];
    skip?: InputMaybe<Scalars['Int']>;
}

export interface QueryVeBalGetTotalSupplyArgs {
    chain?: InputMaybe<GqlChain>;
}

export interface QueryVeBalGetUserArgs {
    address: Scalars['String'];
    chain?: InputMaybe<GqlChain>;
}

export interface QueryVeBalGetUserBalanceArgs {
    address?: InputMaybe<Scalars['String']>;
    chain?: InputMaybe<GqlChain>;
}

export interface QueryVeBalGetUserBalancesArgs {
    address: Scalars['String'];
    chains?: InputMaybe<Array<GqlChain>>;
}

export interface Token {
    __typename?: 'Token';
    address: Scalars['String'];
    decimals: Scalars['Int'];
}

export type WithIndex<TObject> = TObject & Record<string, any>;
export type ResolversObject<TObject> = WithIndex<TObject>;

export type ResolverTypeWrapper<T> = Promise<T> | T;

export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
    resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
    | ResolverFn<TResult, TParent, TContext, TArgs>
    | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
    subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
    resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
    subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
    resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
    | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
    | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
    | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
    | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
    parent: TParent,
    context: TContext,
    info: GraphQLResolveInfo,
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (
    obj: T,
    context: TContext,
    info: GraphQLResolveInfo,
) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
    next: NextResolverFn<TResult>,
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = ResolversObject<{
    AmountHumanReadable: ResolverTypeWrapper<Scalars['AmountHumanReadable']>;
    BigDecimal: ResolverTypeWrapper<Scalars['BigDecimal']>;
    BigInt: ResolverTypeWrapper<Scalars['BigInt']>;
    Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
    Bytes: ResolverTypeWrapper<Scalars['Bytes']>;
    Date: ResolverTypeWrapper<Scalars['Date']>;
    Float: ResolverTypeWrapper<Scalars['Float']>;
    GqlBalancePoolAprItem: ResolverTypeWrapper<
        Omit<GqlBalancePoolAprItem, 'apr'> & { apr: ResolversTypes['GqlPoolAprValue'] }
    >;
    GqlBalancePoolAprSubItem: ResolverTypeWrapper<
        Omit<GqlBalancePoolAprSubItem, 'apr'> & { apr: ResolversTypes['GqlPoolAprValue'] }
    >;
    GqlBigNumber: ResolverTypeWrapper<Scalars['GqlBigNumber']>;
    GqlChain: GqlChain;
    GqlContentNewsItem: ResolverTypeWrapper<GqlContentNewsItem>;
    GqlContentNewsItemSource: GqlContentNewsItemSource;
    GqlFeaturePoolGroupItemExternalLink: ResolverTypeWrapper<GqlFeaturePoolGroupItemExternalLink>;
    GqlGraphTraversalConfigInput: GqlGraphTraversalConfigInput;
    GqlHistoricalTokenPrice: ResolverTypeWrapper<GqlHistoricalTokenPrice>;
    GqlHistoricalTokenPriceEntry: ResolverTypeWrapper<GqlHistoricalTokenPriceEntry>;
    GqlLatestSyncedBlocks: ResolverTypeWrapper<GqlLatestSyncedBlocks>;
    GqlNestedPool: ResolverTypeWrapper<GqlNestedPool>;
    GqlPoolAddRemoveEventV3: ResolverTypeWrapper<GqlPoolAddRemoveEventV3>;
    GqlPoolAggregator: ResolverTypeWrapper<GqlPoolAggregator>;
    GqlPoolApr: ResolverTypeWrapper<
        Omit<GqlPoolApr, 'apr' | 'nativeRewardApr' | 'thirdPartyApr'> & {
            apr: ResolversTypes['GqlPoolAprValue'];
            nativeRewardApr: ResolversTypes['GqlPoolAprValue'];
            thirdPartyApr: ResolversTypes['GqlPoolAprValue'];
        }
    >;
    GqlPoolAprItem: ResolverTypeWrapper<GqlPoolAprItem>;
    GqlPoolAprItemType: GqlPoolAprItemType;
    GqlPoolAprRange: ResolverTypeWrapper<GqlPoolAprRange>;
    GqlPoolAprTotal: ResolverTypeWrapper<GqlPoolAprTotal>;
    GqlPoolAprValue: ResolversTypes['GqlPoolAprRange'] | ResolversTypes['GqlPoolAprTotal'];
    GqlPoolBase:
        | ResolversTypes['GqlPoolComposableStable']
        | ResolversTypes['GqlPoolElement']
        | ResolversTypes['GqlPoolFx']
        | ResolversTypes['GqlPoolGyro']
        | ResolversTypes['GqlPoolLiquidityBootstrapping']
        | ResolversTypes['GqlPoolMetaStable']
        | ResolversTypes['GqlPoolStable']
        | ResolversTypes['GqlPoolWeighted'];
    GqlPoolBatchSwap: ResolverTypeWrapper<GqlPoolBatchSwap>;
    GqlPoolBatchSwapPool: ResolverTypeWrapper<GqlPoolBatchSwapPool>;
    GqlPoolBatchSwapSwap: ResolverTypeWrapper<GqlPoolBatchSwapSwap>;
    GqlPoolComposableStable: ResolverTypeWrapper<
        Omit<GqlPoolComposableStable, 'tokens'> & { tokens: Array<ResolversTypes['GqlPoolTokenUnion']> }
    >;
    GqlPoolComposableStableNested: ResolverTypeWrapper<
        Omit<GqlPoolComposableStableNested, 'tokens'> & {
            tokens: Array<ResolversTypes['GqlPoolTokenComposableStableNestedUnion']>;
        }
    >;
    GqlPoolDynamicData: ResolverTypeWrapper<GqlPoolDynamicData>;
    GqlPoolElement: ResolverTypeWrapper<GqlPoolElement>;
    GqlPoolEvent:
        | ResolversTypes['GqlPoolAddRemoveEventV3']
        | ResolversTypes['GqlPoolSwapEventCowAmm']
        | ResolversTypes['GqlPoolSwapEventV3'];
    GqlPoolEventAmount: ResolverTypeWrapper<GqlPoolEventAmount>;
    GqlPoolEventType: GqlPoolEventType;
    GqlPoolEventsDataRange: GqlPoolEventsDataRange;
    GqlPoolEventsFilter: GqlPoolEventsFilter;
    GqlPoolFeaturedPool: ResolverTypeWrapper<GqlPoolFeaturedPool>;
    GqlPoolFeaturedPoolGroup: ResolverTypeWrapper<
        Omit<GqlPoolFeaturedPoolGroup, 'items'> & { items: Array<ResolversTypes['GqlPoolFeaturedPoolGroupItem']> }
    >;
    GqlPoolFeaturedPoolGroupItem:
        | ResolversTypes['GqlFeaturePoolGroupItemExternalLink']
        | ResolversTypes['GqlPoolMinimal'];
    GqlPoolFilter: GqlPoolFilter;
    GqlPoolFilterCategory: GqlPoolFilterCategory;
    GqlPoolFx: ResolverTypeWrapper<Omit<GqlPoolFx, 'tokens'> & { tokens: Array<ResolversTypes['GqlPoolTokenUnion']> }>;
    GqlPoolGyro: ResolverTypeWrapper<
        Omit<GqlPoolGyro, 'tokens'> & { tokens: Array<ResolversTypes['GqlPoolTokenUnion']> }
    >;
    GqlPoolInvestConfig: ResolverTypeWrapper<GqlPoolInvestConfig>;
    GqlPoolInvestOption: ResolverTypeWrapper<GqlPoolInvestOption>;
    GqlPoolJoinExit: ResolverTypeWrapper<GqlPoolJoinExit>;
    GqlPoolJoinExitAmount: ResolverTypeWrapper<GqlPoolJoinExitAmount>;
    GqlPoolJoinExitFilter: GqlPoolJoinExitFilter;
    GqlPoolJoinExitType: GqlPoolJoinExitType;
    GqlPoolLiquidityBootstrapping: ResolverTypeWrapper<
        Omit<GqlPoolLiquidityBootstrapping, 'tokens'> & { tokens: Array<ResolversTypes['GqlPoolTokenUnion']> }
    >;
    GqlPoolMetaStable: ResolverTypeWrapper<GqlPoolMetaStable>;
    GqlPoolMinimal: ResolverTypeWrapper<GqlPoolMinimal>;
    GqlPoolMutationResult: ResolverTypeWrapper<GqlPoolMutationResult>;
    GqlPoolNestedUnion: ResolversTypes['GqlPoolComposableStableNested'];
    GqlPoolNestingType: GqlPoolNestingType;
    GqlPoolOrderBy: GqlPoolOrderBy;
    GqlPoolOrderDirection: GqlPoolOrderDirection;
    GqlPoolSnapshot: ResolverTypeWrapper<GqlPoolSnapshot>;
    GqlPoolSnapshotDataRange: GqlPoolSnapshotDataRange;
    GqlPoolStable: ResolverTypeWrapper<GqlPoolStable>;
    GqlPoolStableComposablePoolData: ResolverTypeWrapper<GqlPoolStableComposablePoolData>;
    GqlPoolStaking: ResolverTypeWrapper<GqlPoolStaking>;
    GqlPoolStakingAura: ResolverTypeWrapper<GqlPoolStakingAura>;
    GqlPoolStakingFarmRewarder: ResolverTypeWrapper<GqlPoolStakingFarmRewarder>;
    GqlPoolStakingGauge: ResolverTypeWrapper<GqlPoolStakingGauge>;
    GqlPoolStakingGaugeReward: ResolverTypeWrapper<GqlPoolStakingGaugeReward>;
    GqlPoolStakingGaugeStatus: GqlPoolStakingGaugeStatus;
    GqlPoolStakingMasterChefFarm: ResolverTypeWrapper<GqlPoolStakingMasterChefFarm>;
    GqlPoolStakingOtherGauge: ResolverTypeWrapper<GqlPoolStakingOtherGauge>;
    GqlPoolStakingReliquaryFarm: ResolverTypeWrapper<GqlPoolStakingReliquaryFarm>;
    GqlPoolStakingReliquaryFarmLevel: ResolverTypeWrapper<GqlPoolStakingReliquaryFarmLevel>;
    GqlPoolStakingType: GqlPoolStakingType;
    GqlPoolStakingVebal: ResolverTypeWrapper<GqlPoolStakingVebal>;
    GqlPoolSwap: ResolverTypeWrapper<GqlPoolSwap>;
    GqlPoolSwapEventCowAmm: ResolverTypeWrapper<GqlPoolSwapEventCowAmm>;
    GqlPoolSwapEventV3: ResolverTypeWrapper<GqlPoolSwapEventV3>;
    GqlPoolSwapFilter: GqlPoolSwapFilter;
    GqlPoolTimePeriod: GqlPoolTimePeriod;
    GqlPoolToken: ResolverTypeWrapper<GqlPoolToken>;
    GqlPoolTokenBase: ResolversTypes['GqlPoolToken'] | ResolversTypes['GqlPoolTokenComposableStable'];
    GqlPoolTokenComposableStable: ResolverTypeWrapper<GqlPoolTokenComposableStable>;
    GqlPoolTokenComposableStableNestedUnion: ResolversTypes['GqlPoolToken'];
    GqlPoolTokenDetail: ResolverTypeWrapper<GqlPoolTokenDetail>;
    GqlPoolTokenDisplay: ResolverTypeWrapper<GqlPoolTokenDisplay>;
    GqlPoolTokenExpanded: ResolverTypeWrapper<GqlPoolTokenExpanded>;
    GqlPoolTokenUnion: ResolversTypes['GqlPoolToken'] | ResolversTypes['GqlPoolTokenComposableStable'];
    GqlPoolType: GqlPoolType;
    GqlPoolUnion:
        | ResolversTypes['GqlPoolComposableStable']
        | ResolversTypes['GqlPoolElement']
        | ResolversTypes['GqlPoolFx']
        | ResolversTypes['GqlPoolGyro']
        | ResolversTypes['GqlPoolLiquidityBootstrapping']
        | ResolversTypes['GqlPoolMetaStable']
        | ResolversTypes['GqlPoolStable']
        | ResolversTypes['GqlPoolWeighted'];
    GqlPoolUserBalance: ResolverTypeWrapper<GqlPoolUserBalance>;
    GqlPoolUserSwapVolume: ResolverTypeWrapper<GqlPoolUserSwapVolume>;
    GqlPoolWeighted: ResolverTypeWrapper<
        Omit<GqlPoolWeighted, 'tokens'> & { tokens: Array<ResolversTypes['GqlPoolTokenUnion']> }
    >;
    GqlPoolWithdrawConfig: ResolverTypeWrapper<GqlPoolWithdrawConfig>;
    GqlPoolWithdrawOption: ResolverTypeWrapper<GqlPoolWithdrawOption>;
    GqlPriceImpact: ResolverTypeWrapper<GqlPriceImpact>;
    GqlPriceRateProviderData: ResolverTypeWrapper<GqlPriceRateProviderData>;
    GqlPriceRateProviderUpgradeableComponent: ResolverTypeWrapper<GqlPriceRateProviderUpgradeableComponent>;
    GqlProtocolMetricsAggregated: ResolverTypeWrapper<GqlProtocolMetricsAggregated>;
    GqlProtocolMetricsChain: ResolverTypeWrapper<GqlProtocolMetricsChain>;
    GqlRelicSnapshot: ResolverTypeWrapper<GqlRelicSnapshot>;
    GqlReliquaryFarmLevelSnapshot: ResolverTypeWrapper<GqlReliquaryFarmLevelSnapshot>;
    GqlReliquaryFarmSnapshot: ResolverTypeWrapper<GqlReliquaryFarmSnapshot>;
    GqlReliquaryTokenBalanceSnapshot: ResolverTypeWrapper<GqlReliquaryTokenBalanceSnapshot>;
    GqlSftmxStakingData: ResolverTypeWrapper<GqlSftmxStakingData>;
    GqlSftmxStakingSnapshot: ResolverTypeWrapper<GqlSftmxStakingSnapshot>;
    GqlSftmxStakingSnapshotDataRange: GqlSftmxStakingSnapshotDataRange;
    GqlSftmxStakingVault: ResolverTypeWrapper<GqlSftmxStakingVault>;
    GqlSftmxWithdrawalRequests: ResolverTypeWrapper<GqlSftmxWithdrawalRequests>;
    GqlSorCallData: ResolverTypeWrapper<GqlSorCallData>;
    GqlSorGetSwapPaths: ResolverTypeWrapper<GqlSorGetSwapPaths>;
    GqlSorGetSwapsResponse: ResolverTypeWrapper<GqlSorGetSwapsResponse>;
    GqlSorPath: ResolverTypeWrapper<GqlSorPath>;
    GqlSorSwap: ResolverTypeWrapper<GqlSorSwap>;
    GqlSorSwapOptionsInput: GqlSorSwapOptionsInput;
    GqlSorSwapRoute: ResolverTypeWrapper<GqlSorSwapRoute>;
    GqlSorSwapRouteHop: ResolverTypeWrapper<GqlSorSwapRouteHop>;
    GqlSorSwapType: GqlSorSwapType;
    GqlSwapCallDataInput: GqlSwapCallDataInput;
    GqlToken: ResolverTypeWrapper<GqlToken>;
    GqlTokenAmountHumanReadable: GqlTokenAmountHumanReadable;
    GqlTokenCandlestickChartDataItem: ResolverTypeWrapper<GqlTokenCandlestickChartDataItem>;
    GqlTokenChartDataRange: GqlTokenChartDataRange;
    GqlTokenData: ResolverTypeWrapper<GqlTokenData>;
    GqlTokenDynamicData: ResolverTypeWrapper<GqlTokenDynamicData>;
    GqlTokenMutationResult: ResolverTypeWrapper<GqlTokenMutationResult>;
    GqlTokenPrice: ResolverTypeWrapper<GqlTokenPrice>;
    GqlTokenPriceChartDataItem: ResolverTypeWrapper<GqlTokenPriceChartDataItem>;
    GqlTokenType: GqlTokenType;
    GqlUserFbeetsBalance: ResolverTypeWrapper<GqlUserFbeetsBalance>;
    GqlUserPoolBalance: ResolverTypeWrapper<GqlUserPoolBalance>;
    GqlUserStakedBalance: ResolverTypeWrapper<GqlUserStakedBalance>;
    GqlUserSwapVolumeFilter: GqlUserSwapVolumeFilter;
    GqlVeBalBalance: ResolverTypeWrapper<GqlVeBalBalance>;
    GqlVeBalUserData: ResolverTypeWrapper<GqlVeBalUserData>;
    GqlVotingGauge: ResolverTypeWrapper<GqlVotingGauge>;
    GqlVotingGaugeToken: ResolverTypeWrapper<GqlVotingGaugeToken>;
    GqlVotingPool: ResolverTypeWrapper<GqlVotingPool>;
    Hook: ResolverTypeWrapper<Hook>;
    HookData: ResolverTypeWrapper<HookData>;
    ID: ResolverTypeWrapper<Scalars['ID']>;
    Int: ResolverTypeWrapper<Scalars['Int']>;
    JSON: ResolverTypeWrapper<Scalars['JSON']>;
    Mutation: ResolverTypeWrapper<{}>;
    Query: ResolverTypeWrapper<{}>;
    String: ResolverTypeWrapper<Scalars['String']>;
    Token: ResolverTypeWrapper<Token>;
}>;

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = ResolversObject<{
    AmountHumanReadable: Scalars['AmountHumanReadable'];
    BigDecimal: Scalars['BigDecimal'];
    BigInt: Scalars['BigInt'];
    Boolean: Scalars['Boolean'];
    Bytes: Scalars['Bytes'];
    Date: Scalars['Date'];
    Float: Scalars['Float'];
    GqlBalancePoolAprItem: Omit<GqlBalancePoolAprItem, 'apr'> & { apr: ResolversParentTypes['GqlPoolAprValue'] };
    GqlBalancePoolAprSubItem: Omit<GqlBalancePoolAprSubItem, 'apr'> & { apr: ResolversParentTypes['GqlPoolAprValue'] };
    GqlBigNumber: Scalars['GqlBigNumber'];
    GqlContentNewsItem: GqlContentNewsItem;
    GqlFeaturePoolGroupItemExternalLink: GqlFeaturePoolGroupItemExternalLink;
    GqlGraphTraversalConfigInput: GqlGraphTraversalConfigInput;
    GqlHistoricalTokenPrice: GqlHistoricalTokenPrice;
    GqlHistoricalTokenPriceEntry: GqlHistoricalTokenPriceEntry;
    GqlLatestSyncedBlocks: GqlLatestSyncedBlocks;
    GqlNestedPool: GqlNestedPool;
    GqlPoolAddRemoveEventV3: GqlPoolAddRemoveEventV3;
    GqlPoolAggregator: GqlPoolAggregator;
    GqlPoolApr: Omit<GqlPoolApr, 'apr' | 'nativeRewardApr' | 'thirdPartyApr'> & {
        apr: ResolversParentTypes['GqlPoolAprValue'];
        nativeRewardApr: ResolversParentTypes['GqlPoolAprValue'];
        thirdPartyApr: ResolversParentTypes['GqlPoolAprValue'];
    };
    GqlPoolAprItem: GqlPoolAprItem;
    GqlPoolAprRange: GqlPoolAprRange;
    GqlPoolAprTotal: GqlPoolAprTotal;
    GqlPoolAprValue: ResolversParentTypes['GqlPoolAprRange'] | ResolversParentTypes['GqlPoolAprTotal'];
    GqlPoolBase:
        | ResolversParentTypes['GqlPoolComposableStable']
        | ResolversParentTypes['GqlPoolElement']
        | ResolversParentTypes['GqlPoolFx']
        | ResolversParentTypes['GqlPoolGyro']
        | ResolversParentTypes['GqlPoolLiquidityBootstrapping']
        | ResolversParentTypes['GqlPoolMetaStable']
        | ResolversParentTypes['GqlPoolStable']
        | ResolversParentTypes['GqlPoolWeighted'];
    GqlPoolBatchSwap: GqlPoolBatchSwap;
    GqlPoolBatchSwapPool: GqlPoolBatchSwapPool;
    GqlPoolBatchSwapSwap: GqlPoolBatchSwapSwap;
    GqlPoolComposableStable: Omit<GqlPoolComposableStable, 'tokens'> & {
        tokens: Array<ResolversParentTypes['GqlPoolTokenUnion']>;
    };
    GqlPoolComposableStableNested: Omit<GqlPoolComposableStableNested, 'tokens'> & {
        tokens: Array<ResolversParentTypes['GqlPoolTokenComposableStableNestedUnion']>;
    };
    GqlPoolDynamicData: GqlPoolDynamicData;
    GqlPoolElement: GqlPoolElement;
    GqlPoolEvent:
        | ResolversParentTypes['GqlPoolAddRemoveEventV3']
        | ResolversParentTypes['GqlPoolSwapEventCowAmm']
        | ResolversParentTypes['GqlPoolSwapEventV3'];
    GqlPoolEventAmount: GqlPoolEventAmount;
    GqlPoolEventsFilter: GqlPoolEventsFilter;
    GqlPoolFeaturedPool: GqlPoolFeaturedPool;
    GqlPoolFeaturedPoolGroup: Omit<GqlPoolFeaturedPoolGroup, 'items'> & {
        items: Array<ResolversParentTypes['GqlPoolFeaturedPoolGroupItem']>;
    };
    GqlPoolFeaturedPoolGroupItem:
        | ResolversParentTypes['GqlFeaturePoolGroupItemExternalLink']
        | ResolversParentTypes['GqlPoolMinimal'];
    GqlPoolFilter: GqlPoolFilter;
    GqlPoolFx: Omit<GqlPoolFx, 'tokens'> & { tokens: Array<ResolversParentTypes['GqlPoolTokenUnion']> };
    GqlPoolGyro: Omit<GqlPoolGyro, 'tokens'> & { tokens: Array<ResolversParentTypes['GqlPoolTokenUnion']> };
    GqlPoolInvestConfig: GqlPoolInvestConfig;
    GqlPoolInvestOption: GqlPoolInvestOption;
    GqlPoolJoinExit: GqlPoolJoinExit;
    GqlPoolJoinExitAmount: GqlPoolJoinExitAmount;
    GqlPoolJoinExitFilter: GqlPoolJoinExitFilter;
    GqlPoolLiquidityBootstrapping: Omit<GqlPoolLiquidityBootstrapping, 'tokens'> & {
        tokens: Array<ResolversParentTypes['GqlPoolTokenUnion']>;
    };
    GqlPoolMetaStable: GqlPoolMetaStable;
    GqlPoolMinimal: GqlPoolMinimal;
    GqlPoolMutationResult: GqlPoolMutationResult;
    GqlPoolNestedUnion: ResolversParentTypes['GqlPoolComposableStableNested'];
    GqlPoolSnapshot: GqlPoolSnapshot;
    GqlPoolStable: GqlPoolStable;
    GqlPoolStableComposablePoolData: GqlPoolStableComposablePoolData;
    GqlPoolStaking: GqlPoolStaking;
    GqlPoolStakingAura: GqlPoolStakingAura;
    GqlPoolStakingFarmRewarder: GqlPoolStakingFarmRewarder;
    GqlPoolStakingGauge: GqlPoolStakingGauge;
    GqlPoolStakingGaugeReward: GqlPoolStakingGaugeReward;
    GqlPoolStakingMasterChefFarm: GqlPoolStakingMasterChefFarm;
    GqlPoolStakingOtherGauge: GqlPoolStakingOtherGauge;
    GqlPoolStakingReliquaryFarm: GqlPoolStakingReliquaryFarm;
    GqlPoolStakingReliquaryFarmLevel: GqlPoolStakingReliquaryFarmLevel;
    GqlPoolStakingVebal: GqlPoolStakingVebal;
    GqlPoolSwap: GqlPoolSwap;
    GqlPoolSwapEventCowAmm: GqlPoolSwapEventCowAmm;
    GqlPoolSwapEventV3: GqlPoolSwapEventV3;
    GqlPoolSwapFilter: GqlPoolSwapFilter;
    GqlPoolTimePeriod: GqlPoolTimePeriod;
    GqlPoolToken: GqlPoolToken;
    GqlPoolTokenBase: ResolversParentTypes['GqlPoolToken'] | ResolversParentTypes['GqlPoolTokenComposableStable'];
    GqlPoolTokenComposableStable: GqlPoolTokenComposableStable;
    GqlPoolTokenComposableStableNestedUnion: ResolversParentTypes['GqlPoolToken'];
    GqlPoolTokenDetail: GqlPoolTokenDetail;
    GqlPoolTokenDisplay: GqlPoolTokenDisplay;
    GqlPoolTokenExpanded: GqlPoolTokenExpanded;
    GqlPoolTokenUnion: ResolversParentTypes['GqlPoolToken'] | ResolversParentTypes['GqlPoolTokenComposableStable'];
    GqlPoolUnion:
        | ResolversParentTypes['GqlPoolComposableStable']
        | ResolversParentTypes['GqlPoolElement']
        | ResolversParentTypes['GqlPoolFx']
        | ResolversParentTypes['GqlPoolGyro']
        | ResolversParentTypes['GqlPoolLiquidityBootstrapping']
        | ResolversParentTypes['GqlPoolMetaStable']
        | ResolversParentTypes['GqlPoolStable']
        | ResolversParentTypes['GqlPoolWeighted'];
    GqlPoolUserBalance: GqlPoolUserBalance;
    GqlPoolUserSwapVolume: GqlPoolUserSwapVolume;
    GqlPoolWeighted: Omit<GqlPoolWeighted, 'tokens'> & { tokens: Array<ResolversParentTypes['GqlPoolTokenUnion']> };
    GqlPoolWithdrawConfig: GqlPoolWithdrawConfig;
    GqlPoolWithdrawOption: GqlPoolWithdrawOption;
    GqlPriceImpact: GqlPriceImpact;
    GqlPriceRateProviderData: GqlPriceRateProviderData;
    GqlPriceRateProviderUpgradeableComponent: GqlPriceRateProviderUpgradeableComponent;
    GqlProtocolMetricsAggregated: GqlProtocolMetricsAggregated;
    GqlProtocolMetricsChain: GqlProtocolMetricsChain;
    GqlRelicSnapshot: GqlRelicSnapshot;
    GqlReliquaryFarmLevelSnapshot: GqlReliquaryFarmLevelSnapshot;
    GqlReliquaryFarmSnapshot: GqlReliquaryFarmSnapshot;
    GqlReliquaryTokenBalanceSnapshot: GqlReliquaryTokenBalanceSnapshot;
    GqlSftmxStakingData: GqlSftmxStakingData;
    GqlSftmxStakingSnapshot: GqlSftmxStakingSnapshot;
    GqlSftmxStakingVault: GqlSftmxStakingVault;
    GqlSftmxWithdrawalRequests: GqlSftmxWithdrawalRequests;
    GqlSorCallData: GqlSorCallData;
    GqlSorGetSwapPaths: GqlSorGetSwapPaths;
    GqlSorGetSwapsResponse: GqlSorGetSwapsResponse;
    GqlSorPath: GqlSorPath;
    GqlSorSwap: GqlSorSwap;
    GqlSorSwapOptionsInput: GqlSorSwapOptionsInput;
    GqlSorSwapRoute: GqlSorSwapRoute;
    GqlSorSwapRouteHop: GqlSorSwapRouteHop;
    GqlSwapCallDataInput: GqlSwapCallDataInput;
    GqlToken: GqlToken;
    GqlTokenAmountHumanReadable: GqlTokenAmountHumanReadable;
    GqlTokenCandlestickChartDataItem: GqlTokenCandlestickChartDataItem;
    GqlTokenData: GqlTokenData;
    GqlTokenDynamicData: GqlTokenDynamicData;
    GqlTokenMutationResult: GqlTokenMutationResult;
    GqlTokenPrice: GqlTokenPrice;
    GqlTokenPriceChartDataItem: GqlTokenPriceChartDataItem;
    GqlUserFbeetsBalance: GqlUserFbeetsBalance;
    GqlUserPoolBalance: GqlUserPoolBalance;
    GqlUserStakedBalance: GqlUserStakedBalance;
    GqlUserSwapVolumeFilter: GqlUserSwapVolumeFilter;
    GqlVeBalBalance: GqlVeBalBalance;
    GqlVeBalUserData: GqlVeBalUserData;
    GqlVotingGauge: GqlVotingGauge;
    GqlVotingGaugeToken: GqlVotingGaugeToken;
    GqlVotingPool: GqlVotingPool;
    Hook: Hook;
    HookData: HookData;
    ID: Scalars['ID'];
    Int: Scalars['Int'];
    JSON: Scalars['JSON'];
    Mutation: {};
    Query: {};
    String: Scalars['String'];
    Token: Token;
}>;

export interface AmountHumanReadableScalarConfig
    extends GraphQLScalarTypeConfig<ResolversTypes['AmountHumanReadable'], any> {
    name: 'AmountHumanReadable';
}

export interface BigDecimalScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['BigDecimal'], any> {
    name: 'BigDecimal';
}

export interface BigIntScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['BigInt'], any> {
    name: 'BigInt';
}

export interface BytesScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Bytes'], any> {
    name: 'Bytes';
}

export interface DateScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Date'], any> {
    name: 'Date';
}

export type GqlBalancePoolAprItemResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlBalancePoolAprItem'] = ResolversParentTypes['GqlBalancePoolAprItem'],
> = ResolversObject<{
    apr?: Resolver<ResolversTypes['GqlPoolAprValue'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    subItems?: Resolver<Maybe<Array<ResolversTypes['GqlBalancePoolAprSubItem']>>, ParentType, ContextType>;
    title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlBalancePoolAprSubItemResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlBalancePoolAprSubItem'] = ResolversParentTypes['GqlBalancePoolAprSubItem'],
> = ResolversObject<{
    apr?: Resolver<ResolversTypes['GqlPoolAprValue'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface GqlBigNumberScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['GqlBigNumber'], any> {
    name: 'GqlBigNumber';
}

export type GqlContentNewsItemResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlContentNewsItem'] = ResolversParentTypes['GqlContentNewsItem'],
> = ResolversObject<{
    discussionUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    image?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    source?: Resolver<ResolversTypes['GqlContentNewsItemSource'], ParentType, ContextType>;
    text?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    timestamp?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlFeaturePoolGroupItemExternalLinkResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlFeaturePoolGroupItemExternalLink'] = ResolversParentTypes['GqlFeaturePoolGroupItemExternalLink'],
> = ResolversObject<{
    buttonText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    buttonUrl?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    image?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlHistoricalTokenPriceResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlHistoricalTokenPrice'] = ResolversParentTypes['GqlHistoricalTokenPrice'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    prices?: Resolver<Array<ResolversTypes['GqlHistoricalTokenPriceEntry']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlHistoricalTokenPriceEntryResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlHistoricalTokenPriceEntry'] = ResolversParentTypes['GqlHistoricalTokenPriceEntry'],
> = ResolversObject<{
    price?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    timestamp?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    updatedAt?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    updatedBy?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlLatestSyncedBlocksResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlLatestSyncedBlocks'] = ResolversParentTypes['GqlLatestSyncedBlocks'],
> = ResolversObject<{
    poolSyncBlock?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    userStakeSyncBlock?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    userWalletSyncBlock?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlNestedPoolResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlNestedPool'] = ResolversParentTypes['GqlNestedPool'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    bptPriceRate?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    createTime?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    factory?: Resolver<Maybe<ResolversTypes['Bytes']>, ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    nestedLiquidity?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    nestedPercentage?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    nestedShares?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    owner?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    swapFee?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokens?: Resolver<Array<ResolversTypes['GqlPoolTokenDetail']>, ParentType, ContextType>;
    totalLiquidity?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    totalShares?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    type?: Resolver<ResolversTypes['GqlPoolType'], ParentType, ContextType>;
    version?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolAddRemoveEventV3Resolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolAddRemoveEventV3'] = ResolversParentTypes['GqlPoolAddRemoveEventV3'],
> = ResolversObject<{
    blockNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    blockTimestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    logIndex?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    poolId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    sender?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    timestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    tokens?: Resolver<Array<ResolversTypes['GqlPoolEventAmount']>, ParentType, ContextType>;
    tx?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    type?: Resolver<ResolversTypes['GqlPoolEventType'], ParentType, ContextType>;
    userAddress?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    valueUSD?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolAggregatorResolvers<
    ContextType = Context,
    ParentType extends ResolversParentTypes['GqlPoolAggregator'] = ResolversParentTypes['GqlPoolAggregator'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    alpha?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    amp?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
    beta?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    c?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    createTime?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    dSq?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    decimals?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    delta?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    dynamicData?: Resolver<ResolversTypes['GqlPoolDynamicData'], ParentType, ContextType>;
    epsilon?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    factory?: Resolver<Maybe<ResolversTypes['Bytes']>, ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    lambda?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    owner?: Resolver<Maybe<ResolversTypes['Bytes']>, ParentType, ContextType>;
    poolTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenDetail']>, ParentType, ContextType>;
    protocolVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    root3Alpha?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    s?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    sqrtAlpha?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    sqrtBeta?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tauAlphaX?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    tauAlphaY?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    tauBetaX?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    tauBetaY?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    type?: Resolver<ResolversTypes['GqlPoolType'], ParentType, ContextType>;
    u?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    v?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    version?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    w?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    z?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolAprResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolApr'] = ResolversParentTypes['GqlPoolApr'],
> = ResolversObject<{
    apr?: Resolver<ResolversTypes['GqlPoolAprValue'], ParentType, ContextType>;
    hasRewardApr?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    items?: Resolver<Array<ResolversTypes['GqlBalancePoolAprItem']>, ParentType, ContextType>;
    nativeRewardApr?: Resolver<ResolversTypes['GqlPoolAprValue'], ParentType, ContextType>;
    swapApr?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    thirdPartyApr?: Resolver<ResolversTypes['GqlPoolAprValue'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolAprItemResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolAprItem'] = ResolversParentTypes['GqlPoolAprItem'],
> = ResolversObject<{
    apr?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    rewardTokenAddress?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    rewardTokenSymbol?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    type?: Resolver<ResolversTypes['GqlPoolAprItemType'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolAprRangeResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolAprRange'] = ResolversParentTypes['GqlPoolAprRange'],
> = ResolversObject<{
    max?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    min?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolAprTotalResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolAprTotal'] = ResolversParentTypes['GqlPoolAprTotal'],
> = ResolversObject<{
    total?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolAprValueResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolAprValue'] = ResolversParentTypes['GqlPoolAprValue'],
> = ResolversObject<{
    __resolveType: TypeResolveFn<'GqlPoolAprRange' | 'GqlPoolAprTotal', ParentType, ContextType>;
}>;

export type GqlPoolBaseResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolBase'] = ResolversParentTypes['GqlPoolBase'],
> = ResolversObject<{
    __resolveType: TypeResolveFn<
        | 'GqlPoolComposableStable'
        | 'GqlPoolElement'
        | 'GqlPoolFx'
        | 'GqlPoolGyro'
        | 'GqlPoolLiquidityBootstrapping'
        | 'GqlPoolMetaStable'
        | 'GqlPoolStable'
        | 'GqlPoolWeighted',
        ParentType,
        ContextType
    >;
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    allTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenExpanded']>, ParentType, ContextType>;
    categories?: Resolver<Maybe<Array<Maybe<ResolversTypes['GqlPoolFilterCategory']>>>, ParentType, ContextType>;
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    createTime?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    decimals?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    displayTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenDisplay']>, ParentType, ContextType>;
    dynamicData?: Resolver<ResolversTypes['GqlPoolDynamicData'], ParentType, ContextType>;
    factory?: Resolver<Maybe<ResolversTypes['Bytes']>, ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    investConfig?: Resolver<ResolversTypes['GqlPoolInvestConfig'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    owner?: Resolver<Maybe<ResolversTypes['Bytes']>, ParentType, ContextType>;
    poolTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenDetail']>, ParentType, ContextType>;
    protocolVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    staking?: Resolver<Maybe<ResolversTypes['GqlPoolStaking']>, ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tags?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
    type?: Resolver<ResolversTypes['GqlPoolType'], ParentType, ContextType>;
    userBalance?: Resolver<Maybe<ResolversTypes['GqlPoolUserBalance']>, ParentType, ContextType>;
    vaultVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    version?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    withdrawConfig?: Resolver<ResolversTypes['GqlPoolWithdrawConfig'], ParentType, ContextType>;
}>;

export type GqlPoolBatchSwapResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolBatchSwap'] = ResolversParentTypes['GqlPoolBatchSwap'],
> = ResolversObject<{
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    swaps?: Resolver<Array<ResolversTypes['GqlPoolBatchSwapSwap']>, ParentType, ContextType>;
    timestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    tokenAmountIn?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokenAmountOut?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokenIn?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokenInPrice?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    tokenOut?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokenOutPrice?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    tx?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    userAddress?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    valueUSD?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolBatchSwapPoolResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolBatchSwapPool'] = ResolversParentTypes['GqlPoolBatchSwapPool'],
> = ResolversObject<{
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    tokens?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolBatchSwapSwapResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolBatchSwapSwap'] = ResolversParentTypes['GqlPoolBatchSwapSwap'],
> = ResolversObject<{
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    pool?: Resolver<ResolversTypes['GqlPoolMinimal'], ParentType, ContextType>;
    timestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    tokenAmountIn?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokenAmountOut?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokenIn?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokenOut?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tx?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    userAddress?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    valueUSD?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolComposableStableResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolComposableStable'] = ResolversParentTypes['GqlPoolComposableStable'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    allTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenExpanded']>, ParentType, ContextType>;
    amp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    bptPriceRate?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    categories?: Resolver<Maybe<Array<Maybe<ResolversTypes['GqlPoolFilterCategory']>>>, ParentType, ContextType>;
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    createTime?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    decimals?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    displayTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenDisplay']>, ParentType, ContextType>;
    dynamicData?: Resolver<ResolversTypes['GqlPoolDynamicData'], ParentType, ContextType>;
    factory?: Resolver<Maybe<ResolversTypes['Bytes']>, ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    investConfig?: Resolver<ResolversTypes['GqlPoolInvestConfig'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    nestingType?: Resolver<ResolversTypes['GqlPoolNestingType'], ParentType, ContextType>;
    owner?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    poolTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenDetail']>, ParentType, ContextType>;
    protocolVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    staking?: Resolver<Maybe<ResolversTypes['GqlPoolStaking']>, ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tags?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
    tokens?: Resolver<Array<ResolversTypes['GqlPoolTokenUnion']>, ParentType, ContextType>;
    type?: Resolver<ResolversTypes['GqlPoolType'], ParentType, ContextType>;
    userBalance?: Resolver<Maybe<ResolversTypes['GqlPoolUserBalance']>, ParentType, ContextType>;
    vaultVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    version?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    withdrawConfig?: Resolver<ResolversTypes['GqlPoolWithdrawConfig'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolComposableStableNestedResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolComposableStableNested'] = ResolversParentTypes['GqlPoolComposableStableNested'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    amp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    bptPriceRate?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    categories?: Resolver<Maybe<Array<Maybe<ResolversTypes['GqlPoolFilterCategory']>>>, ParentType, ContextType>;
    createTime?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    factory?: Resolver<Maybe<ResolversTypes['Bytes']>, ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    nestingType?: Resolver<ResolversTypes['GqlPoolNestingType'], ParentType, ContextType>;
    owner?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    swapFee?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tags?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
    tokens?: Resolver<Array<ResolversTypes['GqlPoolTokenComposableStableNestedUnion']>, ParentType, ContextType>;
    totalLiquidity?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    totalShares?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    type?: Resolver<ResolversTypes['GqlPoolType'], ParentType, ContextType>;
    version?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolDynamicDataResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolDynamicData'] = ResolversParentTypes['GqlPoolDynamicData'],
> = ResolversObject<{
    aggregateSwapFee?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    aggregateYieldFee?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    apr?: Resolver<ResolversTypes['GqlPoolApr'], ParentType, ContextType>;
    aprItems?: Resolver<Array<ResolversTypes['GqlPoolAprItem']>, ParentType, ContextType>;
    fees24h?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    fees24hAth?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    fees24hAthTimestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    fees24hAtl?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    fees24hAtlTimestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    fees48h?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    holdersCount?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    isInRecoveryMode?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    isPaused?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    lifetimeSwapFees?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    lifetimeVolume?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    poolId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    sharePriceAth?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    sharePriceAthTimestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    sharePriceAtl?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    sharePriceAtlTimestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    surplus24h?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    surplus48h?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    swapEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    swapFee?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    swapsCount?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    totalLiquidity?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    totalLiquidity24hAgo?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    totalLiquidityAth?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    totalLiquidityAthTimestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    totalLiquidityAtl?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    totalLiquidityAtlTimestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    totalShares?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    totalShares24hAgo?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    volume24h?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    volume24hAth?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    volume24hAthTimestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    volume24hAtl?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    volume24hAtlTimestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    volume48h?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    yieldCapture24h?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    yieldCapture48h?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolElementResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolElement'] = ResolversParentTypes['GqlPoolElement'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    allTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenExpanded']>, ParentType, ContextType>;
    baseToken?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    categories?: Resolver<Maybe<Array<Maybe<ResolversTypes['GqlPoolFilterCategory']>>>, ParentType, ContextType>;
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    createTime?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    decimals?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    displayTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenDisplay']>, ParentType, ContextType>;
    dynamicData?: Resolver<ResolversTypes['GqlPoolDynamicData'], ParentType, ContextType>;
    factory?: Resolver<Maybe<ResolversTypes['Bytes']>, ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    investConfig?: Resolver<ResolversTypes['GqlPoolInvestConfig'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    owner?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    poolTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenDetail']>, ParentType, ContextType>;
    principalToken?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    protocolVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    staking?: Resolver<Maybe<ResolversTypes['GqlPoolStaking']>, ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tags?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
    tokens?: Resolver<Array<ResolversTypes['GqlPoolToken']>, ParentType, ContextType>;
    type?: Resolver<ResolversTypes['GqlPoolType'], ParentType, ContextType>;
    unitSeconds?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    userBalance?: Resolver<Maybe<ResolversTypes['GqlPoolUserBalance']>, ParentType, ContextType>;
    vaultVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    version?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    withdrawConfig?: Resolver<ResolversTypes['GqlPoolWithdrawConfig'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolEventResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolEvent'] = ResolversParentTypes['GqlPoolEvent'],
> = ResolversObject<{
    __resolveType: TypeResolveFn<
        'GqlPoolAddRemoveEventV3' | 'GqlPoolSwapEventCowAmm' | 'GqlPoolSwapEventV3',
        ParentType,
        ContextType
    >;
    blockNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    blockTimestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    logIndex?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    poolId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    sender?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    timestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    tx?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    type?: Resolver<ResolversTypes['GqlPoolEventType'], ParentType, ContextType>;
    userAddress?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    valueUSD?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
}>;

export type GqlPoolEventAmountResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolEventAmount'] = ResolversParentTypes['GqlPoolEventAmount'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    amount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    valueUSD?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolFeaturedPoolResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolFeaturedPool'] = ResolversParentTypes['GqlPoolFeaturedPool'],
> = ResolversObject<{
    description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    pool?: Resolver<ResolversTypes['GqlPoolBase'], ParentType, ContextType>;
    poolId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    primary?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolFeaturedPoolGroupResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolFeaturedPoolGroup'] = ResolversParentTypes['GqlPoolFeaturedPoolGroup'],
> = ResolversObject<{
    icon?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    items?: Resolver<Array<ResolversTypes['GqlPoolFeaturedPoolGroupItem']>, ParentType, ContextType>;
    title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolFeaturedPoolGroupItemResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolFeaturedPoolGroupItem'] = ResolversParentTypes['GqlPoolFeaturedPoolGroupItem'],
> = ResolversObject<{
    __resolveType: TypeResolveFn<'GqlFeaturePoolGroupItemExternalLink' | 'GqlPoolMinimal', ParentType, ContextType>;
}>;

export type GqlPoolFxResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolFx'] = ResolversParentTypes['GqlPoolFx'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    allTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenExpanded']>, ParentType, ContextType>;
    alpha?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    beta?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    categories?: Resolver<Maybe<Array<Maybe<ResolversTypes['GqlPoolFilterCategory']>>>, ParentType, ContextType>;
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    createTime?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    decimals?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    delta?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    displayTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenDisplay']>, ParentType, ContextType>;
    dynamicData?: Resolver<ResolversTypes['GqlPoolDynamicData'], ParentType, ContextType>;
    epsilon?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    factory?: Resolver<Maybe<ResolversTypes['Bytes']>, ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    investConfig?: Resolver<ResolversTypes['GqlPoolInvestConfig'], ParentType, ContextType>;
    lambda?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    owner?: Resolver<Maybe<ResolversTypes['Bytes']>, ParentType, ContextType>;
    poolTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenDetail']>, ParentType, ContextType>;
    protocolVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    staking?: Resolver<Maybe<ResolversTypes['GqlPoolStaking']>, ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tags?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
    tokens?: Resolver<Array<ResolversTypes['GqlPoolTokenUnion']>, ParentType, ContextType>;
    type?: Resolver<ResolversTypes['GqlPoolType'], ParentType, ContextType>;
    userBalance?: Resolver<Maybe<ResolversTypes['GqlPoolUserBalance']>, ParentType, ContextType>;
    vaultVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    version?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    withdrawConfig?: Resolver<ResolversTypes['GqlPoolWithdrawConfig'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolGyroResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolGyro'] = ResolversParentTypes['GqlPoolGyro'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    allTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenExpanded']>, ParentType, ContextType>;
    alpha?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    beta?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    c?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    categories?: Resolver<Maybe<Array<Maybe<ResolversTypes['GqlPoolFilterCategory']>>>, ParentType, ContextType>;
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    createTime?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    dSq?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    decimals?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    displayTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenDisplay']>, ParentType, ContextType>;
    dynamicData?: Resolver<ResolversTypes['GqlPoolDynamicData'], ParentType, ContextType>;
    factory?: Resolver<Maybe<ResolversTypes['Bytes']>, ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    investConfig?: Resolver<ResolversTypes['GqlPoolInvestConfig'], ParentType, ContextType>;
    lambda?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    nestingType?: Resolver<ResolversTypes['GqlPoolNestingType'], ParentType, ContextType>;
    owner?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    poolTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenDetail']>, ParentType, ContextType>;
    protocolVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    root3Alpha?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    s?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    sqrtAlpha?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    sqrtBeta?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    staking?: Resolver<Maybe<ResolversTypes['GqlPoolStaking']>, ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tags?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
    tauAlphaX?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tauAlphaY?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tauBetaX?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tauBetaY?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokens?: Resolver<Array<ResolversTypes['GqlPoolTokenUnion']>, ParentType, ContextType>;
    type?: Resolver<ResolversTypes['GqlPoolType'], ParentType, ContextType>;
    u?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    userBalance?: Resolver<Maybe<ResolversTypes['GqlPoolUserBalance']>, ParentType, ContextType>;
    v?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    vaultVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    version?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    w?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    withdrawConfig?: Resolver<ResolversTypes['GqlPoolWithdrawConfig'], ParentType, ContextType>;
    z?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolInvestConfigResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolInvestConfig'] = ResolversParentTypes['GqlPoolInvestConfig'],
> = ResolversObject<{
    options?: Resolver<Array<ResolversTypes['GqlPoolInvestOption']>, ParentType, ContextType>;
    proportionalEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    singleAssetEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolInvestOptionResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolInvestOption'] = ResolversParentTypes['GqlPoolInvestOption'],
> = ResolversObject<{
    poolTokenAddress?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    poolTokenIndex?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    tokenOptions?: Resolver<Array<ResolversTypes['GqlPoolToken']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolJoinExitResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolJoinExit'] = ResolversParentTypes['GqlPoolJoinExit'],
> = ResolversObject<{
    amounts?: Resolver<Array<ResolversTypes['GqlPoolJoinExitAmount']>, ParentType, ContextType>;
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    poolId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    sender?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    timestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    tx?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    type?: Resolver<ResolversTypes['GqlPoolJoinExitType'], ParentType, ContextType>;
    valueUSD?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolJoinExitAmountResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolJoinExitAmount'] = ResolversParentTypes['GqlPoolJoinExitAmount'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    amount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolLiquidityBootstrappingResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolLiquidityBootstrapping'] = ResolversParentTypes['GqlPoolLiquidityBootstrapping'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    allTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenExpanded']>, ParentType, ContextType>;
    categories?: Resolver<Maybe<Array<Maybe<ResolversTypes['GqlPoolFilterCategory']>>>, ParentType, ContextType>;
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    createTime?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    decimals?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    displayTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenDisplay']>, ParentType, ContextType>;
    dynamicData?: Resolver<ResolversTypes['GqlPoolDynamicData'], ParentType, ContextType>;
    factory?: Resolver<Maybe<ResolversTypes['Bytes']>, ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    investConfig?: Resolver<ResolversTypes['GqlPoolInvestConfig'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    nestingType?: Resolver<ResolversTypes['GqlPoolNestingType'], ParentType, ContextType>;
    owner?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    poolTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenDetail']>, ParentType, ContextType>;
    protocolVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    staking?: Resolver<Maybe<ResolversTypes['GqlPoolStaking']>, ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tags?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
    tokens?: Resolver<Array<ResolversTypes['GqlPoolTokenUnion']>, ParentType, ContextType>;
    type?: Resolver<ResolversTypes['GqlPoolType'], ParentType, ContextType>;
    userBalance?: Resolver<Maybe<ResolversTypes['GqlPoolUserBalance']>, ParentType, ContextType>;
    vaultVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    version?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    withdrawConfig?: Resolver<ResolversTypes['GqlPoolWithdrawConfig'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolMetaStableResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolMetaStable'] = ResolversParentTypes['GqlPoolMetaStable'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    allTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenExpanded']>, ParentType, ContextType>;
    amp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    categories?: Resolver<Maybe<Array<Maybe<ResolversTypes['GqlPoolFilterCategory']>>>, ParentType, ContextType>;
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    createTime?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    decimals?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    displayTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenDisplay']>, ParentType, ContextType>;
    dynamicData?: Resolver<ResolversTypes['GqlPoolDynamicData'], ParentType, ContextType>;
    factory?: Resolver<Maybe<ResolversTypes['Bytes']>, ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    investConfig?: Resolver<ResolversTypes['GqlPoolInvestConfig'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    owner?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    poolTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenDetail']>, ParentType, ContextType>;
    protocolVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    staking?: Resolver<Maybe<ResolversTypes['GqlPoolStaking']>, ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tags?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
    tokens?: Resolver<Array<ResolversTypes['GqlPoolToken']>, ParentType, ContextType>;
    type?: Resolver<ResolversTypes['GqlPoolType'], ParentType, ContextType>;
    userBalance?: Resolver<Maybe<ResolversTypes['GqlPoolUserBalance']>, ParentType, ContextType>;
    vaultVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    version?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    withdrawConfig?: Resolver<ResolversTypes['GqlPoolWithdrawConfig'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolMinimalResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolMinimal'] = ResolversParentTypes['GqlPoolMinimal'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    allTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenExpanded']>, ParentType, ContextType>;
    categories?: Resolver<Maybe<Array<Maybe<ResolversTypes['GqlPoolFilterCategory']>>>, ParentType, ContextType>;
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    createTime?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    decimals?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    displayTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenDisplay']>, ParentType, ContextType>;
    dynamicData?: Resolver<ResolversTypes['GqlPoolDynamicData'], ParentType, ContextType>;
    factory?: Resolver<Maybe<ResolversTypes['Bytes']>, ParentType, ContextType>;
    hasErc4626?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    hook?: Resolver<Maybe<ResolversTypes['Hook']>, ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    incentivized?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    owner?: Resolver<Maybe<ResolversTypes['Bytes']>, ParentType, ContextType>;
    protocolVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    staking?: Resolver<Maybe<ResolversTypes['GqlPoolStaking']>, ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tags?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
    type?: Resolver<ResolversTypes['GqlPoolType'], ParentType, ContextType>;
    userBalance?: Resolver<Maybe<ResolversTypes['GqlPoolUserBalance']>, ParentType, ContextType>;
    vaultVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    version?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolMutationResultResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolMutationResult'] = ResolversParentTypes['GqlPoolMutationResult'],
> = ResolversObject<{
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    error?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolNestedUnionResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolNestedUnion'] = ResolversParentTypes['GqlPoolNestedUnion'],
> = ResolversObject<{
    __resolveType: TypeResolveFn<'GqlPoolComposableStableNested', ParentType, ContextType>;
}>;

export type GqlPoolSnapshotResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolSnapshot'] = ResolversParentTypes['GqlPoolSnapshot'],
> = ResolversObject<{
    amounts?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    fees24h?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    holdersCount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    poolId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    sharePrice?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    surplus24h?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    swapsCount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    timestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    totalLiquidity?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    totalShares?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    totalSurplus?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    totalSwapFee?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    totalSwapVolume?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    volume24h?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolStableResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolStable'] = ResolversParentTypes['GqlPoolStable'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    allTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenExpanded']>, ParentType, ContextType>;
    amp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    categories?: Resolver<Maybe<Array<Maybe<ResolversTypes['GqlPoolFilterCategory']>>>, ParentType, ContextType>;
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    createTime?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    decimals?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    displayTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenDisplay']>, ParentType, ContextType>;
    dynamicData?: Resolver<ResolversTypes['GqlPoolDynamicData'], ParentType, ContextType>;
    factory?: Resolver<Maybe<ResolversTypes['Bytes']>, ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    investConfig?: Resolver<ResolversTypes['GqlPoolInvestConfig'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    owner?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    poolTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenDetail']>, ParentType, ContextType>;
    protocolVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    staking?: Resolver<Maybe<ResolversTypes['GqlPoolStaking']>, ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tags?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
    tokens?: Resolver<Array<ResolversTypes['GqlPoolToken']>, ParentType, ContextType>;
    type?: Resolver<ResolversTypes['GqlPoolType'], ParentType, ContextType>;
    userBalance?: Resolver<Maybe<ResolversTypes['GqlPoolUserBalance']>, ParentType, ContextType>;
    vaultVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    version?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    withdrawConfig?: Resolver<ResolversTypes['GqlPoolWithdrawConfig'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolStableComposablePoolDataResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolStableComposablePoolData'] = ResolversParentTypes['GqlPoolStableComposablePoolData'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    balance?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokens?: Resolver<Array<ResolversTypes['GqlPoolToken']>, ParentType, ContextType>;
    totalSupply?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolStakingResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolStaking'] = ResolversParentTypes['GqlPoolStaking'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    aura?: Resolver<Maybe<ResolversTypes['GqlPoolStakingAura']>, ParentType, ContextType>;
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    farm?: Resolver<Maybe<ResolversTypes['GqlPoolStakingMasterChefFarm']>, ParentType, ContextType>;
    gauge?: Resolver<Maybe<ResolversTypes['GqlPoolStakingGauge']>, ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    reliquary?: Resolver<Maybe<ResolversTypes['GqlPoolStakingReliquaryFarm']>, ParentType, ContextType>;
    type?: Resolver<ResolversTypes['GqlPoolStakingType'], ParentType, ContextType>;
    vebal?: Resolver<Maybe<ResolversTypes['GqlPoolStakingVebal']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolStakingAuraResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolStakingAura'] = ResolversParentTypes['GqlPoolStakingAura'],
> = ResolversObject<{
    apr?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    auraPoolAddress?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    auraPoolId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    isShutdown?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolStakingFarmRewarderResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolStakingFarmRewarder'] = ResolversParentTypes['GqlPoolStakingFarmRewarder'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    rewardPerSecond?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokenAddress?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolStakingGaugeResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolStakingGauge'] = ResolversParentTypes['GqlPoolStakingGauge'],
> = ResolversObject<{
    gaugeAddress?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    otherGauges?: Resolver<Maybe<Array<ResolversTypes['GqlPoolStakingOtherGauge']>>, ParentType, ContextType>;
    rewards?: Resolver<Array<ResolversTypes['GqlPoolStakingGaugeReward']>, ParentType, ContextType>;
    status?: Resolver<ResolversTypes['GqlPoolStakingGaugeStatus'], ParentType, ContextType>;
    version?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    workingSupply?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolStakingGaugeRewardResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolStakingGaugeReward'] = ResolversParentTypes['GqlPoolStakingGaugeReward'],
> = ResolversObject<{
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    rewardPerSecond?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokenAddress?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolStakingMasterChefFarmResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolStakingMasterChefFarm'] = ResolversParentTypes['GqlPoolStakingMasterChefFarm'],
> = ResolversObject<{
    beetsPerBlock?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    rewarders?: Resolver<Maybe<Array<ResolversTypes['GqlPoolStakingFarmRewarder']>>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolStakingOtherGaugeResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolStakingOtherGauge'] = ResolversParentTypes['GqlPoolStakingOtherGauge'],
> = ResolversObject<{
    gaugeAddress?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    rewards?: Resolver<Array<ResolversTypes['GqlPoolStakingGaugeReward']>, ParentType, ContextType>;
    status?: Resolver<ResolversTypes['GqlPoolStakingGaugeStatus'], ParentType, ContextType>;
    version?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolStakingReliquaryFarmResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolStakingReliquaryFarm'] = ResolversParentTypes['GqlPoolStakingReliquaryFarm'],
> = ResolversObject<{
    beetsPerSecond?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    levels?: Resolver<Maybe<Array<ResolversTypes['GqlPoolStakingReliquaryFarmLevel']>>, ParentType, ContextType>;
    totalBalance?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    totalWeightedBalance?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolStakingReliquaryFarmLevelResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolStakingReliquaryFarmLevel'] = ResolversParentTypes['GqlPoolStakingReliquaryFarmLevel'],
> = ResolversObject<{
    allocationPoints?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    apr?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    balance?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    level?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    requiredMaturity?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolStakingVebalResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolStakingVebal'] = ResolversParentTypes['GqlPoolStakingVebal'],
> = ResolversObject<{
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    vebalAddress?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolSwapResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolSwap'] = ResolversParentTypes['GqlPoolSwap'],
> = ResolversObject<{
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    poolId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    timestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    tokenAmountIn?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokenAmountOut?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokenIn?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokenOut?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tx?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    userAddress?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    valueUSD?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolSwapEventCowAmmResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolSwapEventCowAmm'] = ResolversParentTypes['GqlPoolSwapEventCowAmm'],
> = ResolversObject<{
    blockNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    blockTimestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    fee?: Resolver<ResolversTypes['GqlPoolEventAmount'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    logIndex?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    poolId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    sender?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    surplus?: Resolver<ResolversTypes['GqlPoolEventAmount'], ParentType, ContextType>;
    timestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    tokenIn?: Resolver<ResolversTypes['GqlPoolEventAmount'], ParentType, ContextType>;
    tokenOut?: Resolver<ResolversTypes['GqlPoolEventAmount'], ParentType, ContextType>;
    tx?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    type?: Resolver<ResolversTypes['GqlPoolEventType'], ParentType, ContextType>;
    userAddress?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    valueUSD?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolSwapEventV3Resolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolSwapEventV3'] = ResolversParentTypes['GqlPoolSwapEventV3'],
> = ResolversObject<{
    blockNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    blockTimestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    fee?: Resolver<ResolversTypes['GqlPoolEventAmount'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    logIndex?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    poolId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    sender?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    timestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    tokenIn?: Resolver<ResolversTypes['GqlPoolEventAmount'], ParentType, ContextType>;
    tokenOut?: Resolver<ResolversTypes['GqlPoolEventAmount'], ParentType, ContextType>;
    tx?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    type?: Resolver<ResolversTypes['GqlPoolEventType'], ParentType, ContextType>;
    userAddress?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    valueUSD?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolTokenResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolToken'] = ResolversParentTypes['GqlPoolToken'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    balance?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    decimals?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    index?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    priceRate?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    priceRateProvider?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    totalBalance?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    weight?: Resolver<Maybe<ResolversTypes['BigDecimal']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolTokenBaseResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolTokenBase'] = ResolversParentTypes['GqlPoolTokenBase'],
> = ResolversObject<{
    __resolveType: TypeResolveFn<'GqlPoolToken' | 'GqlPoolTokenComposableStable', ParentType, ContextType>;
    address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    balance?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    decimals?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    index?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    priceRate?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    priceRateProvider?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    totalBalance?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    weight?: Resolver<Maybe<ResolversTypes['BigDecimal']>, ParentType, ContextType>;
}>;

export type GqlPoolTokenComposableStableResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolTokenComposableStable'] = ResolversParentTypes['GqlPoolTokenComposableStable'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    balance?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    decimals?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    index?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    pool?: Resolver<ResolversTypes['GqlPoolComposableStableNested'], ParentType, ContextType>;
    priceRate?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    priceRateProvider?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    totalBalance?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    weight?: Resolver<Maybe<ResolversTypes['BigDecimal']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolTokenComposableStableNestedUnionResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolTokenComposableStableNestedUnion'] = ResolversParentTypes['GqlPoolTokenComposableStableNestedUnion'],
> = ResolversObject<{
    __resolveType: TypeResolveFn<'GqlPoolToken', ParentType, ContextType>;
}>;

export type GqlPoolTokenDetailResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolTokenDetail'] = ResolversParentTypes['GqlPoolTokenDetail'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    balance?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    balanceUSD?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    decimals?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    hasNestedPool?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    index?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    isAllowed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    isErc4626?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    nestedPool?: Resolver<Maybe<ResolversTypes['GqlNestedPool']>, ParentType, ContextType>;
    priceRate?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    priceRateProvider?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    priceRateProviderData?: Resolver<Maybe<ResolversTypes['GqlPriceRateProviderData']>, ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    underlyingToken?: Resolver<Maybe<ResolversTypes['GqlToken']>, ParentType, ContextType>;
    weight?: Resolver<Maybe<ResolversTypes['BigDecimal']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolTokenDisplayResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolTokenDisplay'] = ResolversParentTypes['GqlPoolTokenDisplay'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    nestedTokens?: Resolver<Maybe<Array<ResolversTypes['GqlPoolTokenDisplay']>>, ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    weight?: Resolver<Maybe<ResolversTypes['BigDecimal']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolTokenExpandedResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolTokenExpanded'] = ResolversParentTypes['GqlPoolTokenExpanded'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    decimals?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    isErc4626?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    isMainToken?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    isNested?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    isPhantomBpt?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    weight?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolTokenUnionResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolTokenUnion'] = ResolversParentTypes['GqlPoolTokenUnion'],
> = ResolversObject<{
    __resolveType: TypeResolveFn<'GqlPoolToken' | 'GqlPoolTokenComposableStable', ParentType, ContextType>;
}>;

export type GqlPoolUnionResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolUnion'] = ResolversParentTypes['GqlPoolUnion'],
> = ResolversObject<{
    __resolveType: TypeResolveFn<
        | 'GqlPoolComposableStable'
        | 'GqlPoolElement'
        | 'GqlPoolFx'
        | 'GqlPoolGyro'
        | 'GqlPoolLiquidityBootstrapping'
        | 'GqlPoolMetaStable'
        | 'GqlPoolStable'
        | 'GqlPoolWeighted',
        ParentType,
        ContextType
    >;
}>;

export type GqlPoolUserBalanceResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolUserBalance'] = ResolversParentTypes['GqlPoolUserBalance'],
> = ResolversObject<{
    stakedBalances?: Resolver<Array<ResolversTypes['GqlUserStakedBalance']>, ParentType, ContextType>;
    totalBalance?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    totalBalanceUsd?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    walletBalance?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    walletBalanceUsd?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolUserSwapVolumeResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolUserSwapVolume'] = ResolversParentTypes['GqlPoolUserSwapVolume'],
> = ResolversObject<{
    swapVolumeUSD?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    userAddress?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolWeightedResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolWeighted'] = ResolversParentTypes['GqlPoolWeighted'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    allTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenExpanded']>, ParentType, ContextType>;
    categories?: Resolver<Maybe<Array<Maybe<ResolversTypes['GqlPoolFilterCategory']>>>, ParentType, ContextType>;
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    createTime?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    decimals?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    displayTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenDisplay']>, ParentType, ContextType>;
    dynamicData?: Resolver<ResolversTypes['GqlPoolDynamicData'], ParentType, ContextType>;
    factory?: Resolver<Maybe<ResolversTypes['Bytes']>, ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    investConfig?: Resolver<ResolversTypes['GqlPoolInvestConfig'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    nestingType?: Resolver<ResolversTypes['GqlPoolNestingType'], ParentType, ContextType>;
    owner?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    poolTokens?: Resolver<Array<ResolversTypes['GqlPoolTokenDetail']>, ParentType, ContextType>;
    protocolVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    staking?: Resolver<Maybe<ResolversTypes['GqlPoolStaking']>, ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tags?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
    tokens?: Resolver<Array<ResolversTypes['GqlPoolTokenUnion']>, ParentType, ContextType>;
    type?: Resolver<ResolversTypes['GqlPoolType'], ParentType, ContextType>;
    userBalance?: Resolver<Maybe<ResolversTypes['GqlPoolUserBalance']>, ParentType, ContextType>;
    vaultVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    version?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    withdrawConfig?: Resolver<ResolversTypes['GqlPoolWithdrawConfig'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolWithdrawConfigResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolWithdrawConfig'] = ResolversParentTypes['GqlPoolWithdrawConfig'],
> = ResolversObject<{
    options?: Resolver<Array<ResolversTypes['GqlPoolWithdrawOption']>, ParentType, ContextType>;
    proportionalEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    singleAssetEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPoolWithdrawOptionResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPoolWithdrawOption'] = ResolversParentTypes['GqlPoolWithdrawOption'],
> = ResolversObject<{
    poolTokenAddress?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    poolTokenIndex?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    tokenOptions?: Resolver<Array<ResolversTypes['GqlPoolToken']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPriceImpactResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPriceImpact'] = ResolversParentTypes['GqlPriceImpact'],
> = ResolversObject<{
    error?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    priceImpact?: Resolver<Maybe<ResolversTypes['AmountHumanReadable']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPriceRateProviderDataResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPriceRateProviderData'] = ResolversParentTypes['GqlPriceRateProviderData'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    factory?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    reviewFile?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    reviewed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    summary?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    upgradeableComponents?: Resolver<
        Maybe<Array<Maybe<ResolversTypes['GqlPriceRateProviderUpgradeableComponent']>>>,
        ParentType,
        ContextType
    >;
    warnings?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlPriceRateProviderUpgradeableComponentResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlPriceRateProviderUpgradeableComponent'] = ResolversParentTypes['GqlPriceRateProviderUpgradeableComponent'],
> = ResolversObject<{
    entryPoint?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    implementationReviewed?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlProtocolMetricsAggregatedResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlProtocolMetricsAggregated'] = ResolversParentTypes['GqlProtocolMetricsAggregated'],
> = ResolversObject<{
    chains?: Resolver<Array<ResolversTypes['GqlProtocolMetricsChain']>, ParentType, ContextType>;
    numLiquidityProviders?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    poolCount?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    swapFee24h?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    swapVolume24h?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    totalLiquidity?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    totalSwapFee?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    totalSwapVolume?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    yieldCapture24h?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlProtocolMetricsChainResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlProtocolMetricsChain'] = ResolversParentTypes['GqlProtocolMetricsChain'],
> = ResolversObject<{
    chainId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    numLiquidityProviders?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    poolCount?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    swapFee24h?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    swapVolume24h?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    totalLiquidity?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    totalSwapFee?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    totalSwapVolume?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    yieldCapture24h?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlRelicSnapshotResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlRelicSnapshot'] = ResolversParentTypes['GqlRelicSnapshot'],
> = ResolversObject<{
    balance?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    entryTimestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    farmId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    level?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    relicId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlReliquaryFarmLevelSnapshotResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlReliquaryFarmLevelSnapshot'] = ResolversParentTypes['GqlReliquaryFarmLevelSnapshot'],
> = ResolversObject<{
    balance?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    level?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlReliquaryFarmSnapshotResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlReliquaryFarmSnapshot'] = ResolversParentTypes['GqlReliquaryFarmSnapshot'],
> = ResolversObject<{
    dailyDeposited?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    dailyWithdrawn?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    farmId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    levelBalances?: Resolver<Array<ResolversTypes['GqlReliquaryFarmLevelSnapshot']>, ParentType, ContextType>;
    relicCount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    timestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    tokenBalances?: Resolver<Array<ResolversTypes['GqlReliquaryTokenBalanceSnapshot']>, ParentType, ContextType>;
    totalBalance?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    totalLiquidity?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    userCount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlReliquaryTokenBalanceSnapshotResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlReliquaryTokenBalanceSnapshot'] = ResolversParentTypes['GqlReliquaryTokenBalanceSnapshot'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    balance?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    decimals?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlSftmxStakingDataResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlSftmxStakingData'] = ResolversParentTypes['GqlSftmxStakingData'],
> = ResolversObject<{
    exchangeRate?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    maintenancePaused?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    maxDepositLimit?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    minDepositLimit?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    numberOfVaults?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    stakingApr?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    totalFtmAmount?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    totalFtmAmountInPool?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    totalFtmAmountStaked?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    undelegatePaused?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    vaults?: Resolver<Array<ResolversTypes['GqlSftmxStakingVault']>, ParentType, ContextType>;
    withdrawPaused?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    withdrawalDelay?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlSftmxStakingSnapshotResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlSftmxStakingSnapshot'] = ResolversParentTypes['GqlSftmxStakingSnapshot'],
> = ResolversObject<{
    exchangeRate?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    timestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    totalFtmAmount?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    totalFtmAmountInPool?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    totalFtmAmountStaked?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlSftmxStakingVaultResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlSftmxStakingVault'] = ResolversParentTypes['GqlSftmxStakingVault'],
> = ResolversObject<{
    ftmAmountStaked?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    isMatured?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    unlockTimestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    validatorAddress?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    validatorId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    vaultAddress?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    vaultIndex?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlSftmxWithdrawalRequestsResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlSftmxWithdrawalRequests'] = ResolversParentTypes['GqlSftmxWithdrawalRequests'],
> = ResolversObject<{
    amountSftmx?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    isWithdrawn?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    requestTimestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    user?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlSorCallDataResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlSorCallData'] = ResolversParentTypes['GqlSorCallData'],
> = ResolversObject<{
    callData?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    maxAmountInRaw?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    minAmountOutRaw?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    to?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    value?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlSorGetSwapPathsResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlSorGetSwapPaths'] = ResolversParentTypes['GqlSorGetSwapPaths'],
> = ResolversObject<{
    callData?: Resolver<Maybe<ResolversTypes['GqlSorCallData']>, ParentType, ContextType>;
    effectivePrice?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    effectivePriceReversed?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    paths?: Resolver<Array<ResolversTypes['GqlSorPath']>, ParentType, ContextType>;
    priceImpact?: Resolver<ResolversTypes['GqlPriceImpact'], ParentType, ContextType>;
    protocolVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    returnAmount?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    returnAmountRaw?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    routes?: Resolver<Array<ResolversTypes['GqlSorSwapRoute']>, ParentType, ContextType>;
    swapAmount?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    swapAmountRaw?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    swapType?: Resolver<ResolversTypes['GqlSorSwapType'], ParentType, ContextType>;
    swaps?: Resolver<Array<ResolversTypes['GqlSorSwap']>, ParentType, ContextType>;
    tokenAddresses?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
    tokenIn?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokenInAmount?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    tokenOut?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokenOutAmount?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    vaultVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlSorGetSwapsResponseResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlSorGetSwapsResponse'] = ResolversParentTypes['GqlSorGetSwapsResponse'],
> = ResolversObject<{
    effectivePrice?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    effectivePriceReversed?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    marketSp?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    priceImpact?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    returnAmount?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    returnAmountConsideringFees?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    returnAmountFromSwaps?: Resolver<Maybe<ResolversTypes['BigDecimal']>, ParentType, ContextType>;
    returnAmountScaled?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    routes?: Resolver<Array<ResolversTypes['GqlSorSwapRoute']>, ParentType, ContextType>;
    swapAmount?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    swapAmountForSwaps?: Resolver<Maybe<ResolversTypes['BigDecimal']>, ParentType, ContextType>;
    swapAmountScaled?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
    swapType?: Resolver<ResolversTypes['GqlSorSwapType'], ParentType, ContextType>;
    swaps?: Resolver<Array<ResolversTypes['GqlSorSwap']>, ParentType, ContextType>;
    tokenAddresses?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
    tokenIn?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokenInAmount?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    tokenOut?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokenOutAmount?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlSorPathResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlSorPath'] = ResolversParentTypes['GqlSorPath'],
> = ResolversObject<{
    inputAmountRaw?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    isBuffer?: Resolver<Array<Maybe<ResolversTypes['Boolean']>>, ParentType, ContextType>;
    outputAmountRaw?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    pools?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
    protocolVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    tokens?: Resolver<Array<Maybe<ResolversTypes['Token']>>, ParentType, ContextType>;
    vaultVersion?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlSorSwapResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlSorSwap'] = ResolversParentTypes['GqlSorSwap'],
> = ResolversObject<{
    amount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    assetInIndex?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    assetOutIndex?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    poolId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    userData?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlSorSwapRouteResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlSorSwapRoute'] = ResolversParentTypes['GqlSorSwapRoute'],
> = ResolversObject<{
    hops?: Resolver<Array<ResolversTypes['GqlSorSwapRouteHop']>, ParentType, ContextType>;
    share?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    tokenIn?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokenInAmount?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    tokenOut?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokenOutAmount?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlSorSwapRouteHopResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlSorSwapRouteHop'] = ResolversParentTypes['GqlSorSwapRouteHop'],
> = ResolversObject<{
    pool?: Resolver<ResolversTypes['GqlPoolMinimal'], ParentType, ContextType>;
    poolId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokenIn?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokenInAmount?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    tokenOut?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokenOutAmount?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlTokenResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlToken'] = ResolversParentTypes['GqlToken'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    chainId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    coingeckoId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    decimals?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    discordUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    isErc4626?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    logoURI?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    priceRateProviderData?: Resolver<Maybe<ResolversTypes['GqlPriceRateProviderData']>, ParentType, ContextType>;
    priority?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    rateProviderData?: Resolver<Maybe<ResolversTypes['GqlPriceRateProviderData']>, ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    telegramUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    tradable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    twitterUsername?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    websiteUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlTokenCandlestickChartDataItemResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlTokenCandlestickChartDataItem'] = ResolversParentTypes['GqlTokenCandlestickChartDataItem'],
> = ResolversObject<{
    close?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    high?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    low?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    open?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    timestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlTokenDataResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlTokenData'] = ResolversParentTypes['GqlTokenData'],
> = ResolversObject<{
    description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    discordUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    telegramUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    tokenAddress?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    twitterUsername?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    websiteUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlTokenDynamicDataResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlTokenDynamicData'] = ResolversParentTypes['GqlTokenDynamicData'],
> = ResolversObject<{
    ath?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    atl?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    fdv?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    high24h?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    low24h?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    marketCap?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    price?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    priceChange24h?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    priceChangePercent7d?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    priceChangePercent14d?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    priceChangePercent24h?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    priceChangePercent30d?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    tokenAddress?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    updatedAt?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlTokenMutationResultResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlTokenMutationResult'] = ResolversParentTypes['GqlTokenMutationResult'],
> = ResolversObject<{
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    error?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlTokenPriceResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlTokenPrice'] = ResolversParentTypes['GqlTokenPrice'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    price?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    updatedAt?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    updatedBy?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlTokenPriceChartDataItemResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlTokenPriceChartDataItem'] = ResolversParentTypes['GqlTokenPriceChartDataItem'],
> = ResolversObject<{
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    price?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    timestamp?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlUserFbeetsBalanceResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlUserFbeetsBalance'] = ResolversParentTypes['GqlUserFbeetsBalance'],
> = ResolversObject<{
    id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    stakedBalance?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    totalBalance?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    walletBalance?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlUserPoolBalanceResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlUserPoolBalance'] = ResolversParentTypes['GqlUserPoolBalance'],
> = ResolversObject<{
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    poolId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    stakedBalance?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    tokenAddress?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokenPrice?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    totalBalance?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    walletBalance?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlUserStakedBalanceResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlUserStakedBalance'] = ResolversParentTypes['GqlUserStakedBalance'],
> = ResolversObject<{
    balance?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    balanceUsd?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    stakingId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    stakingType?: Resolver<ResolversTypes['GqlPoolStakingType'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlVeBalBalanceResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlVeBalBalance'] = ResolversParentTypes['GqlVeBalBalance'],
> = ResolversObject<{
    balance?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    locked?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    lockedUsd?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlVeBalUserDataResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlVeBalUserData'] = ResolversParentTypes['GqlVeBalUserData'],
> = ResolversObject<{
    balance?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    locked?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    lockedUsd?: Resolver<ResolversTypes['AmountHumanReadable'], ParentType, ContextType>;
    rank?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlVotingGaugeResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlVotingGauge'] = ResolversParentTypes['GqlVotingGauge'],
> = ResolversObject<{
    addedTimestamp?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    childGaugeAddress?: Resolver<Maybe<ResolversTypes['Bytes']>, ParentType, ContextType>;
    isKilled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    relativeWeight?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    relativeWeightCap?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlVotingGaugeTokenResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlVotingGaugeToken'] = ResolversParentTypes['GqlVotingGaugeToken'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    logoURI?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    weight?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GqlVotingPoolResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['GqlVotingPool'] = ResolversParentTypes['GqlVotingPool'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    gauge?: Resolver<ResolversTypes['GqlVotingGauge'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokens?: Resolver<Array<ResolversTypes['GqlVotingGaugeToken']>, ParentType, ContextType>;
    type?: Resolver<ResolversTypes['GqlPoolType'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type HookResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['Hook'] = ResolversParentTypes['Hook'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    chain?: Resolver<ResolversTypes['GqlChain'], ParentType, ContextType>;
    dynamicData?: Resolver<Maybe<ResolversTypes['HookData']>, ParentType, ContextType>;
    enableHookAdjustedAmounts?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    poolsIds?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
    shouldCallAfterAddLiquidity?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    shouldCallAfterInitialize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    shouldCallAfterRemoveLiquidity?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    shouldCallAfterSwap?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    shouldCallBeforeAddLiquidity?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    shouldCallBeforeInitialize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    shouldCallBeforeRemoveLiquidity?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    shouldCallBeforeSwap?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    shouldCallComputeDynamicSwapFee?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type HookDataResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['HookData'] = ResolversParentTypes['HookData'],
> = ResolversObject<{
    addLiquidityFeePercentage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    removeLiquidityFeePercentage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    swapFeePercentage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export interface JsonScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSON'], any> {
    name: 'JSON';
}

export type MutationResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation'],
> = ResolversObject<{
    beetsPoolLoadReliquarySnapshotsForAllFarms?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    beetsSyncFbeetsRatio?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    cacheAverageBlockTime?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    poolBlackListAddPool?: Resolver<
        ResolversTypes['String'],
        ParentType,
        ContextType,
        RequireFields<MutationPoolBlackListAddPoolArgs, 'poolId'>
    >;
    poolBlackListRemovePool?: Resolver<
        ResolversTypes['String'],
        ParentType,
        ContextType,
        RequireFields<MutationPoolBlackListRemovePoolArgs, 'poolId'>
    >;
    poolDeletePool?: Resolver<
        ResolversTypes['String'],
        ParentType,
        ContextType,
        RequireFields<MutationPoolDeletePoolArgs, 'poolId'>
    >;
    poolInitOnChainDataForAllPools?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    poolInitializeSnapshotsForPool?: Resolver<
        ResolversTypes['String'],
        ParentType,
        ContextType,
        RequireFields<MutationPoolInitializeSnapshotsForPoolArgs, 'poolId'>
    >;
    poolLoadOnChainDataForAllPools?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    poolLoadOnChainDataForPoolsWithActiveUpdates?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    poolLoadSnapshotsForAllPools?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    poolLoadSnapshotsForPools?: Resolver<
        ResolversTypes['String'],
        ParentType,
        ContextType,
        RequireFields<MutationPoolLoadSnapshotsForPoolsArgs, 'poolIds'>
    >;
    poolReloadAllPoolAprs?: Resolver<
        ResolversTypes['String'],
        ParentType,
        ContextType,
        RequireFields<MutationPoolReloadAllPoolAprsArgs, 'chain'>
    >;
    poolReloadAllTokenNestedPoolIds?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    poolReloadPools?: Resolver<
        Array<ResolversTypes['GqlPoolMutationResult']>,
        ParentType,
        ContextType,
        RequireFields<MutationPoolReloadPoolsArgs, 'chains'>
    >;
    poolReloadStakingForAllPools?: Resolver<
        ResolversTypes['String'],
        ParentType,
        ContextType,
        RequireFields<MutationPoolReloadStakingForAllPoolsArgs, 'stakingTypes'>
    >;
    poolSyncAllCowSnapshots?: Resolver<
        Array<ResolversTypes['GqlPoolMutationResult']>,
        ParentType,
        ContextType,
        RequireFields<MutationPoolSyncAllCowSnapshotsArgs, 'chains'>
    >;
    poolSyncAllPoolsFromSubgraph?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
    poolSyncLatestSnapshotsForAllPools?: Resolver<
        ResolversTypes['String'],
        ParentType,
        ContextType,
        RequireFields<MutationPoolSyncLatestSnapshotsForAllPoolsArgs, 'chain'>
    >;
    poolSyncNewPoolsFromSubgraph?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
    poolSyncPool?: Resolver<
        ResolversTypes['String'],
        ParentType,
        ContextType,
        RequireFields<MutationPoolSyncPoolArgs, 'poolId'>
    >;
    poolSyncPoolAllTokensRelationship?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    poolSyncSanityPoolData?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    poolSyncStakingForPools?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    poolSyncSwapsForLast48Hours?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    poolSyncTotalShares?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    poolUpdateAprs?: Resolver<
        ResolversTypes['String'],
        ParentType,
        ContextType,
        RequireFields<MutationPoolUpdateAprsArgs, 'chain'>
    >;
    poolUpdateLifetimeValuesForAllPools?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    poolUpdateLiquidity24hAgoForAllPools?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    poolUpdateLiquidityValuesForAllPools?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    poolUpdateVolumeAndFeeValuesForAllPools?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    protocolCacheMetrics?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    sftmxSyncStakingData?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    sftmxSyncWithdrawalRequests?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokenDeleteTokenType?: Resolver<
        ResolversTypes['String'],
        ParentType,
        ContextType,
        RequireFields<MutationTokenDeleteTokenTypeArgs, 'tokenAddress' | 'type'>
    >;
    tokenReloadAllTokenTypes?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tokenReloadErc4626Tokens?: Resolver<
        Array<ResolversTypes['GqlTokenMutationResult']>,
        ParentType,
        ContextType,
        RequireFields<MutationTokenReloadErc4626TokensArgs, 'chains'>
    >;
    tokenReloadTokenPrices?: Resolver<
        Maybe<ResolversTypes['Boolean']>,
        ParentType,
        ContextType,
        RequireFields<MutationTokenReloadTokenPricesArgs, 'chains'>
    >;
    tokenSyncLatestFxPrices?: Resolver<
        ResolversTypes['String'],
        ParentType,
        ContextType,
        RequireFields<MutationTokenSyncLatestFxPricesArgs, 'chain'>
    >;
    tokenSyncTokenDefinitions?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    userInitStakedBalances?: Resolver<
        ResolversTypes['String'],
        ParentType,
        ContextType,
        RequireFields<MutationUserInitStakedBalancesArgs, 'stakingTypes'>
    >;
    userInitWalletBalancesForAllPools?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    userInitWalletBalancesForPool?: Resolver<
        ResolversTypes['String'],
        ParentType,
        ContextType,
        RequireFields<MutationUserInitWalletBalancesForPoolArgs, 'poolId'>
    >;
    userSyncBalance?: Resolver<
        ResolversTypes['String'],
        ParentType,
        ContextType,
        RequireFields<MutationUserSyncBalanceArgs, 'poolId'>
    >;
    userSyncBalanceAllPools?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    userSyncChangedStakedBalances?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    userSyncChangedWalletBalancesForAllPools?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    veBalSyncAllUserBalances?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    veBalSyncTotalSupply?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
}>;

export type QueryResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query'],
> = ResolversObject<{
    beetsGetFbeetsRatio?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    beetsPoolGetReliquaryFarmSnapshots?: Resolver<
        Array<ResolversTypes['GqlReliquaryFarmSnapshot']>,
        ParentType,
        ContextType,
        RequireFields<QueryBeetsPoolGetReliquaryFarmSnapshotsArgs, 'id' | 'range'>
    >;
    blocksGetAverageBlockTime?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    blocksGetBlocksPerDay?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    blocksGetBlocksPerSecond?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    blocksGetBlocksPerYear?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
    contentGetNewsItems?: Resolver<
        Array<ResolversTypes['GqlContentNewsItem']>,
        ParentType,
        ContextType,
        RequireFields<QueryContentGetNewsItemsArgs, never>
    >;
    hooks?: Resolver<
        Maybe<Array<ResolversTypes['Hook']>>,
        ParentType,
        ContextType,
        RequireFields<QueryHooksArgs, never>
    >;
    latestSyncedBlocks?: Resolver<ResolversTypes['GqlLatestSyncedBlocks'], ParentType, ContextType>;
    poolEvents?: Resolver<
        Array<ResolversTypes['GqlPoolEvent']>,
        ParentType,
        ContextType,
        RequireFields<QueryPoolEventsArgs, never>
    >;
    poolGetAggregatorPools?: Resolver<
        Array<ResolversTypes['GqlPoolAggregator']>,
        ParentType,
        ContextType,
        RequireFields<QueryPoolGetAggregatorPoolsArgs, never>
    >;
    poolGetBatchSwaps?: Resolver<
        Array<ResolversTypes['GqlPoolBatchSwap']>,
        ParentType,
        ContextType,
        RequireFields<QueryPoolGetBatchSwapsArgs, never>
    >;
    poolGetEvents?: Resolver<
        Array<ResolversTypes['GqlPoolEvent']>,
        ParentType,
        ContextType,
        RequireFields<QueryPoolGetEventsArgs, 'chain' | 'poolId' | 'range' | 'typeIn'>
    >;
    poolGetFeaturedPoolGroups?: Resolver<
        Array<ResolversTypes['GqlPoolFeaturedPoolGroup']>,
        ParentType,
        ContextType,
        RequireFields<QueryPoolGetFeaturedPoolGroupsArgs, never>
    >;
    poolGetFeaturedPools?: Resolver<
        Array<ResolversTypes['GqlPoolFeaturedPool']>,
        ParentType,
        ContextType,
        RequireFields<QueryPoolGetFeaturedPoolsArgs, 'chains'>
    >;
    poolGetJoinExits?: Resolver<
        Array<ResolversTypes['GqlPoolJoinExit']>,
        ParentType,
        ContextType,
        RequireFields<QueryPoolGetJoinExitsArgs, never>
    >;
    poolGetPool?: Resolver<
        ResolversTypes['GqlPoolBase'],
        ParentType,
        ContextType,
        RequireFields<QueryPoolGetPoolArgs, 'id'>
    >;
    poolGetPools?: Resolver<
        Array<ResolversTypes['GqlPoolMinimal']>,
        ParentType,
        ContextType,
        RequireFields<QueryPoolGetPoolsArgs, never>
    >;
    poolGetPoolsCount?: Resolver<
        ResolversTypes['Int'],
        ParentType,
        ContextType,
        RequireFields<QueryPoolGetPoolsCountArgs, never>
    >;
    poolGetSnapshots?: Resolver<
        Array<ResolversTypes['GqlPoolSnapshot']>,
        ParentType,
        ContextType,
        RequireFields<QueryPoolGetSnapshotsArgs, 'id' | 'range'>
    >;
    poolGetSwaps?: Resolver<
        Array<ResolversTypes['GqlPoolSwap']>,
        ParentType,
        ContextType,
        RequireFields<QueryPoolGetSwapsArgs, never>
    >;
    protocolMetricsAggregated?: Resolver<
        ResolversTypes['GqlProtocolMetricsAggregated'],
        ParentType,
        ContextType,
        RequireFields<QueryProtocolMetricsAggregatedArgs, never>
    >;
    protocolMetricsChain?: Resolver<
        ResolversTypes['GqlProtocolMetricsChain'],
        ParentType,
        ContextType,
        RequireFields<QueryProtocolMetricsChainArgs, never>
    >;
    sftmxGetStakingData?: Resolver<ResolversTypes['GqlSftmxStakingData'], ParentType, ContextType>;
    sftmxGetStakingSnapshots?: Resolver<
        Array<ResolversTypes['GqlSftmxStakingSnapshot']>,
        ParentType,
        ContextType,
        RequireFields<QuerySftmxGetStakingSnapshotsArgs, 'range'>
    >;
    sftmxGetWithdrawalRequests?: Resolver<
        Array<ResolversTypes['GqlSftmxWithdrawalRequests']>,
        ParentType,
        ContextType,
        RequireFields<QuerySftmxGetWithdrawalRequestsArgs, 'user'>
    >;
    sorGetSwapPaths?: Resolver<
        ResolversTypes['GqlSorGetSwapPaths'],
        ParentType,
        ContextType,
        RequireFields<QuerySorGetSwapPathsArgs, 'chain' | 'swapAmount' | 'swapType' | 'tokenIn' | 'tokenOut'>
    >;
    sorGetSwaps?: Resolver<
        ResolversTypes['GqlSorGetSwapsResponse'],
        ParentType,
        ContextType,
        RequireFields<QuerySorGetSwapsArgs, 'swapAmount' | 'swapOptions' | 'swapType' | 'tokenIn' | 'tokenOut'>
    >;
    tokenGetCandlestickChartData?: Resolver<
        Array<ResolversTypes['GqlTokenCandlestickChartDataItem']>,
        ParentType,
        ContextType,
        RequireFields<QueryTokenGetCandlestickChartDataArgs, 'address' | 'range'>
    >;
    tokenGetCurrentPrices?: Resolver<
        Array<ResolversTypes['GqlTokenPrice']>,
        ParentType,
        ContextType,
        RequireFields<QueryTokenGetCurrentPricesArgs, never>
    >;
    tokenGetHistoricalPrices?: Resolver<
        Array<ResolversTypes['GqlHistoricalTokenPrice']>,
        ParentType,
        ContextType,
        RequireFields<QueryTokenGetHistoricalPricesArgs, 'addresses' | 'chain' | 'range'>
    >;
    tokenGetPriceChartData?: Resolver<
        Array<ResolversTypes['GqlTokenPriceChartDataItem']>,
        ParentType,
        ContextType,
        RequireFields<QueryTokenGetPriceChartDataArgs, 'address' | 'range'>
    >;
    tokenGetProtocolTokenPrice?: Resolver<
        ResolversTypes['AmountHumanReadable'],
        ParentType,
        ContextType,
        RequireFields<QueryTokenGetProtocolTokenPriceArgs, never>
    >;
    tokenGetRelativePriceChartData?: Resolver<
        Array<ResolversTypes['GqlTokenPriceChartDataItem']>,
        ParentType,
        ContextType,
        RequireFields<QueryTokenGetRelativePriceChartDataArgs, 'range' | 'tokenIn' | 'tokenOut'>
    >;
    tokenGetTokenData?: Resolver<
        Maybe<ResolversTypes['GqlTokenData']>,
        ParentType,
        ContextType,
        RequireFields<QueryTokenGetTokenDataArgs, 'address'>
    >;
    tokenGetTokenDynamicData?: Resolver<
        Maybe<ResolversTypes['GqlTokenDynamicData']>,
        ParentType,
        ContextType,
        RequireFields<QueryTokenGetTokenDynamicDataArgs, 'address'>
    >;
    tokenGetTokens?: Resolver<
        Array<ResolversTypes['GqlToken']>,
        ParentType,
        ContextType,
        RequireFields<QueryTokenGetTokensArgs, never>
    >;
    tokenGetTokensData?: Resolver<
        Array<ResolversTypes['GqlTokenData']>,
        ParentType,
        ContextType,
        RequireFields<QueryTokenGetTokensDataArgs, 'addresses'>
    >;
    tokenGetTokensDynamicData?: Resolver<
        Array<ResolversTypes['GqlTokenDynamicData']>,
        ParentType,
        ContextType,
        RequireFields<QueryTokenGetTokensDynamicDataArgs, 'addresses'>
    >;
    userGetFbeetsBalance?: Resolver<ResolversTypes['GqlUserFbeetsBalance'], ParentType, ContextType>;
    userGetPoolBalances?: Resolver<
        Array<ResolversTypes['GqlUserPoolBalance']>,
        ParentType,
        ContextType,
        RequireFields<QueryUserGetPoolBalancesArgs, never>
    >;
    userGetPoolJoinExits?: Resolver<
        Array<ResolversTypes['GqlPoolJoinExit']>,
        ParentType,
        ContextType,
        RequireFields<QueryUserGetPoolJoinExitsArgs, 'first' | 'poolId' | 'skip'>
    >;
    userGetStaking?: Resolver<
        Array<ResolversTypes['GqlPoolStaking']>,
        ParentType,
        ContextType,
        RequireFields<QueryUserGetStakingArgs, never>
    >;
    userGetSwaps?: Resolver<
        Array<ResolversTypes['GqlPoolSwap']>,
        ParentType,
        ContextType,
        RequireFields<QueryUserGetSwapsArgs, 'first' | 'poolId' | 'skip'>
    >;
    veBalGetTotalSupply?: Resolver<
        ResolversTypes['AmountHumanReadable'],
        ParentType,
        ContextType,
        RequireFields<QueryVeBalGetTotalSupplyArgs, never>
    >;
    veBalGetUser?: Resolver<
        ResolversTypes['GqlVeBalUserData'],
        ParentType,
        ContextType,
        RequireFields<QueryVeBalGetUserArgs, 'address'>
    >;
    veBalGetUserBalance?: Resolver<
        ResolversTypes['AmountHumanReadable'],
        ParentType,
        ContextType,
        RequireFields<QueryVeBalGetUserBalanceArgs, never>
    >;
    veBalGetUserBalances?: Resolver<
        Array<ResolversTypes['GqlVeBalBalance']>,
        ParentType,
        ContextType,
        RequireFields<QueryVeBalGetUserBalancesArgs, 'address'>
    >;
    veBalGetVotingList?: Resolver<Array<ResolversTypes['GqlVotingPool']>, ParentType, ContextType>;
}>;

export type TokenResolvers<
    ContextType = ResolverContext,
    ParentType extends ResolversParentTypes['Token'] = ResolversParentTypes['Token'],
> = ResolversObject<{
    address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    decimals?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Resolvers<ContextType = ResolverContext> = ResolversObject<{
    AmountHumanReadable?: GraphQLScalarType;
    BigDecimal?: GraphQLScalarType;
    BigInt?: GraphQLScalarType;
    Bytes?: GraphQLScalarType;
    Date?: GraphQLScalarType;
    GqlBalancePoolAprItem?: GqlBalancePoolAprItemResolvers<ContextType>;
    GqlBalancePoolAprSubItem?: GqlBalancePoolAprSubItemResolvers<ContextType>;
    GqlBigNumber?: GraphQLScalarType;
    GqlContentNewsItem?: GqlContentNewsItemResolvers<ContextType>;
    GqlFeaturePoolGroupItemExternalLink?: GqlFeaturePoolGroupItemExternalLinkResolvers<ContextType>;
    GqlHistoricalTokenPrice?: GqlHistoricalTokenPriceResolvers<ContextType>;
    GqlHistoricalTokenPriceEntry?: GqlHistoricalTokenPriceEntryResolvers<ContextType>;
    GqlLatestSyncedBlocks?: GqlLatestSyncedBlocksResolvers<ContextType>;
    GqlNestedPool?: GqlNestedPoolResolvers<ContextType>;
    GqlPoolAddRemoveEventV3?: GqlPoolAddRemoveEventV3Resolvers<ContextType>;
    GqlPoolAggregator?: GqlPoolAggregatorResolvers<ContextType>;
    GqlPoolApr?: GqlPoolAprResolvers<ContextType>;
    GqlPoolAprItem?: GqlPoolAprItemResolvers<ContextType>;
    GqlPoolAprRange?: GqlPoolAprRangeResolvers<ContextType>;
    GqlPoolAprTotal?: GqlPoolAprTotalResolvers<ContextType>;
    GqlPoolAprValue?: GqlPoolAprValueResolvers<ContextType>;
    GqlPoolBase?: GqlPoolBaseResolvers<ContextType>;
    GqlPoolBatchSwap?: GqlPoolBatchSwapResolvers<ContextType>;
    GqlPoolBatchSwapPool?: GqlPoolBatchSwapPoolResolvers<ContextType>;
    GqlPoolBatchSwapSwap?: GqlPoolBatchSwapSwapResolvers<ContextType>;
    GqlPoolComposableStable?: GqlPoolComposableStableResolvers<ContextType>;
    GqlPoolComposableStableNested?: GqlPoolComposableStableNestedResolvers<ContextType>;
    GqlPoolDynamicData?: GqlPoolDynamicDataResolvers<ContextType>;
    GqlPoolElement?: GqlPoolElementResolvers<ContextType>;
    GqlPoolEvent?: GqlPoolEventResolvers<ContextType>;
    GqlPoolEventAmount?: GqlPoolEventAmountResolvers<ContextType>;
    GqlPoolFeaturedPool?: GqlPoolFeaturedPoolResolvers<ContextType>;
    GqlPoolFeaturedPoolGroup?: GqlPoolFeaturedPoolGroupResolvers<ContextType>;
    GqlPoolFeaturedPoolGroupItem?: GqlPoolFeaturedPoolGroupItemResolvers<ContextType>;
    GqlPoolFx?: GqlPoolFxResolvers<ContextType>;
    GqlPoolGyro?: GqlPoolGyroResolvers<ContextType>;
    GqlPoolInvestConfig?: GqlPoolInvestConfigResolvers<ContextType>;
    GqlPoolInvestOption?: GqlPoolInvestOptionResolvers<ContextType>;
    GqlPoolJoinExit?: GqlPoolJoinExitResolvers<ContextType>;
    GqlPoolJoinExitAmount?: GqlPoolJoinExitAmountResolvers<ContextType>;
    GqlPoolLiquidityBootstrapping?: GqlPoolLiquidityBootstrappingResolvers<ContextType>;
    GqlPoolMetaStable?: GqlPoolMetaStableResolvers<ContextType>;
    GqlPoolMinimal?: GqlPoolMinimalResolvers<ContextType>;
    GqlPoolMutationResult?: GqlPoolMutationResultResolvers<ContextType>;
    GqlPoolNestedUnion?: GqlPoolNestedUnionResolvers<ContextType>;
    GqlPoolSnapshot?: GqlPoolSnapshotResolvers<ContextType>;
    GqlPoolStable?: GqlPoolStableResolvers<ContextType>;
    GqlPoolStableComposablePoolData?: GqlPoolStableComposablePoolDataResolvers<ContextType>;
    GqlPoolStaking?: GqlPoolStakingResolvers<ContextType>;
    GqlPoolStakingAura?: GqlPoolStakingAuraResolvers<ContextType>;
    GqlPoolStakingFarmRewarder?: GqlPoolStakingFarmRewarderResolvers<ContextType>;
    GqlPoolStakingGauge?: GqlPoolStakingGaugeResolvers<ContextType>;
    GqlPoolStakingGaugeReward?: GqlPoolStakingGaugeRewardResolvers<ContextType>;
    GqlPoolStakingMasterChefFarm?: GqlPoolStakingMasterChefFarmResolvers<ContextType>;
    GqlPoolStakingOtherGauge?: GqlPoolStakingOtherGaugeResolvers<ContextType>;
    GqlPoolStakingReliquaryFarm?: GqlPoolStakingReliquaryFarmResolvers<ContextType>;
    GqlPoolStakingReliquaryFarmLevel?: GqlPoolStakingReliquaryFarmLevelResolvers<ContextType>;
    GqlPoolStakingVebal?: GqlPoolStakingVebalResolvers<ContextType>;
    GqlPoolSwap?: GqlPoolSwapResolvers<ContextType>;
    GqlPoolSwapEventCowAmm?: GqlPoolSwapEventCowAmmResolvers<ContextType>;
    GqlPoolSwapEventV3?: GqlPoolSwapEventV3Resolvers<ContextType>;
    GqlPoolToken?: GqlPoolTokenResolvers<ContextType>;
    GqlPoolTokenBase?: GqlPoolTokenBaseResolvers<ContextType>;
    GqlPoolTokenComposableStable?: GqlPoolTokenComposableStableResolvers<ContextType>;
    GqlPoolTokenComposableStableNestedUnion?: GqlPoolTokenComposableStableNestedUnionResolvers<ContextType>;
    GqlPoolTokenDetail?: GqlPoolTokenDetailResolvers<ContextType>;
    GqlPoolTokenDisplay?: GqlPoolTokenDisplayResolvers<ContextType>;
    GqlPoolTokenExpanded?: GqlPoolTokenExpandedResolvers<ContextType>;
    GqlPoolTokenUnion?: GqlPoolTokenUnionResolvers<ContextType>;
    GqlPoolUnion?: GqlPoolUnionResolvers<ContextType>;
    GqlPoolUserBalance?: GqlPoolUserBalanceResolvers<ContextType>;
    GqlPoolUserSwapVolume?: GqlPoolUserSwapVolumeResolvers<ContextType>;
    GqlPoolWeighted?: GqlPoolWeightedResolvers<ContextType>;
    GqlPoolWithdrawConfig?: GqlPoolWithdrawConfigResolvers<ContextType>;
    GqlPoolWithdrawOption?: GqlPoolWithdrawOptionResolvers<ContextType>;
    GqlPriceImpact?: GqlPriceImpactResolvers<ContextType>;
    GqlPriceRateProviderData?: GqlPriceRateProviderDataResolvers<ContextType>;
    GqlPriceRateProviderUpgradeableComponent?: GqlPriceRateProviderUpgradeableComponentResolvers<ContextType>;
    GqlProtocolMetricsAggregated?: GqlProtocolMetricsAggregatedResolvers<ContextType>;
    GqlProtocolMetricsChain?: GqlProtocolMetricsChainResolvers<ContextType>;
    GqlRelicSnapshot?: GqlRelicSnapshotResolvers<ContextType>;
    GqlReliquaryFarmLevelSnapshot?: GqlReliquaryFarmLevelSnapshotResolvers<ContextType>;
    GqlReliquaryFarmSnapshot?: GqlReliquaryFarmSnapshotResolvers<ContextType>;
    GqlReliquaryTokenBalanceSnapshot?: GqlReliquaryTokenBalanceSnapshotResolvers<ContextType>;
    GqlSftmxStakingData?: GqlSftmxStakingDataResolvers<ContextType>;
    GqlSftmxStakingSnapshot?: GqlSftmxStakingSnapshotResolvers<ContextType>;
    GqlSftmxStakingVault?: GqlSftmxStakingVaultResolvers<ContextType>;
    GqlSftmxWithdrawalRequests?: GqlSftmxWithdrawalRequestsResolvers<ContextType>;
    GqlSorCallData?: GqlSorCallDataResolvers<ContextType>;
    GqlSorGetSwapPaths?: GqlSorGetSwapPathsResolvers<ContextType>;
    GqlSorGetSwapsResponse?: GqlSorGetSwapsResponseResolvers<ContextType>;
    GqlSorPath?: GqlSorPathResolvers<ContextType>;
    GqlSorSwap?: GqlSorSwapResolvers<ContextType>;
    GqlSorSwapRoute?: GqlSorSwapRouteResolvers<ContextType>;
    GqlSorSwapRouteHop?: GqlSorSwapRouteHopResolvers<ContextType>;
    GqlToken?: GqlTokenResolvers<ContextType>;
    GqlTokenCandlestickChartDataItem?: GqlTokenCandlestickChartDataItemResolvers<ContextType>;
    GqlTokenData?: GqlTokenDataResolvers<ContextType>;
    GqlTokenDynamicData?: GqlTokenDynamicDataResolvers<ContextType>;
    GqlTokenMutationResult?: GqlTokenMutationResultResolvers<ContextType>;
    GqlTokenPrice?: GqlTokenPriceResolvers<ContextType>;
    GqlTokenPriceChartDataItem?: GqlTokenPriceChartDataItemResolvers<ContextType>;
    GqlUserFbeetsBalance?: GqlUserFbeetsBalanceResolvers<ContextType>;
    GqlUserPoolBalance?: GqlUserPoolBalanceResolvers<ContextType>;
    GqlUserStakedBalance?: GqlUserStakedBalanceResolvers<ContextType>;
    GqlVeBalBalance?: GqlVeBalBalanceResolvers<ContextType>;
    GqlVeBalUserData?: GqlVeBalUserDataResolvers<ContextType>;
    GqlVotingGauge?: GqlVotingGaugeResolvers<ContextType>;
    GqlVotingGaugeToken?: GqlVotingGaugeTokenResolvers<ContextType>;
    GqlVotingPool?: GqlVotingPoolResolvers<ContextType>;
    Hook?: HookResolvers<ContextType>;
    HookData?: HookDataResolvers<ContextType>;
    JSON?: GraphQLScalarType;
    Mutation?: MutationResolvers<ContextType>;
    Query?: QueryResolvers<ContextType>;
    Token?: TokenResolvers<ContextType>;
}>;
