"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""
Defined a Subgraph ID for an object type
"""
directive @subgraphId(id: String!) on OBJECT

type AddRemove {
    amounts: [BigDecimal!]!
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    logIndex: BigInt!
    pool: Pool!
    sender: Bytes!
    transactionHash: Bytes!
    type: InvestType!
    user: User!
}

input AddRemove_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    amounts: [BigDecimal!]
    amounts_contains: [BigDecimal!]
    amounts_contains_nocase: [BigDecimal!]
    amounts_not: [BigDecimal!]
    amounts_not_contains: [BigDecimal!]
    amounts_not_contains_nocase: [BigDecimal!]
    and: [AddRemove_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    logIndex: BigInt
    logIndex_gt: BigInt
    logIndex_gte: BigInt
    logIndex_in: [BigInt!]
    logIndex_lt: BigInt
    logIndex_lte: BigInt
    logIndex_not: BigInt
    logIndex_not_in: [BigInt!]
    or: [AddRemove_filter]
    pool: String
    pool_: Pool_filter
    pool_contains: String
    pool_contains_nocase: String
    pool_ends_with: String
    pool_ends_with_nocase: String
    pool_gt: String
    pool_gte: String
    pool_in: [String!]
    pool_lt: String
    pool_lte: String
    pool_not: String
    pool_not_contains: String
    pool_not_contains_nocase: String
    pool_not_ends_with: String
    pool_not_ends_with_nocase: String
    pool_not_in: [String!]
    pool_not_starts_with: String
    pool_not_starts_with_nocase: String
    pool_starts_with: String
    pool_starts_with_nocase: String
    sender: Bytes
    sender_contains: Bytes
    sender_gt: Bytes
    sender_gte: Bytes
    sender_in: [Bytes!]
    sender_lt: Bytes
    sender_lte: Bytes
    sender_not: Bytes
    sender_not_contains: Bytes
    sender_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
    type: InvestType
    type_in: [InvestType!]
    type_not: InvestType
    type_not_in: [InvestType!]
    user: String
    user_: User_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
}

enum AddRemove_orderBy {
    amounts
    blockNumber
    blockTimestamp
    id
    logIndex
    pool
    pool__address
    pool__blockNumber
    pool__blockTimestamp
    pool__factory
    pool__holdersCount
    pool__id
    pool__isInitialized
    pool__name
    pool__pauseManager
    pool__pauseWindowEndTime
    pool__swapFee
    pool__swapsCount
    pool__symbol
    pool__totalShares
    pool__transactionHash
    sender
    transactionHash
    type
    user
    user__id
}

enum Aggregation_interval {
    day
    hour
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
    number_gte: Int!
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

type Buffer {
    id: Bytes!
    totalShares: BigDecimal!
    underlyingBalance: BigDecimal!
    underlyingToken: Token!
    wrappedBalance: BigDecimal!
    wrappedToken: Token!
}

type BufferShare {
    balance: BigDecimal!
    buffer: Buffer!
    id: Bytes!
    user: User!
}

input BufferShare_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [BufferShare_filter]
    balance: BigDecimal
    balance_gt: BigDecimal
    balance_gte: BigDecimal
    balance_in: [BigDecimal!]
    balance_lt: BigDecimal
    balance_lte: BigDecimal
    balance_not: BigDecimal
    balance_not_in: [BigDecimal!]
    buffer: String
    buffer_: Buffer_filter
    buffer_contains: String
    buffer_contains_nocase: String
    buffer_ends_with: String
    buffer_ends_with_nocase: String
    buffer_gt: String
    buffer_gte: String
    buffer_in: [String!]
    buffer_lt: String
    buffer_lte: String
    buffer_not: String
    buffer_not_contains: String
    buffer_not_contains_nocase: String
    buffer_not_ends_with: String
    buffer_not_ends_with_nocase: String
    buffer_not_in: [String!]
    buffer_not_starts_with: String
    buffer_not_starts_with_nocase: String
    buffer_starts_with: String
    buffer_starts_with_nocase: String
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [BufferShare_filter]
    user: String
    user_: User_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
}

enum BufferShare_orderBy {
    balance
    buffer
    buffer__id
    buffer__totalShares
    buffer__underlyingBalance
    buffer__wrappedBalance
    id
    user
    user__id
}

input Buffer_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [Buffer_filter]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [Buffer_filter]
    totalShares: BigDecimal
    totalShares_gt: BigDecimal
    totalShares_gte: BigDecimal
    totalShares_in: [BigDecimal!]
    totalShares_lt: BigDecimal
    totalShares_lte: BigDecimal
    totalShares_not: BigDecimal
    totalShares_not_in: [BigDecimal!]
    underlyingBalance: BigDecimal
    underlyingBalance_gt: BigDecimal
    underlyingBalance_gte: BigDecimal
    underlyingBalance_in: [BigDecimal!]
    underlyingBalance_lt: BigDecimal
    underlyingBalance_lte: BigDecimal
    underlyingBalance_not: BigDecimal
    underlyingBalance_not_in: [BigDecimal!]
    underlyingToken: String
    underlyingToken_: Token_filter
    underlyingToken_contains: String
    underlyingToken_contains_nocase: String
    underlyingToken_ends_with: String
    underlyingToken_ends_with_nocase: String
    underlyingToken_gt: String
    underlyingToken_gte: String
    underlyingToken_in: [String!]
    underlyingToken_lt: String
    underlyingToken_lte: String
    underlyingToken_not: String
    underlyingToken_not_contains: String
    underlyingToken_not_contains_nocase: String
    underlyingToken_not_ends_with: String
    underlyingToken_not_ends_with_nocase: String
    underlyingToken_not_in: [String!]
    underlyingToken_not_starts_with: String
    underlyingToken_not_starts_with_nocase: String
    underlyingToken_starts_with: String
    underlyingToken_starts_with_nocase: String
    wrappedBalance: BigDecimal
    wrappedBalance_gt: BigDecimal
    wrappedBalance_gte: BigDecimal
    wrappedBalance_in: [BigDecimal!]
    wrappedBalance_lt: BigDecimal
    wrappedBalance_lte: BigDecimal
    wrappedBalance_not: BigDecimal
    wrappedBalance_not_in: [BigDecimal!]
    wrappedToken: String
    wrappedToken_: Token_filter
    wrappedToken_contains: String
    wrappedToken_contains_nocase: String
    wrappedToken_ends_with: String
    wrappedToken_ends_with_nocase: String
    wrappedToken_gt: String
    wrappedToken_gte: String
    wrappedToken_in: [String!]
    wrappedToken_lt: String
    wrappedToken_lte: String
    wrappedToken_not: String
    wrappedToken_not_contains: String
    wrappedToken_not_contains_nocase: String
    wrappedToken_not_ends_with: String
    wrappedToken_not_ends_with_nocase: String
    wrappedToken_not_in: [String!]
    wrappedToken_not_starts_with: String
    wrappedToken_not_starts_with_nocase: String
    wrappedToken_starts_with: String
    wrappedToken_starts_with_nocase: String
}

enum Buffer_orderBy {
    id
    totalShares
    underlyingBalance
    underlyingToken
    underlyingToken__address
    underlyingToken__decimals
    underlyingToken__id
    underlyingToken__name
    underlyingToken__symbol
    wrappedBalance
    wrappedToken
    wrappedToken__address
    wrappedToken__decimals
    wrappedToken__id
    wrappedToken__name
    wrappedToken__symbol
}

scalar Bytes

type Hook {
    address: Bytes!
    id: Bytes!
    pools(
        first: Int = 100
        orderBy: Pool_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Pool_filter
    ): [Pool!]
}

type HookConfig {
    enableHookAdjustedAmounts: Boolean!
    hook: Hook!
    id: Bytes!
    pool: Pool!
    shouldCallAfterAddLiquidity: Boolean!
    shouldCallAfterInitialize: Boolean!
    shouldCallAfterRemoveLiquidity: Boolean!
    shouldCallAfterSwap: Boolean!
    shouldCallBeforeAddLiquidity: Boolean!
    shouldCallBeforeInitialize: Boolean!
    shouldCallBeforeRemoveLiquidity: Boolean!
    shouldCallBeforeSwap: Boolean!
    shouldCallComputeDynamicSwapFee: Boolean!
}

input HookConfig_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [HookConfig_filter]
    enableHookAdjustedAmounts: Boolean
    enableHookAdjustedAmounts_in: [Boolean!]
    enableHookAdjustedAmounts_not: Boolean
    enableHookAdjustedAmounts_not_in: [Boolean!]
    hook: String
    hook_: Hook_filter
    hook_contains: String
    hook_contains_nocase: String
    hook_ends_with: String
    hook_ends_with_nocase: String
    hook_gt: String
    hook_gte: String
    hook_in: [String!]
    hook_lt: String
    hook_lte: String
    hook_not: String
    hook_not_contains: String
    hook_not_contains_nocase: String
    hook_not_ends_with: String
    hook_not_ends_with_nocase: String
    hook_not_in: [String!]
    hook_not_starts_with: String
    hook_not_starts_with_nocase: String
    hook_starts_with: String
    hook_starts_with_nocase: String
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [HookConfig_filter]
    pool: String
    pool_: Pool_filter
    pool_contains: String
    pool_contains_nocase: String
    pool_ends_with: String
    pool_ends_with_nocase: String
    pool_gt: String
    pool_gte: String
    pool_in: [String!]
    pool_lt: String
    pool_lte: String
    pool_not: String
    pool_not_contains: String
    pool_not_contains_nocase: String
    pool_not_ends_with: String
    pool_not_ends_with_nocase: String
    pool_not_in: [String!]
    pool_not_starts_with: String
    pool_not_starts_with_nocase: String
    pool_starts_with: String
    pool_starts_with_nocase: String
    shouldCallAfterAddLiquidity: Boolean
    shouldCallAfterAddLiquidity_in: [Boolean!]
    shouldCallAfterAddLiquidity_not: Boolean
    shouldCallAfterAddLiquidity_not_in: [Boolean!]
    shouldCallAfterInitialize: Boolean
    shouldCallAfterInitialize_in: [Boolean!]
    shouldCallAfterInitialize_not: Boolean
    shouldCallAfterInitialize_not_in: [Boolean!]
    shouldCallAfterRemoveLiquidity: Boolean
    shouldCallAfterRemoveLiquidity_in: [Boolean!]
    shouldCallAfterRemoveLiquidity_not: Boolean
    shouldCallAfterRemoveLiquidity_not_in: [Boolean!]
    shouldCallAfterSwap: Boolean
    shouldCallAfterSwap_in: [Boolean!]
    shouldCallAfterSwap_not: Boolean
    shouldCallAfterSwap_not_in: [Boolean!]
    shouldCallBeforeAddLiquidity: Boolean
    shouldCallBeforeAddLiquidity_in: [Boolean!]
    shouldCallBeforeAddLiquidity_not: Boolean
    shouldCallBeforeAddLiquidity_not_in: [Boolean!]
    shouldCallBeforeInitialize: Boolean
    shouldCallBeforeInitialize_in: [Boolean!]
    shouldCallBeforeInitialize_not: Boolean
    shouldCallBeforeInitialize_not_in: [Boolean!]
    shouldCallBeforeRemoveLiquidity: Boolean
    shouldCallBeforeRemoveLiquidity_in: [Boolean!]
    shouldCallBeforeRemoveLiquidity_not: Boolean
    shouldCallBeforeRemoveLiquidity_not_in: [Boolean!]
    shouldCallBeforeSwap: Boolean
    shouldCallBeforeSwap_in: [Boolean!]
    shouldCallBeforeSwap_not: Boolean
    shouldCallBeforeSwap_not_in: [Boolean!]
    shouldCallComputeDynamicSwapFee: Boolean
    shouldCallComputeDynamicSwapFee_in: [Boolean!]
    shouldCallComputeDynamicSwapFee_not: Boolean
    shouldCallComputeDynamicSwapFee_not_in: [Boolean!]
}

enum HookConfig_orderBy {
    enableHookAdjustedAmounts
    hook
    hook__address
    hook__id
    id
    pool
    pool__address
    pool__blockNumber
    pool__blockTimestamp
    pool__factory
    pool__holdersCount
    pool__id
    pool__isInitialized
    pool__name
    pool__pauseManager
    pool__pauseWindowEndTime
    pool__swapFee
    pool__swapsCount
    pool__symbol
    pool__totalShares
    pool__transactionHash
    shouldCallAfterAddLiquidity
    shouldCallAfterInitialize
    shouldCallAfterRemoveLiquidity
    shouldCallAfterSwap
    shouldCallBeforeAddLiquidity
    shouldCallBeforeInitialize
    shouldCallBeforeRemoveLiquidity
    shouldCallBeforeSwap
    shouldCallComputeDynamicSwapFee
}

input Hook_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    address: Bytes
    address_contains: Bytes
    address_gt: Bytes
    address_gte: Bytes
    address_in: [Bytes!]
    address_lt: Bytes
    address_lte: Bytes
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    and: [Hook_filter]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [Hook_filter]
    pools_: Pool_filter
}

enum Hook_orderBy {
    address
    id
    pools
}

"""
8 bytes signed integer
"""
scalar Int8

enum InvestType {
    Add
    Remove
}

type LiquidityManagement {
    disableUnbalancedLiquidity: Boolean!
    enableAddLiquidityCustom: Boolean!
    enableDonation: Boolean!
    enableRemoveLiquidityCustom: Boolean!
    id: Bytes!
    pool: Pool!
}

input LiquidityManagement_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [LiquidityManagement_filter]
    disableUnbalancedLiquidity: Boolean
    disableUnbalancedLiquidity_in: [Boolean!]
    disableUnbalancedLiquidity_not: Boolean
    disableUnbalancedLiquidity_not_in: [Boolean!]
    enableAddLiquidityCustom: Boolean
    enableAddLiquidityCustom_in: [Boolean!]
    enableAddLiquidityCustom_not: Boolean
    enableAddLiquidityCustom_not_in: [Boolean!]
    enableDonation: Boolean
    enableDonation_in: [Boolean!]
    enableDonation_not: Boolean
    enableDonation_not_in: [Boolean!]
    enableRemoveLiquidityCustom: Boolean
    enableRemoveLiquidityCustom_in: [Boolean!]
    enableRemoveLiquidityCustom_not: Boolean
    enableRemoveLiquidityCustom_not_in: [Boolean!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [LiquidityManagement_filter]
    pool: String
    pool_: Pool_filter
    pool_contains: String
    pool_contains_nocase: String
    pool_ends_with: String
    pool_ends_with_nocase: String
    pool_gt: String
    pool_gte: String
    pool_in: [String!]
    pool_lt: String
    pool_lte: String
    pool_not: String
    pool_not_contains: String
    pool_not_contains_nocase: String
    pool_not_ends_with: String
    pool_not_ends_with_nocase: String
    pool_not_in: [String!]
    pool_not_starts_with: String
    pool_not_starts_with_nocase: String
    pool_starts_with: String
    pool_starts_with_nocase: String
}

enum LiquidityManagement_orderBy {
    disableUnbalancedLiquidity
    enableAddLiquidityCustom
    enableDonation
    enableRemoveLiquidityCustom
    id
    pool
    pool__address
    pool__blockNumber
    pool__blockTimestamp
    pool__factory
    pool__holdersCount
    pool__id
    pool__isInitialized
    pool__name
    pool__pauseManager
    pool__pauseWindowEndTime
    pool__swapFee
    pool__swapsCount
    pool__symbol
    pool__totalShares
    pool__transactionHash
}

"""
Defines the order direction, either ascending or descending
"""
enum OrderDirection {
    asc
    desc
}

type Pool {
    address: Bytes!
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    factory: Bytes!
    holdersCount: BigInt!
    hook: Hook!
    hookConfig: HookConfig!
    id: Bytes!
    isInitialized: Boolean!
    liquidityManagement: LiquidityManagement!
    name: String!
    pauseManager: Bytes!
    pauseWindowEndTime: BigInt!
    rateProviders(
        first: Int = 100
        orderBy: RateProvider_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: RateProvider_filter
    ): [RateProvider!]!
    snapshots(
        first: Int = 100
        orderBy: PoolSnapshot_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: PoolSnapshot_filter
    ): [PoolSnapshot!]!
    swapFee: BigDecimal!
    swapsCount: BigInt!
    symbol: String!
    tokens(
        first: Int = 100
        orderBy: PoolToken_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: PoolToken_filter
    ): [PoolToken!]!
    totalShares: BigDecimal!
    transactionHash: Bytes!
    vault: Vault!
}

type PoolShare {
    balance: BigDecimal!
    id: ID!
    pool: Pool!
    user: User!
}

input PoolShare_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [PoolShare_filter]
    balance: BigDecimal
    balance_gt: BigDecimal
    balance_gte: BigDecimal
    balance_in: [BigDecimal!]
    balance_lt: BigDecimal
    balance_lte: BigDecimal
    balance_not: BigDecimal
    balance_not_in: [BigDecimal!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [PoolShare_filter]
    pool: String
    pool_: Pool_filter
    pool_contains: String
    pool_contains_nocase: String
    pool_ends_with: String
    pool_ends_with_nocase: String
    pool_gt: String
    pool_gte: String
    pool_in: [String!]
    pool_lt: String
    pool_lte: String
    pool_not: String
    pool_not_contains: String
    pool_not_contains_nocase: String
    pool_not_ends_with: String
    pool_not_ends_with_nocase: String
    pool_not_in: [String!]
    pool_not_starts_with: String
    pool_not_starts_with_nocase: String
    pool_starts_with: String
    pool_starts_with_nocase: String
    user: String
    user_: User_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
}

enum PoolShare_orderBy {
    balance
    id
    pool
    pool__address
    pool__blockNumber
    pool__blockTimestamp
    pool__factory
    pool__holdersCount
    pool__id
    pool__isInitialized
    pool__name
    pool__pauseManager
    pool__pauseWindowEndTime
    pool__swapFee
    pool__swapsCount
    pool__symbol
    pool__totalShares
    pool__transactionHash
    user
    user__id
}

type PoolSnapshot {
    balances: [BigDecimal!]!
    holdersCount: BigInt!
    id: ID!
    pool: Pool!
    swapsCount: BigInt!
    timestamp: Int!
    totalProtocolSwapFees: [BigDecimal!]!
    totalProtocolYieldFees: [BigDecimal!]!
    totalShares: BigDecimal!
    totalSwapFees: [BigDecimal!]!
    totalSwapVolumes: [BigDecimal!]!
}

input PoolSnapshot_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [PoolSnapshot_filter]
    balances: [BigDecimal!]
    balances_contains: [BigDecimal!]
    balances_contains_nocase: [BigDecimal!]
    balances_not: [BigDecimal!]
    balances_not_contains: [BigDecimal!]
    balances_not_contains_nocase: [BigDecimal!]
    holdersCount: BigInt
    holdersCount_gt: BigInt
    holdersCount_gte: BigInt
    holdersCount_in: [BigInt!]
    holdersCount_lt: BigInt
    holdersCount_lte: BigInt
    holdersCount_not: BigInt
    holdersCount_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [PoolSnapshot_filter]
    pool: String
    pool_: Pool_filter
    pool_contains: String
    pool_contains_nocase: String
    pool_ends_with: String
    pool_ends_with_nocase: String
    pool_gt: String
    pool_gte: String
    pool_in: [String!]
    pool_lt: String
    pool_lte: String
    pool_not: String
    pool_not_contains: String
    pool_not_contains_nocase: String
    pool_not_ends_with: String
    pool_not_ends_with_nocase: String
    pool_not_in: [String!]
    pool_not_starts_with: String
    pool_not_starts_with_nocase: String
    pool_starts_with: String
    pool_starts_with_nocase: String
    swapsCount: BigInt
    swapsCount_gt: BigInt
    swapsCount_gte: BigInt
    swapsCount_in: [BigInt!]
    swapsCount_lt: BigInt
    swapsCount_lte: BigInt
    swapsCount_not: BigInt
    swapsCount_not_in: [BigInt!]
    timestamp: Int
    timestamp_gt: Int
    timestamp_gte: Int
    timestamp_in: [Int!]
    timestamp_lt: Int
    timestamp_lte: Int
    timestamp_not: Int
    timestamp_not_in: [Int!]
    totalProtocolSwapFees: [BigDecimal!]
    totalProtocolSwapFees_contains: [BigDecimal!]
    totalProtocolSwapFees_contains_nocase: [BigDecimal!]
    totalProtocolSwapFees_not: [BigDecimal!]
    totalProtocolSwapFees_not_contains: [BigDecimal!]
    totalProtocolSwapFees_not_contains_nocase: [BigDecimal!]
    totalProtocolYieldFees: [BigDecimal!]
    totalProtocolYieldFees_contains: [BigDecimal!]
    totalProtocolYieldFees_contains_nocase: [BigDecimal!]
    totalProtocolYieldFees_not: [BigDecimal!]
    totalProtocolYieldFees_not_contains: [BigDecimal!]
    totalProtocolYieldFees_not_contains_nocase: [BigDecimal!]
    totalShares: BigDecimal
    totalShares_gt: BigDecimal
    totalShares_gte: BigDecimal
    totalShares_in: [BigDecimal!]
    totalShares_lt: BigDecimal
    totalShares_lte: BigDecimal
    totalShares_not: BigDecimal
    totalShares_not_in: [BigDecimal!]
    totalSwapFees: [BigDecimal!]
    totalSwapFees_contains: [BigDecimal!]
    totalSwapFees_contains_nocase: [BigDecimal!]
    totalSwapFees_not: [BigDecimal!]
    totalSwapFees_not_contains: [BigDecimal!]
    totalSwapFees_not_contains_nocase: [BigDecimal!]
    totalSwapVolumes: [BigDecimal!]
    totalSwapVolumes_contains: [BigDecimal!]
    totalSwapVolumes_contains_nocase: [BigDecimal!]
    totalSwapVolumes_not: [BigDecimal!]
    totalSwapVolumes_not_contains: [BigDecimal!]
    totalSwapVolumes_not_contains_nocase: [BigDecimal!]
}

enum PoolSnapshot_orderBy {
    balances
    holdersCount
    id
    pool
    pool__address
    pool__blockNumber
    pool__blockTimestamp
    pool__factory
    pool__holdersCount
    pool__id
    pool__isInitialized
    pool__name
    pool__pauseManager
    pool__pauseWindowEndTime
    pool__swapFee
    pool__swapsCount
    pool__symbol
    pool__totalShares
    pool__transactionHash
    swapsCount
    timestamp
    totalProtocolSwapFees
    totalProtocolYieldFees
    totalShares
    totalSwapFees
    totalSwapVolumes
}

type PoolToken {
    address: Bytes!
    balance: BigDecimal!
    buffer: Buffer
    decimals: Int!
    id: Bytes!
    index: Int!
    name: String!
    nestedPool: Pool
    paysYieldFees: Boolean!
    pool: Pool!
    priceRate: BigDecimal!
    symbol: String!
    totalProtocolSwapFee: BigDecimal!
    totalProtocolYieldFee: BigDecimal!
    volume: BigDecimal!
}

input PoolToken_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    address: Bytes
    address_contains: Bytes
    address_gt: Bytes
    address_gte: Bytes
    address_in: [Bytes!]
    address_lt: Bytes
    address_lte: Bytes
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    and: [PoolToken_filter]
    balance: BigDecimal
    balance_gt: BigDecimal
    balance_gte: BigDecimal
    balance_in: [BigDecimal!]
    balance_lt: BigDecimal
    balance_lte: BigDecimal
    balance_not: BigDecimal
    balance_not_in: [BigDecimal!]
    buffer: String
    buffer_: Buffer_filter
    buffer_contains: String
    buffer_contains_nocase: String
    buffer_ends_with: String
    buffer_ends_with_nocase: String
    buffer_gt: String
    buffer_gte: String
    buffer_in: [String!]
    buffer_lt: String
    buffer_lte: String
    buffer_not: String
    buffer_not_contains: String
    buffer_not_contains_nocase: String
    buffer_not_ends_with: String
    buffer_not_ends_with_nocase: String
    buffer_not_in: [String!]
    buffer_not_starts_with: String
    buffer_not_starts_with_nocase: String
    buffer_starts_with: String
    buffer_starts_with_nocase: String
    decimals: Int
    decimals_gt: Int
    decimals_gte: Int
    decimals_in: [Int!]
    decimals_lt: Int
    decimals_lte: Int
    decimals_not: Int
    decimals_not_in: [Int!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    index: Int
    index_gt: Int
    index_gte: Int
    index_in: [Int!]
    index_lt: Int
    index_lte: Int
    index_not: Int
    index_not_in: [Int!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    nestedPool: String
    nestedPool_: Pool_filter
    nestedPool_contains: String
    nestedPool_contains_nocase: String
    nestedPool_ends_with: String
    nestedPool_ends_with_nocase: String
    nestedPool_gt: String
    nestedPool_gte: String
    nestedPool_in: [String!]
    nestedPool_lt: String
    nestedPool_lte: String
    nestedPool_not: String
    nestedPool_not_contains: String
    nestedPool_not_contains_nocase: String
    nestedPool_not_ends_with: String
    nestedPool_not_ends_with_nocase: String
    nestedPool_not_in: [String!]
    nestedPool_not_starts_with: String
    nestedPool_not_starts_with_nocase: String
    nestedPool_starts_with: String
    nestedPool_starts_with_nocase: String
    or: [PoolToken_filter]
    paysYieldFees: Boolean
    paysYieldFees_in: [Boolean!]
    paysYieldFees_not: Boolean
    paysYieldFees_not_in: [Boolean!]
    pool: String
    pool_: Pool_filter
    pool_contains: String
    pool_contains_nocase: String
    pool_ends_with: String
    pool_ends_with_nocase: String
    pool_gt: String
    pool_gte: String
    pool_in: [String!]
    pool_lt: String
    pool_lte: String
    pool_not: String
    pool_not_contains: String
    pool_not_contains_nocase: String
    pool_not_ends_with: String
    pool_not_ends_with_nocase: String
    pool_not_in: [String!]
    pool_not_starts_with: String
    pool_not_starts_with_nocase: String
    pool_starts_with: String
    pool_starts_with_nocase: String
    priceRate: BigDecimal
    priceRate_gt: BigDecimal
    priceRate_gte: BigDecimal
    priceRate_in: [BigDecimal!]
    priceRate_lt: BigDecimal
    priceRate_lte: BigDecimal
    priceRate_not: BigDecimal
    priceRate_not_in: [BigDecimal!]
    symbol: String
    symbol_contains: String
    symbol_contains_nocase: String
    symbol_ends_with: String
    symbol_ends_with_nocase: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_contains_nocase: String
    symbol_not_ends_with: String
    symbol_not_ends_with_nocase: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_not_starts_with_nocase: String
    symbol_starts_with: String
    symbol_starts_with_nocase: String
    totalProtocolSwapFee: BigDecimal
    totalProtocolSwapFee_gt: BigDecimal
    totalProtocolSwapFee_gte: BigDecimal
    totalProtocolSwapFee_in: [BigDecimal!]
    totalProtocolSwapFee_lt: BigDecimal
    totalProtocolSwapFee_lte: BigDecimal
    totalProtocolSwapFee_not: BigDecimal
    totalProtocolSwapFee_not_in: [BigDecimal!]
    totalProtocolYieldFee: BigDecimal
    totalProtocolYieldFee_gt: BigDecimal
    totalProtocolYieldFee_gte: BigDecimal
    totalProtocolYieldFee_in: [BigDecimal!]
    totalProtocolYieldFee_lt: BigDecimal
    totalProtocolYieldFee_lte: BigDecimal
    totalProtocolYieldFee_not: BigDecimal
    totalProtocolYieldFee_not_in: [BigDecimal!]
    volume: BigDecimal
    volume_gt: BigDecimal
    volume_gte: BigDecimal
    volume_in: [BigDecimal!]
    volume_lt: BigDecimal
    volume_lte: BigDecimal
    volume_not: BigDecimal
    volume_not_in: [BigDecimal!]
}

enum PoolToken_orderBy {
    address
    balance
    buffer
    buffer__id
    buffer__totalShares
    buffer__underlyingBalance
    buffer__wrappedBalance
    decimals
    id
    index
    name
    nestedPool
    nestedPool__address
    nestedPool__blockNumber
    nestedPool__blockTimestamp
    nestedPool__factory
    nestedPool__holdersCount
    nestedPool__id
    nestedPool__isInitialized
    nestedPool__name
    nestedPool__pauseManager
    nestedPool__pauseWindowEndTime
    nestedPool__swapFee
    nestedPool__swapsCount
    nestedPool__symbol
    nestedPool__totalShares
    nestedPool__transactionHash
    paysYieldFees
    pool
    pool__address
    pool__blockNumber
    pool__blockTimestamp
    pool__factory
    pool__holdersCount
    pool__id
    pool__isInitialized
    pool__name
    pool__pauseManager
    pool__pauseWindowEndTime
    pool__swapFee
    pool__swapsCount
    pool__symbol
    pool__totalShares
    pool__transactionHash
    priceRate
    symbol
    totalProtocolSwapFee
    totalProtocolYieldFee
    volume
}

input Pool_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    address: Bytes
    address_contains: Bytes
    address_gt: Bytes
    address_gte: Bytes
    address_in: [Bytes!]
    address_lt: Bytes
    address_lte: Bytes
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    and: [Pool_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    factory: Bytes
    factory_contains: Bytes
    factory_gt: Bytes
    factory_gte: Bytes
    factory_in: [Bytes!]
    factory_lt: Bytes
    factory_lte: Bytes
    factory_not: Bytes
    factory_not_contains: Bytes
    factory_not_in: [Bytes!]
    holdersCount: BigInt
    holdersCount_gt: BigInt
    holdersCount_gte: BigInt
    holdersCount_in: [BigInt!]
    holdersCount_lt: BigInt
    holdersCount_lte: BigInt
    holdersCount_not: BigInt
    holdersCount_not_in: [BigInt!]
    hook: String
    hookConfig: String
    hookConfig_: HookConfig_filter
    hookConfig_contains: String
    hookConfig_contains_nocase: String
    hookConfig_ends_with: String
    hookConfig_ends_with_nocase: String
    hookConfig_gt: String
    hookConfig_gte: String
    hookConfig_in: [String!]
    hookConfig_lt: String
    hookConfig_lte: String
    hookConfig_not: String
    hookConfig_not_contains: String
    hookConfig_not_contains_nocase: String
    hookConfig_not_ends_with: String
    hookConfig_not_ends_with_nocase: String
    hookConfig_not_in: [String!]
    hookConfig_not_starts_with: String
    hookConfig_not_starts_with_nocase: String
    hookConfig_starts_with: String
    hookConfig_starts_with_nocase: String
    hook_: Hook_filter
    hook_contains: String
    hook_contains_nocase: String
    hook_ends_with: String
    hook_ends_with_nocase: String
    hook_gt: String
    hook_gte: String
    hook_in: [String!]
    hook_lt: String
    hook_lte: String
    hook_not: String
    hook_not_contains: String
    hook_not_contains_nocase: String
    hook_not_ends_with: String
    hook_not_ends_with_nocase: String
    hook_not_in: [String!]
    hook_not_starts_with: String
    hook_not_starts_with_nocase: String
    hook_starts_with: String
    hook_starts_with_nocase: String
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    isInitialized: Boolean
    isInitialized_in: [Boolean!]
    isInitialized_not: Boolean
    isInitialized_not_in: [Boolean!]
    liquidityManagement: String
    liquidityManagement_: LiquidityManagement_filter
    liquidityManagement_contains: String
    liquidityManagement_contains_nocase: String
    liquidityManagement_ends_with: String
    liquidityManagement_ends_with_nocase: String
    liquidityManagement_gt: String
    liquidityManagement_gte: String
    liquidityManagement_in: [String!]
    liquidityManagement_lt: String
    liquidityManagement_lte: String
    liquidityManagement_not: String
    liquidityManagement_not_contains: String
    liquidityManagement_not_contains_nocase: String
    liquidityManagement_not_ends_with: String
    liquidityManagement_not_ends_with_nocase: String
    liquidityManagement_not_in: [String!]
    liquidityManagement_not_starts_with: String
    liquidityManagement_not_starts_with_nocase: String
    liquidityManagement_starts_with: String
    liquidityManagement_starts_with_nocase: String
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    or: [Pool_filter]
    pauseManager: Bytes
    pauseManager_contains: Bytes
    pauseManager_gt: Bytes
    pauseManager_gte: Bytes
    pauseManager_in: [Bytes!]
    pauseManager_lt: Bytes
    pauseManager_lte: Bytes
    pauseManager_not: Bytes
    pauseManager_not_contains: Bytes
    pauseManager_not_in: [Bytes!]
    pauseWindowEndTime: BigInt
    pauseWindowEndTime_gt: BigInt
    pauseWindowEndTime_gte: BigInt
    pauseWindowEndTime_in: [BigInt!]
    pauseWindowEndTime_lt: BigInt
    pauseWindowEndTime_lte: BigInt
    pauseWindowEndTime_not: BigInt
    pauseWindowEndTime_not_in: [BigInt!]
    rateProviders_: RateProvider_filter
    snapshots_: PoolSnapshot_filter
    swapFee: BigDecimal
    swapFee_gt: BigDecimal
    swapFee_gte: BigDecimal
    swapFee_in: [BigDecimal!]
    swapFee_lt: BigDecimal
    swapFee_lte: BigDecimal
    swapFee_not: BigDecimal
    swapFee_not_in: [BigDecimal!]
    swapsCount: BigInt
    swapsCount_gt: BigInt
    swapsCount_gte: BigInt
    swapsCount_in: [BigInt!]
    swapsCount_lt: BigInt
    swapsCount_lte: BigInt
    swapsCount_not: BigInt
    swapsCount_not_in: [BigInt!]
    symbol: String
    symbol_contains: String
    symbol_contains_nocase: String
    symbol_ends_with: String
    symbol_ends_with_nocase: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_contains_nocase: String
    symbol_not_ends_with: String
    symbol_not_ends_with_nocase: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_not_starts_with_nocase: String
    symbol_starts_with: String
    symbol_starts_with_nocase: String
    tokens_: PoolToken_filter
    totalShares: BigDecimal
    totalShares_gt: BigDecimal
    totalShares_gte: BigDecimal
    totalShares_in: [BigDecimal!]
    totalShares_lt: BigDecimal
    totalShares_lte: BigDecimal
    totalShares_not: BigDecimal
    totalShares_not_in: [BigDecimal!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
    vault: String
    vault_: Vault_filter
    vault_contains: String
    vault_contains_nocase: String
    vault_ends_with: String
    vault_ends_with_nocase: String
    vault_gt: String
    vault_gte: String
    vault_in: [String!]
    vault_lt: String
    vault_lte: String
    vault_not: String
    vault_not_contains: String
    vault_not_contains_nocase: String
    vault_not_ends_with: String
    vault_not_ends_with_nocase: String
    vault_not_in: [String!]
    vault_not_starts_with: String
    vault_not_starts_with_nocase: String
    vault_starts_with: String
    vault_starts_with_nocase: String
}

enum Pool_orderBy {
    address
    blockNumber
    blockTimestamp
    factory
    holdersCount
    hook
    hookConfig
    hookConfig__enableHookAdjustedAmounts
    hookConfig__id
    hookConfig__shouldCallAfterAddLiquidity
    hookConfig__shouldCallAfterInitialize
    hookConfig__shouldCallAfterRemoveLiquidity
    hookConfig__shouldCallAfterSwap
    hookConfig__shouldCallBeforeAddLiquidity
    hookConfig__shouldCallBeforeInitialize
    hookConfig__shouldCallBeforeRemoveLiquidity
    hookConfig__shouldCallBeforeSwap
    hookConfig__shouldCallComputeDynamicSwapFee
    hook__address
    hook__id
    id
    isInitialized
    liquidityManagement
    liquidityManagement__disableUnbalancedLiquidity
    liquidityManagement__enableAddLiquidityCustom
    liquidityManagement__enableDonation
    liquidityManagement__enableRemoveLiquidityCustom
    liquidityManagement__id
    name
    pauseManager
    pauseWindowEndTime
    rateProviders
    snapshots
    swapFee
    swapsCount
    symbol
    tokens
    totalShares
    transactionHash
    vault
    vault__authorizer
    vault__id
    vault__isPaused
    vault__protocolSwapFee
    vault__protocolYieldFee
}

type Query {
    """
    Access to subgraph metadata
    """
    _meta(block: Block_height): _Meta_
    addRemove(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AddRemove
    addRemoves(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: AddRemove_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: AddRemove_filter
    ): [AddRemove!]!
    buffer(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Buffer
    bufferShare(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): BufferShare
    bufferShares(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: BufferShare_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: BufferShare_filter
    ): [BufferShare!]!
    buffers(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Buffer_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Buffer_filter
    ): [Buffer!]!
    hook(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Hook
    hookConfig(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HookConfig
    hookConfigs(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: HookConfig_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: HookConfig_filter
    ): [HookConfig!]!
    hooks(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Hook_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Hook_filter
    ): [Hook!]!
    liquidityManagement(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): LiquidityManagement
    liquidityManagements(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: LiquidityManagement_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: LiquidityManagement_filter
    ): [LiquidityManagement!]!
    pool(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Pool
    poolShare(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PoolShare
    poolShares(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: PoolShare_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: PoolShare_filter
    ): [PoolShare!]!
    poolSnapshot(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PoolSnapshot
    poolSnapshots(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: PoolSnapshot_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: PoolSnapshot_filter
    ): [PoolSnapshot!]!
    poolToken(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PoolToken
    poolTokens(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: PoolToken_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: PoolToken_filter
    ): [PoolToken!]!
    pools(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Pool_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Pool_filter
    ): [Pool!]!
    rateProvider(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RateProvider
    rateProviders(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: RateProvider_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: RateProvider_filter
    ): [RateProvider!]!
    swap(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Swap
    swaps(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Swap_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Swap_filter
    ): [Swap!]!
    token(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Token
    tokens(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Token_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Token_filter
    ): [Token!]!
    user(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): User
    users(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: User_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: User_filter
    ): [User!]!
    vault(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Vault
    vaults(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Vault_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Vault_filter
    ): [Vault!]!
}

type RateProvider {
    address: Bytes!
    id: Bytes!
    pool: Pool!
    token: PoolToken!
}

input RateProvider_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    address: Bytes
    address_contains: Bytes
    address_gt: Bytes
    address_gte: Bytes
    address_in: [Bytes!]
    address_lt: Bytes
    address_lte: Bytes
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    and: [RateProvider_filter]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [RateProvider_filter]
    pool: String
    pool_: Pool_filter
    pool_contains: String
    pool_contains_nocase: String
    pool_ends_with: String
    pool_ends_with_nocase: String
    pool_gt: String
    pool_gte: String
    pool_in: [String!]
    pool_lt: String
    pool_lte: String
    pool_not: String
    pool_not_contains: String
    pool_not_contains_nocase: String
    pool_not_ends_with: String
    pool_not_ends_with_nocase: String
    pool_not_in: [String!]
    pool_not_starts_with: String
    pool_not_starts_with_nocase: String
    pool_starts_with: String
    pool_starts_with_nocase: String
    token: String
    token_: PoolToken_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
}

enum RateProvider_orderBy {
    address
    id
    pool
    pool__address
    pool__blockNumber
    pool__blockTimestamp
    pool__factory
    pool__holdersCount
    pool__id
    pool__isInitialized
    pool__name
    pool__pauseManager
    pool__pauseWindowEndTime
    pool__swapFee
    pool__swapsCount
    pool__symbol
    pool__totalShares
    pool__transactionHash
    token
    token__address
    token__balance
    token__decimals
    token__id
    token__index
    token__name
    token__paysYieldFees
    token__priceRate
    token__symbol
    token__totalProtocolSwapFee
    token__totalProtocolYieldFee
    token__volume
}

type Subscription {
    """
    Access to subgraph metadata
    """
    _meta(block: Block_height): _Meta_
    addRemove(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AddRemove
    addRemoves(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: AddRemove_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: AddRemove_filter
    ): [AddRemove!]!
    buffer(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Buffer
    bufferShare(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): BufferShare
    bufferShares(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: BufferShare_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: BufferShare_filter
    ): [BufferShare!]!
    buffers(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Buffer_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Buffer_filter
    ): [Buffer!]!
    hook(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Hook
    hookConfig(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HookConfig
    hookConfigs(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: HookConfig_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: HookConfig_filter
    ): [HookConfig!]!
    hooks(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Hook_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Hook_filter
    ): [Hook!]!
    liquidityManagement(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): LiquidityManagement
    liquidityManagements(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: LiquidityManagement_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: LiquidityManagement_filter
    ): [LiquidityManagement!]!
    pool(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Pool
    poolShare(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PoolShare
    poolShares(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: PoolShare_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: PoolShare_filter
    ): [PoolShare!]!
    poolSnapshot(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PoolSnapshot
    poolSnapshots(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: PoolSnapshot_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: PoolSnapshot_filter
    ): [PoolSnapshot!]!
    poolToken(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PoolToken
    poolTokens(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: PoolToken_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: PoolToken_filter
    ): [PoolToken!]!
    pools(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Pool_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Pool_filter
    ): [Pool!]!
    rateProvider(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RateProvider
    rateProviders(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: RateProvider_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: RateProvider_filter
    ): [RateProvider!]!
    swap(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Swap
    swaps(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Swap_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Swap_filter
    ): [Swap!]!
    token(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Token
    tokens(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Token_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Token_filter
    ): [Token!]!
    user(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): User
    users(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: User_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: User_filter
    ): [User!]!
    vault(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Vault
    vaults(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Vault_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Vault_filter
    ): [Vault!]!
}

type Swap {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    logIndex: BigInt!
    pool: Bytes!
    swapFeeAmount: BigDecimal!
    swapFeeToken: Bytes!
    tokenAmountIn: BigDecimal!
    tokenAmountOut: BigDecimal!
    tokenIn: Bytes!
    tokenInSymbol: String!
    tokenOut: Bytes!
    tokenOutSymbol: String!
    transactionHash: Bytes!
    user: User!
}

input Swap_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [Swap_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    logIndex: BigInt
    logIndex_gt: BigInt
    logIndex_gte: BigInt
    logIndex_in: [BigInt!]
    logIndex_lt: BigInt
    logIndex_lte: BigInt
    logIndex_not: BigInt
    logIndex_not_in: [BigInt!]
    or: [Swap_filter]
    pool: Bytes
    pool_contains: Bytes
    pool_gt: Bytes
    pool_gte: Bytes
    pool_in: [Bytes!]
    pool_lt: Bytes
    pool_lte: Bytes
    pool_not: Bytes
    pool_not_contains: Bytes
    pool_not_in: [Bytes!]
    swapFeeAmount: BigDecimal
    swapFeeAmount_gt: BigDecimal
    swapFeeAmount_gte: BigDecimal
    swapFeeAmount_in: [BigDecimal!]
    swapFeeAmount_lt: BigDecimal
    swapFeeAmount_lte: BigDecimal
    swapFeeAmount_not: BigDecimal
    swapFeeAmount_not_in: [BigDecimal!]
    swapFeeToken: Bytes
    swapFeeToken_contains: Bytes
    swapFeeToken_gt: Bytes
    swapFeeToken_gte: Bytes
    swapFeeToken_in: [Bytes!]
    swapFeeToken_lt: Bytes
    swapFeeToken_lte: Bytes
    swapFeeToken_not: Bytes
    swapFeeToken_not_contains: Bytes
    swapFeeToken_not_in: [Bytes!]
    tokenAmountIn: BigDecimal
    tokenAmountIn_gt: BigDecimal
    tokenAmountIn_gte: BigDecimal
    tokenAmountIn_in: [BigDecimal!]
    tokenAmountIn_lt: BigDecimal
    tokenAmountIn_lte: BigDecimal
    tokenAmountIn_not: BigDecimal
    tokenAmountIn_not_in: [BigDecimal!]
    tokenAmountOut: BigDecimal
    tokenAmountOut_gt: BigDecimal
    tokenAmountOut_gte: BigDecimal
    tokenAmountOut_in: [BigDecimal!]
    tokenAmountOut_lt: BigDecimal
    tokenAmountOut_lte: BigDecimal
    tokenAmountOut_not: BigDecimal
    tokenAmountOut_not_in: [BigDecimal!]
    tokenIn: Bytes
    tokenInSymbol: String
    tokenInSymbol_contains: String
    tokenInSymbol_contains_nocase: String
    tokenInSymbol_ends_with: String
    tokenInSymbol_ends_with_nocase: String
    tokenInSymbol_gt: String
    tokenInSymbol_gte: String
    tokenInSymbol_in: [String!]
    tokenInSymbol_lt: String
    tokenInSymbol_lte: String
    tokenInSymbol_not: String
    tokenInSymbol_not_contains: String
    tokenInSymbol_not_contains_nocase: String
    tokenInSymbol_not_ends_with: String
    tokenInSymbol_not_ends_with_nocase: String
    tokenInSymbol_not_in: [String!]
    tokenInSymbol_not_starts_with: String
    tokenInSymbol_not_starts_with_nocase: String
    tokenInSymbol_starts_with: String
    tokenInSymbol_starts_with_nocase: String
    tokenIn_contains: Bytes
    tokenIn_gt: Bytes
    tokenIn_gte: Bytes
    tokenIn_in: [Bytes!]
    tokenIn_lt: Bytes
    tokenIn_lte: Bytes
    tokenIn_not: Bytes
    tokenIn_not_contains: Bytes
    tokenIn_not_in: [Bytes!]
    tokenOut: Bytes
    tokenOutSymbol: String
    tokenOutSymbol_contains: String
    tokenOutSymbol_contains_nocase: String
    tokenOutSymbol_ends_with: String
    tokenOutSymbol_ends_with_nocase: String
    tokenOutSymbol_gt: String
    tokenOutSymbol_gte: String
    tokenOutSymbol_in: [String!]
    tokenOutSymbol_lt: String
    tokenOutSymbol_lte: String
    tokenOutSymbol_not: String
    tokenOutSymbol_not_contains: String
    tokenOutSymbol_not_contains_nocase: String
    tokenOutSymbol_not_ends_with: String
    tokenOutSymbol_not_ends_with_nocase: String
    tokenOutSymbol_not_in: [String!]
    tokenOutSymbol_not_starts_with: String
    tokenOutSymbol_not_starts_with_nocase: String
    tokenOutSymbol_starts_with: String
    tokenOutSymbol_starts_with_nocase: String
    tokenOut_contains: Bytes
    tokenOut_gt: Bytes
    tokenOut_gte: Bytes
    tokenOut_in: [Bytes!]
    tokenOut_lt: Bytes
    tokenOut_lte: Bytes
    tokenOut_not: Bytes
    tokenOut_not_contains: Bytes
    tokenOut_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
    user: String
    user_: User_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
}

enum Swap_orderBy {
    blockNumber
    blockTimestamp
    id
    logIndex
    pool
    swapFeeAmount
    swapFeeToken
    tokenAmountIn
    tokenAmountOut
    tokenIn
    tokenInSymbol
    tokenOut
    tokenOutSymbol
    transactionHash
    user
    user__id
}

"""
A string representation of microseconds UNIX timestamp (16 digits)
"""
scalar Timestamp

type Token {
    address: Bytes!
    decimals: Int!
    id: Bytes!
    name: String!
    symbol: String!
}

input Token_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    address: Bytes
    address_contains: Bytes
    address_gt: Bytes
    address_gte: Bytes
    address_in: [Bytes!]
    address_lt: Bytes
    address_lte: Bytes
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    and: [Token_filter]
    decimals: Int
    decimals_gt: Int
    decimals_gte: Int
    decimals_in: [Int!]
    decimals_lt: Int
    decimals_lte: Int
    decimals_not: Int
    decimals_not_in: [Int!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    or: [Token_filter]
    symbol: String
    symbol_contains: String
    symbol_contains_nocase: String
    symbol_ends_with: String
    symbol_ends_with_nocase: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_contains_nocase: String
    symbol_not_ends_with: String
    symbol_not_ends_with_nocase: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_not_starts_with_nocase: String
    symbol_starts_with: String
    symbol_starts_with_nocase: String
}

enum Token_orderBy {
    address
    decimals
    id
    name
    symbol
}

type User {
    addRemoves(
        first: Int = 100
        orderBy: AddRemove_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: AddRemove_filter
    ): [AddRemove!]
    id: Bytes!
    shares(
        first: Int = 100
        orderBy: PoolShare_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: PoolShare_filter
    ): [PoolShare!]
    swaps(
        first: Int = 100
        orderBy: Swap_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Swap_filter
    ): [Swap!]
}

input User_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    addRemoves_: AddRemove_filter
    and: [User_filter]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [User_filter]
    shares_: PoolShare_filter
    swaps_: Swap_filter
}

enum User_orderBy {
    addRemoves
    id
    shares
    swaps
}

type Vault {
    authorizer: Bytes!
    id: Bytes!
    isPaused: Boolean!
    pools(
        first: Int = 100
        orderBy: Pool_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Pool_filter
    ): [Pool!]
    protocolSwapFee: BigDecimal!
    protocolYieldFee: BigDecimal!
}

input Vault_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [Vault_filter]
    authorizer: Bytes
    authorizer_contains: Bytes
    authorizer_gt: Bytes
    authorizer_gte: Bytes
    authorizer_in: [Bytes!]
    authorizer_lt: Bytes
    authorizer_lte: Bytes
    authorizer_not: Bytes
    authorizer_not_contains: Bytes
    authorizer_not_in: [Bytes!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    isPaused: Boolean
    isPaused_in: [Boolean!]
    isPaused_not: Boolean
    isPaused_not_in: [Boolean!]
    or: [Vault_filter]
    pools_: Pool_filter
    protocolSwapFee: BigDecimal
    protocolSwapFee_gt: BigDecimal
    protocolSwapFee_gte: BigDecimal
    protocolSwapFee_in: [BigDecimal!]
    protocolSwapFee_lt: BigDecimal
    protocolSwapFee_lte: BigDecimal
    protocolSwapFee_not: BigDecimal
    protocolSwapFee_not_in: [BigDecimal!]
    protocolYieldFee: BigDecimal
    protocolYieldFee_gt: BigDecimal
    protocolYieldFee_gte: BigDecimal
    protocolYieldFee_in: [BigDecimal!]
    protocolYieldFee_lt: BigDecimal
    protocolYieldFee_lte: BigDecimal
    protocolYieldFee_not: BigDecimal
    protocolYieldFee_not_in: [BigDecimal!]
}

enum Vault_orderBy {
    authorizer
    id
    isPaused
    pools
    protocolSwapFee
    protocolYieldFee
}

type _Block_ {
    """
    The hash of the block
    """
    hash: Bytes

    """
    The block number
    """
    number: Int!

    """
    The hash of the parent block
    """
    parentHash: Bytes

    """
    Integer representation of the timestamp stored in blocks for the chain
    """
    timestamp: Int
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
    """
    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!

    """
    The deployment ID
    """
    deployment: String!

    """
    If `true`, the subgraph encountered indexing errors at some past block
    """
    hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
    """
    Data will be returned even if the subgraph has indexing errors
    """
    allow

    """
    If the subgraph has indexing errors, data will be omitted. The default.
    """
    deny
}
