"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""
Defined a Subgraph ID for an object type
"""
directive @subgraphId(id: String!) on OBJECT

type AddRemove {
    amounts: [BigDecimal!]!
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    logIndex: BigInt!
    pool: Pool!
    sender: Bytes!
    transactionHash: Bytes!
    type: InvestType!
    user: User!
}

input AddRemove_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    amounts: [BigDecimal!]
    amounts_contains: [BigDecimal!]
    amounts_contains_nocase: [BigDecimal!]
    amounts_not: [BigDecimal!]
    amounts_not_contains: [BigDecimal!]
    amounts_not_contains_nocase: [BigDecimal!]
    and: [AddRemove_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    logIndex: BigInt
    logIndex_gt: BigInt
    logIndex_gte: BigInt
    logIndex_in: [BigInt!]
    logIndex_lt: BigInt
    logIndex_lte: BigInt
    logIndex_not: BigInt
    logIndex_not_in: [BigInt!]
    or: [AddRemove_filter]
    pool: String
    pool_: Pool_filter
    pool_contains: String
    pool_contains_nocase: String
    pool_ends_with: String
    pool_ends_with_nocase: String
    pool_gt: String
    pool_gte: String
    pool_in: [String!]
    pool_lt: String
    pool_lte: String
    pool_not: String
    pool_not_contains: String
    pool_not_contains_nocase: String
    pool_not_ends_with: String
    pool_not_ends_with_nocase: String
    pool_not_in: [String!]
    pool_not_starts_with: String
    pool_not_starts_with_nocase: String
    pool_starts_with: String
    pool_starts_with_nocase: String
    sender: Bytes
    sender_contains: Bytes
    sender_gt: Bytes
    sender_gte: Bytes
    sender_in: [Bytes!]
    sender_lt: Bytes
    sender_lte: Bytes
    sender_not: Bytes
    sender_not_contains: Bytes
    sender_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
    type: InvestType
    type_in: [InvestType!]
    type_not: InvestType
    type_not_in: [InvestType!]
    user: String
    user_: User_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
}

enum AddRemove_orderBy {
    amounts
    blockNumber
    blockTimestamp
    id
    logIndex
    pool
    pool__address
    pool__blockNumber
    pool__blockTimestamp
    pool__holdersCount
    pool__id
    pool__isInitialized
    pool__name
    pool__swapFee
    pool__swapsCount
    pool__symbol
    pool__totalShares
    pool__transactionHash
    sender
    transactionHash
    type
    user
    user__id
}

enum Aggregation_interval {
    day
    hour
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
    number_gte: Int!
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

scalar Bytes

type Factory {
    id: Bytes!
    pools(
        first: Int = 100
        orderBy: Pool_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Pool_filter
    ): [Pool!]
}

input Factory_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [Factory_filter]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [Factory_filter]
    pools_: Pool_filter
}

enum Factory_orderBy {
    id
    pools
}

"""
8 bytes signed integer
"""
scalar Int8

enum InvestType {
    Add
    Remove
}

"""
Defines the order direction, either ascending or descending
"""
enum OrderDirection {
    asc
    desc
}

type Pool {
    address: Bytes!
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    factory: Factory!
    holdersCount: BigInt!
    id: Bytes!
    isInitialized: Boolean!
    name: String!
    snapshots(
        first: Int = 100
        orderBy: PoolSnapshot_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: PoolSnapshot_filter
    ): [PoolSnapshot!]!
    swapFee: BigDecimal!
    swaps(
        first: Int = 100
        orderBy: Swap_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Swap_filter
    ): [Swap!]!
    swapsCount: BigInt!
    symbol: String!
    tokens(
        first: Int = 100
        orderBy: PoolToken_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: PoolToken_filter
    ): [PoolToken!]!
    totalShares: BigDecimal!
    transactionHash: Bytes!
    weights: [BigDecimal!]!
}

type PoolShare {
    balance: BigDecimal!
    id: Bytes!
    pool: Pool!
    user: User!
}

input PoolShare_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [PoolShare_filter]
    balance: BigDecimal
    balance_gt: BigDecimal
    balance_gte: BigDecimal
    balance_in: [BigDecimal!]
    balance_lt: BigDecimal
    balance_lte: BigDecimal
    balance_not: BigDecimal
    balance_not_in: [BigDecimal!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [PoolShare_filter]
    pool: String
    pool_: Pool_filter
    pool_contains: String
    pool_contains_nocase: String
    pool_ends_with: String
    pool_ends_with_nocase: String
    pool_gt: String
    pool_gte: String
    pool_in: [String!]
    pool_lt: String
    pool_lte: String
    pool_not: String
    pool_not_contains: String
    pool_not_contains_nocase: String
    pool_not_ends_with: String
    pool_not_ends_with_nocase: String
    pool_not_in: [String!]
    pool_not_starts_with: String
    pool_not_starts_with_nocase: String
    pool_starts_with: String
    pool_starts_with_nocase: String
    user: String
    user_: User_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
}

enum PoolShare_orderBy {
    balance
    id
    pool
    pool__address
    pool__blockNumber
    pool__blockTimestamp
    pool__holdersCount
    pool__id
    pool__isInitialized
    pool__name
    pool__swapFee
    pool__swapsCount
    pool__symbol
    pool__totalShares
    pool__transactionHash
    user
    user__id
}

type PoolSnapshot {
    balances: [BigDecimal!]!
    holdersCount: BigInt!
    id: Bytes!
    pool: Pool!
    swapsCount: BigInt!
    timestamp: Int!
    totalShares: BigDecimal!
    totalSurpluses: [BigDecimal!]!
    totalSwapFees: [BigDecimal!]!
    totalSwapVolumes: [BigDecimal!]!
}

input PoolSnapshot_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [PoolSnapshot_filter]
    balances: [BigDecimal!]
    balances_contains: [BigDecimal!]
    balances_contains_nocase: [BigDecimal!]
    balances_not: [BigDecimal!]
    balances_not_contains: [BigDecimal!]
    balances_not_contains_nocase: [BigDecimal!]
    holdersCount: BigInt
    holdersCount_gt: BigInt
    holdersCount_gte: BigInt
    holdersCount_in: [BigInt!]
    holdersCount_lt: BigInt
    holdersCount_lte: BigInt
    holdersCount_not: BigInt
    holdersCount_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [PoolSnapshot_filter]
    pool: String
    pool_: Pool_filter
    pool_contains: String
    pool_contains_nocase: String
    pool_ends_with: String
    pool_ends_with_nocase: String
    pool_gt: String
    pool_gte: String
    pool_in: [String!]
    pool_lt: String
    pool_lte: String
    pool_not: String
    pool_not_contains: String
    pool_not_contains_nocase: String
    pool_not_ends_with: String
    pool_not_ends_with_nocase: String
    pool_not_in: [String!]
    pool_not_starts_with: String
    pool_not_starts_with_nocase: String
    pool_starts_with: String
    pool_starts_with_nocase: String
    swapsCount: BigInt
    swapsCount_gt: BigInt
    swapsCount_gte: BigInt
    swapsCount_in: [BigInt!]
    swapsCount_lt: BigInt
    swapsCount_lte: BigInt
    swapsCount_not: BigInt
    swapsCount_not_in: [BigInt!]
    timestamp: Int
    timestamp_gt: Int
    timestamp_gte: Int
    timestamp_in: [Int!]
    timestamp_lt: Int
    timestamp_lte: Int
    timestamp_not: Int
    timestamp_not_in: [Int!]
    totalShares: BigDecimal
    totalShares_gt: BigDecimal
    totalShares_gte: BigDecimal
    totalShares_in: [BigDecimal!]
    totalShares_lt: BigDecimal
    totalShares_lte: BigDecimal
    totalShares_not: BigDecimal
    totalShares_not_in: [BigDecimal!]
    totalSurpluses: [BigDecimal!]
    totalSurpluses_contains: [BigDecimal!]
    totalSurpluses_contains_nocase: [BigDecimal!]
    totalSurpluses_not: [BigDecimal!]
    totalSurpluses_not_contains: [BigDecimal!]
    totalSurpluses_not_contains_nocase: [BigDecimal!]
    totalSwapFees: [BigDecimal!]
    totalSwapFees_contains: [BigDecimal!]
    totalSwapFees_contains_nocase: [BigDecimal!]
    totalSwapFees_not: [BigDecimal!]
    totalSwapFees_not_contains: [BigDecimal!]
    totalSwapFees_not_contains_nocase: [BigDecimal!]
    totalSwapVolumes: [BigDecimal!]
    totalSwapVolumes_contains: [BigDecimal!]
    totalSwapVolumes_contains_nocase: [BigDecimal!]
    totalSwapVolumes_not: [BigDecimal!]
    totalSwapVolumes_not_contains: [BigDecimal!]
    totalSwapVolumes_not_contains_nocase: [BigDecimal!]
}

enum PoolSnapshot_orderBy {
    balances
    holdersCount
    id
    pool
    pool__address
    pool__blockNumber
    pool__blockTimestamp
    pool__holdersCount
    pool__id
    pool__isInitialized
    pool__name
    pool__swapFee
    pool__swapsCount
    pool__symbol
    pool__totalShares
    pool__transactionHash
    swapsCount
    timestamp
    totalShares
    totalSurpluses
    totalSwapFees
    totalSwapVolumes
}

type PoolToken {
    address: Bytes!
    balance: BigDecimal!
    decimals: Int!
    id: Bytes!
    index: Int!
    name: String!
    pool: Pool!
    surplus: BigDecimal!
    swapFee: BigDecimal!
    symbol: String!
    token: Token!
    volume: BigDecimal!
    weight: BigDecimal!
}

input PoolToken_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    address: Bytes
    address_contains: Bytes
    address_gt: Bytes
    address_gte: Bytes
    address_in: [Bytes!]
    address_lt: Bytes
    address_lte: Bytes
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    and: [PoolToken_filter]
    balance: BigDecimal
    balance_gt: BigDecimal
    balance_gte: BigDecimal
    balance_in: [BigDecimal!]
    balance_lt: BigDecimal
    balance_lte: BigDecimal
    balance_not: BigDecimal
    balance_not_in: [BigDecimal!]
    decimals: Int
    decimals_gt: Int
    decimals_gte: Int
    decimals_in: [Int!]
    decimals_lt: Int
    decimals_lte: Int
    decimals_not: Int
    decimals_not_in: [Int!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    index: Int
    index_gt: Int
    index_gte: Int
    index_in: [Int!]
    index_lt: Int
    index_lte: Int
    index_not: Int
    index_not_in: [Int!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    or: [PoolToken_filter]
    pool: String
    pool_: Pool_filter
    pool_contains: String
    pool_contains_nocase: String
    pool_ends_with: String
    pool_ends_with_nocase: String
    pool_gt: String
    pool_gte: String
    pool_in: [String!]
    pool_lt: String
    pool_lte: String
    pool_not: String
    pool_not_contains: String
    pool_not_contains_nocase: String
    pool_not_ends_with: String
    pool_not_ends_with_nocase: String
    pool_not_in: [String!]
    pool_not_starts_with: String
    pool_not_starts_with_nocase: String
    pool_starts_with: String
    pool_starts_with_nocase: String
    surplus: BigDecimal
    surplus_gt: BigDecimal
    surplus_gte: BigDecimal
    surplus_in: [BigDecimal!]
    surplus_lt: BigDecimal
    surplus_lte: BigDecimal
    surplus_not: BigDecimal
    surplus_not_in: [BigDecimal!]
    swapFee: BigDecimal
    swapFee_gt: BigDecimal
    swapFee_gte: BigDecimal
    swapFee_in: [BigDecimal!]
    swapFee_lt: BigDecimal
    swapFee_lte: BigDecimal
    swapFee_not: BigDecimal
    swapFee_not_in: [BigDecimal!]
    symbol: String
    symbol_contains: String
    symbol_contains_nocase: String
    symbol_ends_with: String
    symbol_ends_with_nocase: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_contains_nocase: String
    symbol_not_ends_with: String
    symbol_not_ends_with_nocase: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_not_starts_with_nocase: String
    symbol_starts_with: String
    symbol_starts_with_nocase: String
    token: String
    token_: Token_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
    volume: BigDecimal
    volume_gt: BigDecimal
    volume_gte: BigDecimal
    volume_in: [BigDecimal!]
    volume_lt: BigDecimal
    volume_lte: BigDecimal
    volume_not: BigDecimal
    volume_not_in: [BigDecimal!]
    weight: BigDecimal
    weight_gt: BigDecimal
    weight_gte: BigDecimal
    weight_in: [BigDecimal!]
    weight_lt: BigDecimal
    weight_lte: BigDecimal
    weight_not: BigDecimal
    weight_not_in: [BigDecimal!]
}

enum PoolToken_orderBy {
    address
    balance
    decimals
    id
    index
    name
    pool
    pool__address
    pool__blockNumber
    pool__blockTimestamp
    pool__holdersCount
    pool__id
    pool__isInitialized
    pool__name
    pool__swapFee
    pool__swapsCount
    pool__symbol
    pool__totalShares
    pool__transactionHash
    surplus
    swapFee
    symbol
    token
    token__address
    token__decimals
    token__id
    token__name
    token__symbol
    volume
    weight
}

input Pool_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    address: Bytes
    address_contains: Bytes
    address_gt: Bytes
    address_gte: Bytes
    address_in: [Bytes!]
    address_lt: Bytes
    address_lte: Bytes
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    and: [Pool_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    factory: String
    factory_: Factory_filter
    factory_contains: String
    factory_contains_nocase: String
    factory_ends_with: String
    factory_ends_with_nocase: String
    factory_gt: String
    factory_gte: String
    factory_in: [String!]
    factory_lt: String
    factory_lte: String
    factory_not: String
    factory_not_contains: String
    factory_not_contains_nocase: String
    factory_not_ends_with: String
    factory_not_ends_with_nocase: String
    factory_not_in: [String!]
    factory_not_starts_with: String
    factory_not_starts_with_nocase: String
    factory_starts_with: String
    factory_starts_with_nocase: String
    holdersCount: BigInt
    holdersCount_gt: BigInt
    holdersCount_gte: BigInt
    holdersCount_in: [BigInt!]
    holdersCount_lt: BigInt
    holdersCount_lte: BigInt
    holdersCount_not: BigInt
    holdersCount_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    isInitialized: Boolean
    isInitialized_in: [Boolean!]
    isInitialized_not: Boolean
    isInitialized_not_in: [Boolean!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    or: [Pool_filter]
    snapshots_: PoolSnapshot_filter
    swapFee: BigDecimal
    swapFee_gt: BigDecimal
    swapFee_gte: BigDecimal
    swapFee_in: [BigDecimal!]
    swapFee_lt: BigDecimal
    swapFee_lte: BigDecimal
    swapFee_not: BigDecimal
    swapFee_not_in: [BigDecimal!]
    swapsCount: BigInt
    swapsCount_gt: BigInt
    swapsCount_gte: BigInt
    swapsCount_in: [BigInt!]
    swapsCount_lt: BigInt
    swapsCount_lte: BigInt
    swapsCount_not: BigInt
    swapsCount_not_in: [BigInt!]
    swaps_: Swap_filter
    symbol: String
    symbol_contains: String
    symbol_contains_nocase: String
    symbol_ends_with: String
    symbol_ends_with_nocase: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_contains_nocase: String
    symbol_not_ends_with: String
    symbol_not_ends_with_nocase: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_not_starts_with_nocase: String
    symbol_starts_with: String
    symbol_starts_with_nocase: String
    tokens_: PoolToken_filter
    totalShares: BigDecimal
    totalShares_gt: BigDecimal
    totalShares_gte: BigDecimal
    totalShares_in: [BigDecimal!]
    totalShares_lt: BigDecimal
    totalShares_lte: BigDecimal
    totalShares_not: BigDecimal
    totalShares_not_in: [BigDecimal!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
    weights: [BigDecimal!]
    weights_contains: [BigDecimal!]
    weights_contains_nocase: [BigDecimal!]
    weights_not: [BigDecimal!]
    weights_not_contains: [BigDecimal!]
    weights_not_contains_nocase: [BigDecimal!]
}

enum Pool_orderBy {
    address
    blockNumber
    blockTimestamp
    factory
    factory__id
    holdersCount
    id
    isInitialized
    name
    snapshots
    swapFee
    swaps
    swapsCount
    symbol
    tokens
    totalShares
    transactionHash
    weights
}

type Query {
    """
    Access to subgraph metadata
    """
    _meta(block: Block_height): _Meta_
    addRemove(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AddRemove
    addRemoves(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: AddRemove_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: AddRemove_filter
    ): [AddRemove!]!
    factories(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Factory_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Factory_filter
    ): [Factory!]!
    factory(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Factory
    pool(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Pool
    poolShare(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PoolShare
    poolShares(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: PoolShare_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: PoolShare_filter
    ): [PoolShare!]!
    poolSnapshot(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PoolSnapshot
    poolSnapshots(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: PoolSnapshot_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: PoolSnapshot_filter
    ): [PoolSnapshot!]!
    poolToken(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PoolToken
    poolTokens(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: PoolToken_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: PoolToken_filter
    ): [PoolToken!]!
    pools(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Pool_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Pool_filter
    ): [Pool!]!
    swap(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Swap
    swaps(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Swap_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Swap_filter
    ): [Swap!]!
    token(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Token
    tokens(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Token_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Token_filter
    ): [Token!]!
    user(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): User
    users(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: User_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: User_filter
    ): [User!]!
}

type Subscription {
    """
    Access to subgraph metadata
    """
    _meta(block: Block_height): _Meta_
    addRemove(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AddRemove
    addRemoves(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: AddRemove_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: AddRemove_filter
    ): [AddRemove!]!
    factories(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Factory_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Factory_filter
    ): [Factory!]!
    factory(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Factory
    pool(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Pool
    poolShare(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PoolShare
    poolShares(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: PoolShare_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: PoolShare_filter
    ): [PoolShare!]!
    poolSnapshot(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PoolSnapshot
    poolSnapshots(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: PoolSnapshot_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: PoolSnapshot_filter
    ): [PoolSnapshot!]!
    poolToken(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PoolToken
    poolTokens(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: PoolToken_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: PoolToken_filter
    ): [PoolToken!]!
    pools(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Pool_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Pool_filter
    ): [Pool!]!
    swap(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Swap
    swaps(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Swap_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Swap_filter
    ): [Swap!]!
    token(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Token
    tokens(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Token_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Token_filter
    ): [Token!]!
    user(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): User
    users(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: User_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: User_filter
    ): [User!]!
}

type Swap {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    logIndex: BigInt!
    pool: Pool!
    surplusAmount: BigDecimal
    surplusToken: Bytes
    swapFeeAmount: BigDecimal
    swapFeeToken: Bytes
    tokenAmountIn: BigDecimal!
    tokenAmountOut: BigDecimal!
    tokenIn: Bytes!
    tokenInSymbol: String!
    tokenOut: Bytes!
    tokenOutSymbol: String!
    transactionHash: Bytes!
    user: User!
}

input Swap_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [Swap_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    logIndex: BigInt
    logIndex_gt: BigInt
    logIndex_gte: BigInt
    logIndex_in: [BigInt!]
    logIndex_lt: BigInt
    logIndex_lte: BigInt
    logIndex_not: BigInt
    logIndex_not_in: [BigInt!]
    or: [Swap_filter]
    pool: String
    pool_: Pool_filter
    pool_contains: String
    pool_contains_nocase: String
    pool_ends_with: String
    pool_ends_with_nocase: String
    pool_gt: String
    pool_gte: String
    pool_in: [String!]
    pool_lt: String
    pool_lte: String
    pool_not: String
    pool_not_contains: String
    pool_not_contains_nocase: String
    pool_not_ends_with: String
    pool_not_ends_with_nocase: String
    pool_not_in: [String!]
    pool_not_starts_with: String
    pool_not_starts_with_nocase: String
    pool_starts_with: String
    pool_starts_with_nocase: String
    surplusAmount: BigDecimal
    surplusAmount_gt: BigDecimal
    surplusAmount_gte: BigDecimal
    surplusAmount_in: [BigDecimal!]
    surplusAmount_lt: BigDecimal
    surplusAmount_lte: BigDecimal
    surplusAmount_not: BigDecimal
    surplusAmount_not_in: [BigDecimal!]
    surplusToken: Bytes
    surplusToken_contains: Bytes
    surplusToken_gt: Bytes
    surplusToken_gte: Bytes
    surplusToken_in: [Bytes!]
    surplusToken_lt: Bytes
    surplusToken_lte: Bytes
    surplusToken_not: Bytes
    surplusToken_not_contains: Bytes
    surplusToken_not_in: [Bytes!]
    swapFeeAmount: BigDecimal
    swapFeeAmount_gt: BigDecimal
    swapFeeAmount_gte: BigDecimal
    swapFeeAmount_in: [BigDecimal!]
    swapFeeAmount_lt: BigDecimal
    swapFeeAmount_lte: BigDecimal
    swapFeeAmount_not: BigDecimal
    swapFeeAmount_not_in: [BigDecimal!]
    swapFeeToken: Bytes
    swapFeeToken_contains: Bytes
    swapFeeToken_gt: Bytes
    swapFeeToken_gte: Bytes
    swapFeeToken_in: [Bytes!]
    swapFeeToken_lt: Bytes
    swapFeeToken_lte: Bytes
    swapFeeToken_not: Bytes
    swapFeeToken_not_contains: Bytes
    swapFeeToken_not_in: [Bytes!]
    tokenAmountIn: BigDecimal
    tokenAmountIn_gt: BigDecimal
    tokenAmountIn_gte: BigDecimal
    tokenAmountIn_in: [BigDecimal!]
    tokenAmountIn_lt: BigDecimal
    tokenAmountIn_lte: BigDecimal
    tokenAmountIn_not: BigDecimal
    tokenAmountIn_not_in: [BigDecimal!]
    tokenAmountOut: BigDecimal
    tokenAmountOut_gt: BigDecimal
    tokenAmountOut_gte: BigDecimal
    tokenAmountOut_in: [BigDecimal!]
    tokenAmountOut_lt: BigDecimal
    tokenAmountOut_lte: BigDecimal
    tokenAmountOut_not: BigDecimal
    tokenAmountOut_not_in: [BigDecimal!]
    tokenIn: Bytes
    tokenInSymbol: String
    tokenInSymbol_contains: String
    tokenInSymbol_contains_nocase: String
    tokenInSymbol_ends_with: String
    tokenInSymbol_ends_with_nocase: String
    tokenInSymbol_gt: String
    tokenInSymbol_gte: String
    tokenInSymbol_in: [String!]
    tokenInSymbol_lt: String
    tokenInSymbol_lte: String
    tokenInSymbol_not: String
    tokenInSymbol_not_contains: String
    tokenInSymbol_not_contains_nocase: String
    tokenInSymbol_not_ends_with: String
    tokenInSymbol_not_ends_with_nocase: String
    tokenInSymbol_not_in: [String!]
    tokenInSymbol_not_starts_with: String
    tokenInSymbol_not_starts_with_nocase: String
    tokenInSymbol_starts_with: String
    tokenInSymbol_starts_with_nocase: String
    tokenIn_contains: Bytes
    tokenIn_gt: Bytes
    tokenIn_gte: Bytes
    tokenIn_in: [Bytes!]
    tokenIn_lt: Bytes
    tokenIn_lte: Bytes
    tokenIn_not: Bytes
    tokenIn_not_contains: Bytes
    tokenIn_not_in: [Bytes!]
    tokenOut: Bytes
    tokenOutSymbol: String
    tokenOutSymbol_contains: String
    tokenOutSymbol_contains_nocase: String
    tokenOutSymbol_ends_with: String
    tokenOutSymbol_ends_with_nocase: String
    tokenOutSymbol_gt: String
    tokenOutSymbol_gte: String
    tokenOutSymbol_in: [String!]
    tokenOutSymbol_lt: String
    tokenOutSymbol_lte: String
    tokenOutSymbol_not: String
    tokenOutSymbol_not_contains: String
    tokenOutSymbol_not_contains_nocase: String
    tokenOutSymbol_not_ends_with: String
    tokenOutSymbol_not_ends_with_nocase: String
    tokenOutSymbol_not_in: [String!]
    tokenOutSymbol_not_starts_with: String
    tokenOutSymbol_not_starts_with_nocase: String
    tokenOutSymbol_starts_with: String
    tokenOutSymbol_starts_with_nocase: String
    tokenOut_contains: Bytes
    tokenOut_gt: Bytes
    tokenOut_gte: Bytes
    tokenOut_in: [Bytes!]
    tokenOut_lt: Bytes
    tokenOut_lte: Bytes
    tokenOut_not: Bytes
    tokenOut_not_contains: Bytes
    tokenOut_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
    user: String
    user_: User_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
}

enum Swap_orderBy {
    blockNumber
    blockTimestamp
    id
    logIndex
    pool
    pool__address
    pool__blockNumber
    pool__blockTimestamp
    pool__holdersCount
    pool__id
    pool__isInitialized
    pool__name
    pool__swapFee
    pool__swapsCount
    pool__symbol
    pool__totalShares
    pool__transactionHash
    surplusAmount
    surplusToken
    swapFeeAmount
    swapFeeToken
    tokenAmountIn
    tokenAmountOut
    tokenIn
    tokenInSymbol
    tokenOut
    tokenOutSymbol
    transactionHash
    user
    user__id
}

"""
A string representation of microseconds UNIX timestamp (16 digits)
"""
scalar Timestamp

type Token {
    address: Bytes!
    decimals: Int!
    id: Bytes!
    name: String!
    symbol: String!
}

input Token_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    address: Bytes
    address_contains: Bytes
    address_gt: Bytes
    address_gte: Bytes
    address_in: [Bytes!]
    address_lt: Bytes
    address_lte: Bytes
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    and: [Token_filter]
    decimals: Int
    decimals_gt: Int
    decimals_gte: Int
    decimals_in: [Int!]
    decimals_lt: Int
    decimals_lte: Int
    decimals_not: Int
    decimals_not_in: [Int!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    or: [Token_filter]
    symbol: String
    symbol_contains: String
    symbol_contains_nocase: String
    symbol_ends_with: String
    symbol_ends_with_nocase: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_contains_nocase: String
    symbol_not_ends_with: String
    symbol_not_ends_with_nocase: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_not_starts_with_nocase: String
    symbol_starts_with: String
    symbol_starts_with_nocase: String
}

enum Token_orderBy {
    address
    decimals
    id
    name
    symbol
}

type User {
    addRemoves(
        first: Int = 100
        orderBy: AddRemove_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: AddRemove_filter
    ): [AddRemove!]
    id: Bytes!
    shares(
        first: Int = 100
        orderBy: PoolShare_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: PoolShare_filter
    ): [PoolShare!]
    swaps(
        first: Int = 100
        orderBy: Swap_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Swap_filter
    ): [Swap!]
}

input User_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    addRemoves_: AddRemove_filter
    and: [User_filter]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [User_filter]
    shares_: PoolShare_filter
    swaps_: Swap_filter
}

enum User_orderBy {
    addRemoves
    id
    shares
    swaps
}

type _Block_ {
    """
    The hash of the block
    """
    hash: Bytes

    """
    The block number
    """
    number: Int!

    """
    The hash of the parent block
    """
    parentHash: Bytes

    """
    Integer representation of the timestamp stored in blocks for the chain
    """
    timestamp: Int
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
    """
    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!

    """
    The deployment ID
    """
    deployment: String!

    """
    If `true`, the subgraph encountered indexing errors at some past block
    """
    hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
    """
    Data will be returned even if the subgraph has indexing errors
    """
    allow

    """
    If the subgraph has indexing errors, data will be omitted. The default.
    """
    deny
}
