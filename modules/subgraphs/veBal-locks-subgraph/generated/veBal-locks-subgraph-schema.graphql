"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""
Defined a Subgraph ID for an object type
"""
directive @subgraphId(id: String!) on OBJECT

enum Aggregation_interval {
    day
    hour
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
    number_gte: Int!
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

scalar Bytes

enum Chain {
    Arbitrum
    Avalanche
    Base
    Fraxtal
    Gnosis
    Optimism
    Polygon
    PolygonZkEvm
}

type Gauge {
    """
     Timestamp at which Balancer DAO added the gauge to GaugeController [seconds]
    """
    addedTimestamp: Int!

    """
     Address of the gauge
    """
    address: Bytes!

    """
     Equal to: <gaugeAddress>-<typeID>
    """
    id: ID!

    """
     Reference to LiquidityGauge
    """
    liquidityGauge: LiquidityGauge

    """
     Reference to RootGauge
    """
    rootGauge: RootGauge

    """
     Type of the gauge
    """
    type: GaugeType!
}

type GaugeFactory {
    """
     List of gauges created through the factory
    """
    gauges(
        first: Int = 100
        orderBy: LiquidityGauge_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: LiquidityGauge_filter
    ): [LiquidityGauge!]

    """
     Factory contract address
    """
    id: ID!

    """
     Number of gauges created through the factory
    """
    numGauges: Int!
}

input GaugeFactory_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [GaugeFactory_filter]
    gauges_: LiquidityGauge_filter
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    numGauges: Int
    numGauges_gt: Int
    numGauges_gte: Int
    numGauges_in: [Int!]
    numGauges_lt: Int
    numGauges_lte: Int
    numGauges_not: Int
    numGauges_not_in: [Int!]
    or: [GaugeFactory_filter]
}

enum GaugeFactory_orderBy {
    gauges
    id
    numGauges
}

type GaugeInjector {
    """
     GaugeInjector contract address
    """
    id: ID!
}

input GaugeInjector_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [GaugeInjector_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [GaugeInjector_filter]
}

enum GaugeInjector_orderBy {
    id
}

type GaugeShare {
    """
     User's balance of gauge deposit tokens
    """
    balance: BigDecimal!

    """
     Reference to LiquidityGauge entity
    """
    gauge: LiquidityGauge!

    """
     Equal to: <userAddress>-<gaugeAddress>
    """
    id: ID!

    """
     Reference to User entity
    """
    user: User!
}

input GaugeShare_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [GaugeShare_filter]
    balance: BigDecimal
    balance_gt: BigDecimal
    balance_gte: BigDecimal
    balance_in: [BigDecimal!]
    balance_lt: BigDecimal
    balance_lte: BigDecimal
    balance_not: BigDecimal
    balance_not_in: [BigDecimal!]
    gauge: String
    gauge_: LiquidityGauge_filter
    gauge_contains: String
    gauge_contains_nocase: String
    gauge_ends_with: String
    gauge_ends_with_nocase: String
    gauge_gt: String
    gauge_gte: String
    gauge_in: [String!]
    gauge_lt: String
    gauge_lte: String
    gauge_not: String
    gauge_not_contains: String
    gauge_not_contains_nocase: String
    gauge_not_ends_with: String
    gauge_not_ends_with_nocase: String
    gauge_not_in: [String!]
    gauge_not_starts_with: String
    gauge_not_starts_with_nocase: String
    gauge_starts_with: String
    gauge_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [GaugeShare_filter]
    user: String
    user_: User_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
}

enum GaugeShare_orderBy {
    balance
    gauge
    gauge__id
    gauge__isKilled
    gauge__isPreferentialGauge
    gauge__poolAddress
    gauge__poolId
    gauge__relativeWeightCap
    gauge__streamer
    gauge__symbol
    gauge__totalSupply
    id
    user
    user__id
}

type GaugeType {
    """
     Type ID
    """
    id: ID!

    """
     Name of the type - empty string if call reverts
    """
    name: String!
}

input GaugeType_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [GaugeType_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    or: [GaugeType_filter]
}

enum GaugeType_orderBy {
    id
    name
}

type GaugeVote {
    """
     Reference to Gauge entity
    """
    gauge: Gauge!

    """
     Equal to: <userAddress>-<gaugeAddress>
    """
    id: ID!

    """
     Timestamp at which user voted [seconds]
    """
    timestamp: BigInt

    """
     Reference to User entity
    """
    user: User!

    """
     Weight of veBAL power user has used to vote
    """
    weight: BigDecimal
}

input GaugeVote_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [GaugeVote_filter]
    gauge: String
    gauge_: Gauge_filter
    gauge_contains: String
    gauge_contains_nocase: String
    gauge_ends_with: String
    gauge_ends_with_nocase: String
    gauge_gt: String
    gauge_gte: String
    gauge_in: [String!]
    gauge_lt: String
    gauge_lte: String
    gauge_not: String
    gauge_not_contains: String
    gauge_not_contains_nocase: String
    gauge_not_ends_with: String
    gauge_not_ends_with_nocase: String
    gauge_not_in: [String!]
    gauge_not_starts_with: String
    gauge_not_starts_with_nocase: String
    gauge_starts_with: String
    gauge_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [GaugeVote_filter]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    user: String
    user_: User_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
    weight: BigDecimal
    weight_gt: BigDecimal
    weight_gte: BigDecimal
    weight_in: [BigDecimal!]
    weight_lt: BigDecimal
    weight_lte: BigDecimal
    weight_not: BigDecimal
    weight_not_in: [BigDecimal!]
}

enum GaugeVote_orderBy {
    gauge
    gauge__addedTimestamp
    gauge__address
    gauge__id
    id
    timestamp
    user
    user__id
    weight
}

input Gauge_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    addedTimestamp: Int
    addedTimestamp_gt: Int
    addedTimestamp_gte: Int
    addedTimestamp_in: [Int!]
    addedTimestamp_lt: Int
    addedTimestamp_lte: Int
    addedTimestamp_not: Int
    addedTimestamp_not_in: [Int!]
    address: Bytes
    address_contains: Bytes
    address_gt: Bytes
    address_gte: Bytes
    address_in: [Bytes!]
    address_lt: Bytes
    address_lte: Bytes
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    and: [Gauge_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    liquidityGauge: String
    liquidityGauge_: LiquidityGauge_filter
    liquidityGauge_contains: String
    liquidityGauge_contains_nocase: String
    liquidityGauge_ends_with: String
    liquidityGauge_ends_with_nocase: String
    liquidityGauge_gt: String
    liquidityGauge_gte: String
    liquidityGauge_in: [String!]
    liquidityGauge_lt: String
    liquidityGauge_lte: String
    liquidityGauge_not: String
    liquidityGauge_not_contains: String
    liquidityGauge_not_contains_nocase: String
    liquidityGauge_not_ends_with: String
    liquidityGauge_not_ends_with_nocase: String
    liquidityGauge_not_in: [String!]
    liquidityGauge_not_starts_with: String
    liquidityGauge_not_starts_with_nocase: String
    liquidityGauge_starts_with: String
    liquidityGauge_starts_with_nocase: String
    or: [Gauge_filter]
    rootGauge: String
    rootGauge_: RootGauge_filter
    rootGauge_contains: String
    rootGauge_contains_nocase: String
    rootGauge_ends_with: String
    rootGauge_ends_with_nocase: String
    rootGauge_gt: String
    rootGauge_gte: String
    rootGauge_in: [String!]
    rootGauge_lt: String
    rootGauge_lte: String
    rootGauge_not: String
    rootGauge_not_contains: String
    rootGauge_not_contains_nocase: String
    rootGauge_not_ends_with: String
    rootGauge_not_ends_with_nocase: String
    rootGauge_not_in: [String!]
    rootGauge_not_starts_with: String
    rootGauge_not_starts_with_nocase: String
    rootGauge_starts_with: String
    rootGauge_starts_with_nocase: String
    type: String
    type_: GaugeType_filter
    type_contains: String
    type_contains_nocase: String
    type_ends_with: String
    type_ends_with_nocase: String
    type_gt: String
    type_gte: String
    type_in: [String!]
    type_lt: String
    type_lte: String
    type_not: String
    type_not_contains: String
    type_not_contains_nocase: String
    type_not_ends_with: String
    type_not_ends_with_nocase: String
    type_not_in: [String!]
    type_not_starts_with: String
    type_not_starts_with_nocase: String
    type_starts_with: String
    type_starts_with_nocase: String
}

enum Gauge_orderBy {
    addedTimestamp
    address
    id
    liquidityGauge
    liquidityGauge__id
    liquidityGauge__isKilled
    liquidityGauge__isPreferentialGauge
    liquidityGauge__poolAddress
    liquidityGauge__poolId
    liquidityGauge__relativeWeightCap
    liquidityGauge__streamer
    liquidityGauge__symbol
    liquidityGauge__totalSupply
    rootGauge
    rootGauge__chain
    rootGauge__id
    rootGauge__isKilled
    rootGauge__recipient
    rootGauge__relativeWeightCap
    type
    type__id
    type__name
}

"""
8 bytes signed integer
"""
scalar Int8

type LiquidityGauge {
    """
     Factory contract address
    """
    factory: GaugeFactory!

    """
     Reference to Gauge entity - created when LiquidityGauge is added to GaugeController
    """
    gauge: Gauge

    """
     LiquidityGauge contract address
    """
    id: ID!

    """
     Whether Balancer DAO killed the gauge
    """
    isKilled: Boolean!

    """
     Whether the LiquidityGauge is the most recent added to GaugeController
    """
    isPreferentialGauge: Boolean!

    """
     Reference to Pool entity
    """
    pool: Pool

    """
     Address of the pool (lp_token of the gauge)
    """
    poolAddress: Bytes!

    """
     Pool ID if lp_token is a Balancer pool; null otherwise
    """
    poolId: Bytes

    """
     Relative weight cap of the gauge (0.01 = 1%) - V2 factories only
    """
    relativeWeightCap: BigDecimal

    """
     List of reward tokens depositted in the gauge - ChildChainLiquidityGauge only
    """
    rewardTokensList: [Bytes!]

    """
     List of user shares
    """
    shares(
        first: Int = 100
        orderBy: GaugeShare_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: GaugeShare_filter
    ): [GaugeShare!]

    """
     Address of the contract that streams reward tokens to the gauge - ChildChainLiquidityGauge only
    """
    streamer: Bytes

    """
     ERC20 token symbol
    """
    symbol: String!

    """
     List of reward tokens depositted in the gauge
    """
    tokens(
        first: Int = 100
        orderBy: RewardToken_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: RewardToken_filter
    ): [RewardToken!]

    """
     Total of BPTs users have staked in the LiquidityGauge
    """
    totalSupply: BigDecimal!
}

input LiquidityGauge_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [LiquidityGauge_filter]
    factory: String
    factory_: GaugeFactory_filter
    factory_contains: String
    factory_contains_nocase: String
    factory_ends_with: String
    factory_ends_with_nocase: String
    factory_gt: String
    factory_gte: String
    factory_in: [String!]
    factory_lt: String
    factory_lte: String
    factory_not: String
    factory_not_contains: String
    factory_not_contains_nocase: String
    factory_not_ends_with: String
    factory_not_ends_with_nocase: String
    factory_not_in: [String!]
    factory_not_starts_with: String
    factory_not_starts_with_nocase: String
    factory_starts_with: String
    factory_starts_with_nocase: String
    gauge: String
    gauge_: Gauge_filter
    gauge_contains: String
    gauge_contains_nocase: String
    gauge_ends_with: String
    gauge_ends_with_nocase: String
    gauge_gt: String
    gauge_gte: String
    gauge_in: [String!]
    gauge_lt: String
    gauge_lte: String
    gauge_not: String
    gauge_not_contains: String
    gauge_not_contains_nocase: String
    gauge_not_ends_with: String
    gauge_not_ends_with_nocase: String
    gauge_not_in: [String!]
    gauge_not_starts_with: String
    gauge_not_starts_with_nocase: String
    gauge_starts_with: String
    gauge_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    isKilled: Boolean
    isKilled_in: [Boolean!]
    isKilled_not: Boolean
    isKilled_not_in: [Boolean!]
    isPreferentialGauge: Boolean
    isPreferentialGauge_in: [Boolean!]
    isPreferentialGauge_not: Boolean
    isPreferentialGauge_not_in: [Boolean!]
    or: [LiquidityGauge_filter]
    pool: String
    poolAddress: Bytes
    poolAddress_contains: Bytes
    poolAddress_gt: Bytes
    poolAddress_gte: Bytes
    poolAddress_in: [Bytes!]
    poolAddress_lt: Bytes
    poolAddress_lte: Bytes
    poolAddress_not: Bytes
    poolAddress_not_contains: Bytes
    poolAddress_not_in: [Bytes!]
    poolId: Bytes
    poolId_contains: Bytes
    poolId_gt: Bytes
    poolId_gte: Bytes
    poolId_in: [Bytes!]
    poolId_lt: Bytes
    poolId_lte: Bytes
    poolId_not: Bytes
    poolId_not_contains: Bytes
    poolId_not_in: [Bytes!]
    pool_: Pool_filter
    pool_contains: String
    pool_contains_nocase: String
    pool_ends_with: String
    pool_ends_with_nocase: String
    pool_gt: String
    pool_gte: String
    pool_in: [String!]
    pool_lt: String
    pool_lte: String
    pool_not: String
    pool_not_contains: String
    pool_not_contains_nocase: String
    pool_not_ends_with: String
    pool_not_ends_with_nocase: String
    pool_not_in: [String!]
    pool_not_starts_with: String
    pool_not_starts_with_nocase: String
    pool_starts_with: String
    pool_starts_with_nocase: String
    relativeWeightCap: BigDecimal
    relativeWeightCap_gt: BigDecimal
    relativeWeightCap_gte: BigDecimal
    relativeWeightCap_in: [BigDecimal!]
    relativeWeightCap_lt: BigDecimal
    relativeWeightCap_lte: BigDecimal
    relativeWeightCap_not: BigDecimal
    relativeWeightCap_not_in: [BigDecimal!]
    rewardTokensList: [Bytes!]
    rewardTokensList_contains: [Bytes!]
    rewardTokensList_contains_nocase: [Bytes!]
    rewardTokensList_not: [Bytes!]
    rewardTokensList_not_contains: [Bytes!]
    rewardTokensList_not_contains_nocase: [Bytes!]
    shares_: GaugeShare_filter
    streamer: Bytes
    streamer_contains: Bytes
    streamer_gt: Bytes
    streamer_gte: Bytes
    streamer_in: [Bytes!]
    streamer_lt: Bytes
    streamer_lte: Bytes
    streamer_not: Bytes
    streamer_not_contains: Bytes
    streamer_not_in: [Bytes!]
    symbol: String
    symbol_contains: String
    symbol_contains_nocase: String
    symbol_ends_with: String
    symbol_ends_with_nocase: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_contains_nocase: String
    symbol_not_ends_with: String
    symbol_not_ends_with_nocase: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_not_starts_with_nocase: String
    symbol_starts_with: String
    symbol_starts_with_nocase: String
    tokens_: RewardToken_filter
    totalSupply: BigDecimal
    totalSupply_gt: BigDecimal
    totalSupply_gte: BigDecimal
    totalSupply_in: [BigDecimal!]
    totalSupply_lt: BigDecimal
    totalSupply_lte: BigDecimal
    totalSupply_not: BigDecimal
    totalSupply_not_in: [BigDecimal!]
}

enum LiquidityGauge_orderBy {
    factory
    factory__id
    factory__numGauges
    gauge
    gauge__addedTimestamp
    gauge__address
    gauge__id
    id
    isKilled
    isPreferentialGauge
    pool
    poolAddress
    poolId
    pool__address
    pool__id
    pool__poolId
    relativeWeightCap
    rewardTokensList
    shares
    streamer
    symbol
    tokens
    totalSupply
}

type LockSnapshot {
    """
     veBAL balance at the moment user locks
    """
    bias: BigDecimal!

    """
     Equal to <userAddress>-<timestamp>
    """
    id: ID!

    """
     veBAL decay rate (per second)
    """
    slope: BigDecimal!

    """
     Timestamp at which the snapshot was taken [seconds]
    """
    timestamp: Int!

    """
     Reference to User entity
    """
    user: User!
}

input LockSnapshot_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [LockSnapshot_filter]
    bias: BigDecimal
    bias_gt: BigDecimal
    bias_gte: BigDecimal
    bias_in: [BigDecimal!]
    bias_lt: BigDecimal
    bias_lte: BigDecimal
    bias_not: BigDecimal
    bias_not_in: [BigDecimal!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [LockSnapshot_filter]
    slope: BigDecimal
    slope_gt: BigDecimal
    slope_gte: BigDecimal
    slope_in: [BigDecimal!]
    slope_lt: BigDecimal
    slope_lte: BigDecimal
    slope_not: BigDecimal
    slope_not_in: [BigDecimal!]
    timestamp: Int
    timestamp_gt: Int
    timestamp_gte: Int
    timestamp_in: [Int!]
    timestamp_lt: Int
    timestamp_lte: Int
    timestamp_not: Int
    timestamp_not_in: [Int!]
    user: String
    user_: User_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
}

enum LockSnapshot_orderBy {
    bias
    id
    slope
    timestamp
    user
    user__id
}

type OmniVotingEscrowLock {
    """
     veBAL balance at the moment user locks
    """
    bias: BigDecimal!

    """
     Chain where the lock was bridged to
    """
    dstChainId: Int!

    """
     Equal to: <userAdress>-<omniVotingEscrow>
    """
    id: ID!

    """
     User on the local chain (reference to User entity)
    """
    localUser: User!

    """
     User address on the remote chain
    """
    remoteUser: Bytes!

    """
     veBAL decay rate (per second)
    """
    slope: BigDecimal!

    """
     Timestamp the lock was created [seconds]
    """
    timestamp: Int!

    """
     Reference to VotingEscrow entity
    """
    votingEscrowID: VotingEscrow!
}

input OmniVotingEscrowLock_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [OmniVotingEscrowLock_filter]
    bias: BigDecimal
    bias_gt: BigDecimal
    bias_gte: BigDecimal
    bias_in: [BigDecimal!]
    bias_lt: BigDecimal
    bias_lte: BigDecimal
    bias_not: BigDecimal
    bias_not_in: [BigDecimal!]
    dstChainId: Int
    dstChainId_gt: Int
    dstChainId_gte: Int
    dstChainId_in: [Int!]
    dstChainId_lt: Int
    dstChainId_lte: Int
    dstChainId_not: Int
    dstChainId_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    localUser: String
    localUser_: User_filter
    localUser_contains: String
    localUser_contains_nocase: String
    localUser_ends_with: String
    localUser_ends_with_nocase: String
    localUser_gt: String
    localUser_gte: String
    localUser_in: [String!]
    localUser_lt: String
    localUser_lte: String
    localUser_not: String
    localUser_not_contains: String
    localUser_not_contains_nocase: String
    localUser_not_ends_with: String
    localUser_not_ends_with_nocase: String
    localUser_not_in: [String!]
    localUser_not_starts_with: String
    localUser_not_starts_with_nocase: String
    localUser_starts_with: String
    localUser_starts_with_nocase: String
    or: [OmniVotingEscrowLock_filter]
    remoteUser: Bytes
    remoteUser_contains: Bytes
    remoteUser_gt: Bytes
    remoteUser_gte: Bytes
    remoteUser_in: [Bytes!]
    remoteUser_lt: Bytes
    remoteUser_lte: Bytes
    remoteUser_not: Bytes
    remoteUser_not_contains: Bytes
    remoteUser_not_in: [Bytes!]
    slope: BigDecimal
    slope_gt: BigDecimal
    slope_gte: BigDecimal
    slope_in: [BigDecimal!]
    slope_lt: BigDecimal
    slope_lte: BigDecimal
    slope_not: BigDecimal
    slope_not_in: [BigDecimal!]
    timestamp: Int
    timestamp_gt: Int
    timestamp_gte: Int
    timestamp_in: [Int!]
    timestamp_lt: Int
    timestamp_lte: Int
    timestamp_not: Int
    timestamp_not_in: [Int!]
    votingEscrowID: String
    votingEscrowID_: VotingEscrow_filter
    votingEscrowID_contains: String
    votingEscrowID_contains_nocase: String
    votingEscrowID_ends_with: String
    votingEscrowID_ends_with_nocase: String
    votingEscrowID_gt: String
    votingEscrowID_gte: String
    votingEscrowID_in: [String!]
    votingEscrowID_lt: String
    votingEscrowID_lte: String
    votingEscrowID_not: String
    votingEscrowID_not_contains: String
    votingEscrowID_not_contains_nocase: String
    votingEscrowID_not_ends_with: String
    votingEscrowID_not_ends_with_nocase: String
    votingEscrowID_not_in: [String!]
    votingEscrowID_not_starts_with: String
    votingEscrowID_not_starts_with_nocase: String
    votingEscrowID_starts_with: String
    votingEscrowID_starts_with_nocase: String
}

enum OmniVotingEscrowLock_orderBy {
    bias
    dstChainId
    id
    localUser
    localUser__id
    remoteUser
    slope
    timestamp
    votingEscrowID
    votingEscrowID__id
    votingEscrowID__stakedSupply
}

"""
Defines the order direction, either ascending or descending
"""
enum OrderDirection {
    asc
    desc
}

type Pool {
    """
     Address of the pool (lp_token of the gauge)
    """
    address: Bytes!

    """
     List of gauges created for the pool
    """
    gauges(
        first: Int = 100
        orderBy: LiquidityGauge_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: LiquidityGauge_filter
    ): [LiquidityGauge!]

    """
     List of the pool's gauges addresses
    """
    gaugesList: [Bytes!]!

    """
     Address of the pool (lp_token of the gauge)
    """
    id: ID!

    """
     Pool ID if lp_token is a Balancer pool; null otherwise
    """
    poolId: Bytes

    """
     Most recent, unkilled gauge in the GaugeController
    """
    preferentialGauge: LiquidityGauge
}

input Pool_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    address: Bytes
    address_contains: Bytes
    address_gt: Bytes
    address_gte: Bytes
    address_in: [Bytes!]
    address_lt: Bytes
    address_lte: Bytes
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    and: [Pool_filter]
    gaugesList: [Bytes!]
    gaugesList_contains: [Bytes!]
    gaugesList_contains_nocase: [Bytes!]
    gaugesList_not: [Bytes!]
    gaugesList_not_contains: [Bytes!]
    gaugesList_not_contains_nocase: [Bytes!]
    gauges_: LiquidityGauge_filter
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [Pool_filter]
    poolId: Bytes
    poolId_contains: Bytes
    poolId_gt: Bytes
    poolId_gte: Bytes
    poolId_in: [Bytes!]
    poolId_lt: Bytes
    poolId_lte: Bytes
    poolId_not: Bytes
    poolId_not_contains: Bytes
    poolId_not_in: [Bytes!]
    preferentialGauge: String
    preferentialGauge_: LiquidityGauge_filter
    preferentialGauge_contains: String
    preferentialGauge_contains_nocase: String
    preferentialGauge_ends_with: String
    preferentialGauge_ends_with_nocase: String
    preferentialGauge_gt: String
    preferentialGauge_gte: String
    preferentialGauge_in: [String!]
    preferentialGauge_lt: String
    preferentialGauge_lte: String
    preferentialGauge_not: String
    preferentialGauge_not_contains: String
    preferentialGauge_not_contains_nocase: String
    preferentialGauge_not_ends_with: String
    preferentialGauge_not_ends_with_nocase: String
    preferentialGauge_not_in: [String!]
    preferentialGauge_not_starts_with: String
    preferentialGauge_not_starts_with_nocase: String
    preferentialGauge_starts_with: String
    preferentialGauge_starts_with_nocase: String
}

enum Pool_orderBy {
    address
    gauges
    gaugesList
    id
    poolId
    preferentialGauge
    preferentialGauge__id
    preferentialGauge__isKilled
    preferentialGauge__isPreferentialGauge
    preferentialGauge__poolAddress
    preferentialGauge__poolId
    preferentialGauge__relativeWeightCap
    preferentialGauge__streamer
    preferentialGauge__symbol
    preferentialGauge__totalSupply
}

type Query {
    """
    Access to subgraph metadata
    """
    _meta(block: Block_height): _Meta_
    gauge(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Gauge
    gaugeFactories(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: GaugeFactory_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: GaugeFactory_filter
    ): [GaugeFactory!]!
    gaugeFactory(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GaugeFactory
    gaugeInjector(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GaugeInjector
    gaugeInjectors(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: GaugeInjector_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: GaugeInjector_filter
    ): [GaugeInjector!]!
    gaugeShare(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GaugeShare
    gaugeShares(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: GaugeShare_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: GaugeShare_filter
    ): [GaugeShare!]!
    gaugeType(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GaugeType
    gaugeTypes(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: GaugeType_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: GaugeType_filter
    ): [GaugeType!]!
    gaugeVote(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GaugeVote
    gaugeVotes(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: GaugeVote_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: GaugeVote_filter
    ): [GaugeVote!]!
    gauges(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Gauge_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Gauge_filter
    ): [Gauge!]!
    liquidityGauge(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): LiquidityGauge
    liquidityGauges(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: LiquidityGauge_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: LiquidityGauge_filter
    ): [LiquidityGauge!]!
    lockSnapshot(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): LockSnapshot
    lockSnapshots(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: LockSnapshot_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: LockSnapshot_filter
    ): [LockSnapshot!]!
    omniVotingEscrowLock(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OmniVotingEscrowLock
    omniVotingEscrowLocks(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: OmniVotingEscrowLock_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: OmniVotingEscrowLock_filter
    ): [OmniVotingEscrowLock!]!
    pool(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Pool
    pools(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Pool_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Pool_filter
    ): [Pool!]!
    rewardToken(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RewardToken
    rewardTokens(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: RewardToken_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: RewardToken_filter
    ): [RewardToken!]!
    rootGauge(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RootGauge
    rootGauges(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: RootGauge_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: RootGauge_filter
    ): [RootGauge!]!
    singleRecipientGauge(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): SingleRecipientGauge
    singleRecipientGauges(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: SingleRecipientGauge_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: SingleRecipientGauge_filter
    ): [SingleRecipientGauge!]!
    user(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): User
    users(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: User_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: User_filter
    ): [User!]!
    votingEscrow(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): VotingEscrow
    votingEscrowLock(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): VotingEscrowLock
    votingEscrowLocks(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: VotingEscrowLock_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: VotingEscrowLock_filter
    ): [VotingEscrowLock!]!
    votingEscrows(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: VotingEscrow_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: VotingEscrow_filter
    ): [VotingEscrow!]!
}

type RewardToken {
    """
     ERC20 token decimals - zero if call to decimals() reverts
    """
    decimals: Int!

    """
     Reference to LiquidityGauge entity
    """
    gauge: LiquidityGauge!

    """
     Equal to: <tokenAddress>-<gaugeAddress>
    """
    id: ID!

    """
     Timestamp at which finishes the period of rewards
    """
    periodFinish: BigInt

    """
     Rate of reward tokens streamed per second
    """
    rate: BigDecimal

    """
     ERC20 token symbol - empty string if call to symbol() reverts
    """
    symbol: String!

    """
     Amount of reward tokens that has been deposited into the gauge
    """
    totalDeposited: BigDecimal!
}

input RewardToken_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [RewardToken_filter]
    decimals: Int
    decimals_gt: Int
    decimals_gte: Int
    decimals_in: [Int!]
    decimals_lt: Int
    decimals_lte: Int
    decimals_not: Int
    decimals_not_in: [Int!]
    gauge: String
    gauge_: LiquidityGauge_filter
    gauge_contains: String
    gauge_contains_nocase: String
    gauge_ends_with: String
    gauge_ends_with_nocase: String
    gauge_gt: String
    gauge_gte: String
    gauge_in: [String!]
    gauge_lt: String
    gauge_lte: String
    gauge_not: String
    gauge_not_contains: String
    gauge_not_contains_nocase: String
    gauge_not_ends_with: String
    gauge_not_ends_with_nocase: String
    gauge_not_in: [String!]
    gauge_not_starts_with: String
    gauge_not_starts_with_nocase: String
    gauge_starts_with: String
    gauge_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [RewardToken_filter]
    periodFinish: BigInt
    periodFinish_gt: BigInt
    periodFinish_gte: BigInt
    periodFinish_in: [BigInt!]
    periodFinish_lt: BigInt
    periodFinish_lte: BigInt
    periodFinish_not: BigInt
    periodFinish_not_in: [BigInt!]
    rate: BigDecimal
    rate_gt: BigDecimal
    rate_gte: BigDecimal
    rate_in: [BigDecimal!]
    rate_lt: BigDecimal
    rate_lte: BigDecimal
    rate_not: BigDecimal
    rate_not_in: [BigDecimal!]
    symbol: String
    symbol_contains: String
    symbol_contains_nocase: String
    symbol_ends_with: String
    symbol_ends_with_nocase: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_contains_nocase: String
    symbol_not_ends_with: String
    symbol_not_ends_with_nocase: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_not_starts_with_nocase: String
    symbol_starts_with: String
    symbol_starts_with_nocase: String
    totalDeposited: BigDecimal
    totalDeposited_gt: BigDecimal
    totalDeposited_gte: BigDecimal
    totalDeposited_in: [BigDecimal!]
    totalDeposited_lt: BigDecimal
    totalDeposited_lte: BigDecimal
    totalDeposited_not: BigDecimal
    totalDeposited_not_in: [BigDecimal!]
}

enum RewardToken_orderBy {
    decimals
    gauge
    gauge__id
    gauge__isKilled
    gauge__isPreferentialGauge
    gauge__poolAddress
    gauge__poolId
    gauge__relativeWeightCap
    gauge__streamer
    gauge__symbol
    gauge__totalSupply
    id
    periodFinish
    rate
    symbol
    totalDeposited
}

type RootGauge {
    """
     Chain where emissions by this gauge will be bridged to
    """
    chain: Chain!

    """
     Factory contract address
    """
    factory: GaugeFactory!

    """
     Reference to Gauge entity - created when LiquidityGauge is added to GaugeController
    """
    gauge: Gauge

    """
     RootGauge contract address
    """
    id: ID!

    """
     Whether Balancer DAO killed the gauge
    """
    isKilled: Boolean!

    """
     Address where emissions by this gauge will be bridged to
    """
    recipient: Bytes!

    """
     Relative weight cap of the gauge (0.01 = 1%) - V2 factories only
    """
    relativeWeightCap: BigDecimal
}

input RootGauge_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [RootGauge_filter]
    chain: Chain
    chain_in: [Chain!]
    chain_not: Chain
    chain_not_in: [Chain!]
    factory: String
    factory_: GaugeFactory_filter
    factory_contains: String
    factory_contains_nocase: String
    factory_ends_with: String
    factory_ends_with_nocase: String
    factory_gt: String
    factory_gte: String
    factory_in: [String!]
    factory_lt: String
    factory_lte: String
    factory_not: String
    factory_not_contains: String
    factory_not_contains_nocase: String
    factory_not_ends_with: String
    factory_not_ends_with_nocase: String
    factory_not_in: [String!]
    factory_not_starts_with: String
    factory_not_starts_with_nocase: String
    factory_starts_with: String
    factory_starts_with_nocase: String
    gauge: String
    gauge_: Gauge_filter
    gauge_contains: String
    gauge_contains_nocase: String
    gauge_ends_with: String
    gauge_ends_with_nocase: String
    gauge_gt: String
    gauge_gte: String
    gauge_in: [String!]
    gauge_lt: String
    gauge_lte: String
    gauge_not: String
    gauge_not_contains: String
    gauge_not_contains_nocase: String
    gauge_not_ends_with: String
    gauge_not_ends_with_nocase: String
    gauge_not_in: [String!]
    gauge_not_starts_with: String
    gauge_not_starts_with_nocase: String
    gauge_starts_with: String
    gauge_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    isKilled: Boolean
    isKilled_in: [Boolean!]
    isKilled_not: Boolean
    isKilled_not_in: [Boolean!]
    or: [RootGauge_filter]
    recipient: Bytes
    recipient_contains: Bytes
    recipient_gt: Bytes
    recipient_gte: Bytes
    recipient_in: [Bytes!]
    recipient_lt: Bytes
    recipient_lte: Bytes
    recipient_not: Bytes
    recipient_not_contains: Bytes
    recipient_not_in: [Bytes!]
    relativeWeightCap: BigDecimal
    relativeWeightCap_gt: BigDecimal
    relativeWeightCap_gte: BigDecimal
    relativeWeightCap_in: [BigDecimal!]
    relativeWeightCap_lt: BigDecimal
    relativeWeightCap_lte: BigDecimal
    relativeWeightCap_not: BigDecimal
    relativeWeightCap_not_in: [BigDecimal!]
}

enum RootGauge_orderBy {
    chain
    factory
    factory__id
    factory__numGauges
    gauge
    gauge__addedTimestamp
    gauge__address
    gauge__id
    id
    isKilled
    recipient
    relativeWeightCap
}

type SingleRecipientGauge {
    """
     Factory contract address
    """
    factory: GaugeFactory!

    """
     Reference to Gauge entity - created when SingleRecipientGauge is added to GaugeController
    """
    gauge: Gauge

    """
     SingleRecipientGauge contract address
    """
    id: ID!

    """
     Whether Balancer DAO killed the gauge
    """
    isKilled: Boolean!

    """
     Address where emissions for this gauge will be sent to
    """
    recipient: Bytes!

    """
     Relative weight cap of the gauge (0.01 = 1%) - V2 factories only
    """
    relativeWeightCap: BigDecimal
}

input SingleRecipientGauge_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [SingleRecipientGauge_filter]
    factory: String
    factory_: GaugeFactory_filter
    factory_contains: String
    factory_contains_nocase: String
    factory_ends_with: String
    factory_ends_with_nocase: String
    factory_gt: String
    factory_gte: String
    factory_in: [String!]
    factory_lt: String
    factory_lte: String
    factory_not: String
    factory_not_contains: String
    factory_not_contains_nocase: String
    factory_not_ends_with: String
    factory_not_ends_with_nocase: String
    factory_not_in: [String!]
    factory_not_starts_with: String
    factory_not_starts_with_nocase: String
    factory_starts_with: String
    factory_starts_with_nocase: String
    gauge: String
    gauge_: Gauge_filter
    gauge_contains: String
    gauge_contains_nocase: String
    gauge_ends_with: String
    gauge_ends_with_nocase: String
    gauge_gt: String
    gauge_gte: String
    gauge_in: [String!]
    gauge_lt: String
    gauge_lte: String
    gauge_not: String
    gauge_not_contains: String
    gauge_not_contains_nocase: String
    gauge_not_ends_with: String
    gauge_not_ends_with_nocase: String
    gauge_not_in: [String!]
    gauge_not_starts_with: String
    gauge_not_starts_with_nocase: String
    gauge_starts_with: String
    gauge_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    isKilled: Boolean
    isKilled_in: [Boolean!]
    isKilled_not: Boolean
    isKilled_not_in: [Boolean!]
    or: [SingleRecipientGauge_filter]
    recipient: Bytes
    recipient_contains: Bytes
    recipient_gt: Bytes
    recipient_gte: Bytes
    recipient_in: [Bytes!]
    recipient_lt: Bytes
    recipient_lte: Bytes
    recipient_not: Bytes
    recipient_not_contains: Bytes
    recipient_not_in: [Bytes!]
    relativeWeightCap: BigDecimal
    relativeWeightCap_gt: BigDecimal
    relativeWeightCap_gte: BigDecimal
    relativeWeightCap_in: [BigDecimal!]
    relativeWeightCap_lt: BigDecimal
    relativeWeightCap_lte: BigDecimal
    relativeWeightCap_not: BigDecimal
    relativeWeightCap_not_in: [BigDecimal!]
}

enum SingleRecipientGauge_orderBy {
    factory
    factory__id
    factory__numGauges
    gauge
    gauge__addedTimestamp
    gauge__address
    gauge__id
    id
    isKilled
    recipient
    relativeWeightCap
}

type Subscription {
    """
    Access to subgraph metadata
    """
    _meta(block: Block_height): _Meta_
    gauge(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Gauge
    gaugeFactories(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: GaugeFactory_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: GaugeFactory_filter
    ): [GaugeFactory!]!
    gaugeFactory(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GaugeFactory
    gaugeInjector(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GaugeInjector
    gaugeInjectors(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: GaugeInjector_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: GaugeInjector_filter
    ): [GaugeInjector!]!
    gaugeShare(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GaugeShare
    gaugeShares(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: GaugeShare_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: GaugeShare_filter
    ): [GaugeShare!]!
    gaugeType(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GaugeType
    gaugeTypes(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: GaugeType_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: GaugeType_filter
    ): [GaugeType!]!
    gaugeVote(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GaugeVote
    gaugeVotes(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: GaugeVote_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: GaugeVote_filter
    ): [GaugeVote!]!
    gauges(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Gauge_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Gauge_filter
    ): [Gauge!]!
    liquidityGauge(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): LiquidityGauge
    liquidityGauges(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: LiquidityGauge_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: LiquidityGauge_filter
    ): [LiquidityGauge!]!
    lockSnapshot(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): LockSnapshot
    lockSnapshots(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: LockSnapshot_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: LockSnapshot_filter
    ): [LockSnapshot!]!
    omniVotingEscrowLock(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OmniVotingEscrowLock
    omniVotingEscrowLocks(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: OmniVotingEscrowLock_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: OmniVotingEscrowLock_filter
    ): [OmniVotingEscrowLock!]!
    pool(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Pool
    pools(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Pool_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Pool_filter
    ): [Pool!]!
    rewardToken(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RewardToken
    rewardTokens(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: RewardToken_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: RewardToken_filter
    ): [RewardToken!]!
    rootGauge(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RootGauge
    rootGauges(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: RootGauge_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: RootGauge_filter
    ): [RootGauge!]!
    singleRecipientGauge(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): SingleRecipientGauge
    singleRecipientGauges(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: SingleRecipientGauge_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: SingleRecipientGauge_filter
    ): [SingleRecipientGauge!]!
    user(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): User
    users(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: User_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: User_filter
    ): [User!]!
    votingEscrow(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): VotingEscrow
    votingEscrowLock(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): VotingEscrowLock
    votingEscrowLocks(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: VotingEscrowLock_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: VotingEscrowLock_filter
    ): [VotingEscrowLock!]!
    votingEscrows(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: VotingEscrow_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: VotingEscrow_filter
    ): [VotingEscrow!]!
}

"""
A string representation of microseconds UNIX timestamp (16 digits)
"""
scalar Timestamp

type User {
    """
     List of gauge the user has shares
    """
    gaugeShares(
        first: Int = 100
        orderBy: GaugeShare_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: GaugeShare_filter
    ): [GaugeShare!]

    """
     List of votes on gauges
    """
    gaugeVotes(
        first: Int = 100
        orderBy: GaugeVote_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: GaugeVote_filter
    ): [GaugeVote!]

    """
     User address
    """
    id: ID!

    """
     List of omni locks the user created
    """
    omniVotingLocks(
        first: Int = 100
        orderBy: OmniVotingEscrowLock_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: OmniVotingEscrowLock_filter
    ): [OmniVotingEscrowLock!]

    """
     List of locks the user created
    """
    votingLocks(
        first: Int = 100
        orderBy: VotingEscrowLock_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: VotingEscrowLock_filter
    ): [VotingEscrowLock!]
}

input User_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [User_filter]
    gaugeShares_: GaugeShare_filter
    gaugeVotes_: GaugeVote_filter
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    omniVotingLocks_: OmniVotingEscrowLock_filter
    or: [User_filter]
    votingLocks_: VotingEscrowLock_filter
}

enum User_orderBy {
    gaugeShares
    gaugeVotes
    id
    omniVotingLocks
    votingLocks
}

type VotingEscrow {
    """
     VotingEscrow contract address
    """
    id: ID!

    """
     List of veBAL locks created
    """
    locks(
        first: Int = 100
        orderBy: VotingEscrowLock_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: VotingEscrowLock_filter
    ): [VotingEscrowLock!]

    """
     List of veBAL locks created
    """
    omniLocks(
        first: Int = 100
        orderBy: OmniVotingEscrowLock_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: OmniVotingEscrowLock_filter
    ): [OmniVotingEscrowLock!]

    """
     Amount of B-80BAL-20WETH BPT locked, only applies on mainnet
    """
    stakedSupply: BigDecimal
}

type VotingEscrowLock {
    """
     veBAL balance at the moment user locks
    """
    bias: BigDecimal!

    """
     Equal to: <userAdress>-<votingEscrow>
    """
    id: ID!

    """
     Amount of B-80BAL-20WETH BPT the user has locked
    """
    lockedBalance: BigDecimal!

    """
     veBAL decay rate (per second)
    """
    slope: BigDecimal!

    """
     Timestamp at which the lock was created [seconds]
    """
    timestamp: Int!

    """
     Timestamp at which B-80BAL-20WETH BPT can be unlocked by user [seconds]
    """
    unlockTime: BigInt!

    """
     Timestamp at which the lcok was created [seconds]. Same as timestamp
    """
    updatedAt: Int!

    """
     Reference to User entity
    """
    user: User!

    """
     Reference to VotingEscrow entity
    """
    votingEscrowID: VotingEscrow!
}

input VotingEscrowLock_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [VotingEscrowLock_filter]
    bias: BigDecimal
    bias_gt: BigDecimal
    bias_gte: BigDecimal
    bias_in: [BigDecimal!]
    bias_lt: BigDecimal
    bias_lte: BigDecimal
    bias_not: BigDecimal
    bias_not_in: [BigDecimal!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    lockedBalance: BigDecimal
    lockedBalance_gt: BigDecimal
    lockedBalance_gte: BigDecimal
    lockedBalance_in: [BigDecimal!]
    lockedBalance_lt: BigDecimal
    lockedBalance_lte: BigDecimal
    lockedBalance_not: BigDecimal
    lockedBalance_not_in: [BigDecimal!]
    or: [VotingEscrowLock_filter]
    slope: BigDecimal
    slope_gt: BigDecimal
    slope_gte: BigDecimal
    slope_in: [BigDecimal!]
    slope_lt: BigDecimal
    slope_lte: BigDecimal
    slope_not: BigDecimal
    slope_not_in: [BigDecimal!]
    timestamp: Int
    timestamp_gt: Int
    timestamp_gte: Int
    timestamp_in: [Int!]
    timestamp_lt: Int
    timestamp_lte: Int
    timestamp_not: Int
    timestamp_not_in: [Int!]
    unlockTime: BigInt
    unlockTime_gt: BigInt
    unlockTime_gte: BigInt
    unlockTime_in: [BigInt!]
    unlockTime_lt: BigInt
    unlockTime_lte: BigInt
    unlockTime_not: BigInt
    unlockTime_not_in: [BigInt!]
    updatedAt: Int
    updatedAt_gt: Int
    updatedAt_gte: Int
    updatedAt_in: [Int!]
    updatedAt_lt: Int
    updatedAt_lte: Int
    updatedAt_not: Int
    updatedAt_not_in: [Int!]
    user: String
    user_: User_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
    votingEscrowID: String
    votingEscrowID_: VotingEscrow_filter
    votingEscrowID_contains: String
    votingEscrowID_contains_nocase: String
    votingEscrowID_ends_with: String
    votingEscrowID_ends_with_nocase: String
    votingEscrowID_gt: String
    votingEscrowID_gte: String
    votingEscrowID_in: [String!]
    votingEscrowID_lt: String
    votingEscrowID_lte: String
    votingEscrowID_not: String
    votingEscrowID_not_contains: String
    votingEscrowID_not_contains_nocase: String
    votingEscrowID_not_ends_with: String
    votingEscrowID_not_ends_with_nocase: String
    votingEscrowID_not_in: [String!]
    votingEscrowID_not_starts_with: String
    votingEscrowID_not_starts_with_nocase: String
    votingEscrowID_starts_with: String
    votingEscrowID_starts_with_nocase: String
}

enum VotingEscrowLock_orderBy {
    bias
    id
    lockedBalance
    slope
    timestamp
    unlockTime
    updatedAt
    user
    user__id
    votingEscrowID
    votingEscrowID__id
    votingEscrowID__stakedSupply
}

input VotingEscrow_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [VotingEscrow_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    locks_: VotingEscrowLock_filter
    omniLocks_: OmniVotingEscrowLock_filter
    or: [VotingEscrow_filter]
    stakedSupply: BigDecimal
    stakedSupply_gt: BigDecimal
    stakedSupply_gte: BigDecimal
    stakedSupply_in: [BigDecimal!]
    stakedSupply_lt: BigDecimal
    stakedSupply_lte: BigDecimal
    stakedSupply_not: BigDecimal
    stakedSupply_not_in: [BigDecimal!]
}

enum VotingEscrow_orderBy {
    id
    locks
    omniLocks
    stakedSupply
}

type _Block_ {
    """
    The hash of the block
    """
    hash: Bytes

    """
    The block number
    """
    number: Int!

    """
    The hash of the parent block
    """
    parentHash: Bytes

    """
    Integer representation of the timestamp stored in blocks for the chain
    """
    timestamp: Int
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
    """
    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!

    """
    The deployment ID
    """
    deployment: String!

    """
    If `true`, the subgraph encountered indexing errors at some past block
    """
    hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
    """
    Data will be returned even if the subgraph has indexing errors
    """
    allow

    """
    If the subgraph has indexing errors, data will be omitted. The default.
    """
    deny
}
