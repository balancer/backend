"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""
Defined a Subgraph ID for an object type
"""
directive @subgraphId(id: String!) on OBJECT

enum Aggregation_interval {
    day
    hour
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
    number_gte: Int!
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

scalar Bytes

type DailyPoolSnapshot {
    dailyDeposited: BigDecimal!
    dailyWithdrawn: BigDecimal!
    id: Bytes!
    pool: Pool!
    poolId: Int!
    relicCount: Int!
    snapshotTimestamp: Int!
    totalBalance: BigDecimal!
}

input DailyPoolSnapshot_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [DailyPoolSnapshot_filter]
    dailyDeposited: BigDecimal
    dailyDeposited_gt: BigDecimal
    dailyDeposited_gte: BigDecimal
    dailyDeposited_in: [BigDecimal!]
    dailyDeposited_lt: BigDecimal
    dailyDeposited_lte: BigDecimal
    dailyDeposited_not: BigDecimal
    dailyDeposited_not_in: [BigDecimal!]
    dailyWithdrawn: BigDecimal
    dailyWithdrawn_gt: BigDecimal
    dailyWithdrawn_gte: BigDecimal
    dailyWithdrawn_in: [BigDecimal!]
    dailyWithdrawn_lt: BigDecimal
    dailyWithdrawn_lte: BigDecimal
    dailyWithdrawn_not: BigDecimal
    dailyWithdrawn_not_in: [BigDecimal!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [DailyPoolSnapshot_filter]
    pool: String
    poolId: Int
    poolId_gt: Int
    poolId_gte: Int
    poolId_in: [Int!]
    poolId_lt: Int
    poolId_lte: Int
    poolId_not: Int
    poolId_not_in: [Int!]
    pool_: Pool_filter
    pool_contains: String
    pool_contains_nocase: String
    pool_ends_with: String
    pool_ends_with_nocase: String
    pool_gt: String
    pool_gte: String
    pool_in: [String!]
    pool_lt: String
    pool_lte: String
    pool_not: String
    pool_not_contains: String
    pool_not_contains_nocase: String
    pool_not_ends_with: String
    pool_not_ends_with_nocase: String
    pool_not_in: [String!]
    pool_not_starts_with: String
    pool_not_starts_with_nocase: String
    pool_starts_with: String
    pool_starts_with_nocase: String
    relicCount: Int
    relicCount_gt: Int
    relicCount_gte: Int
    relicCount_in: [Int!]
    relicCount_lt: Int
    relicCount_lte: Int
    relicCount_not: Int
    relicCount_not_in: [Int!]
    snapshotTimestamp: Int
    snapshotTimestamp_gt: Int
    snapshotTimestamp_gte: Int
    snapshotTimestamp_in: [Int!]
    snapshotTimestamp_lt: Int
    snapshotTimestamp_lte: Int
    snapshotTimestamp_not: Int
    snapshotTimestamp_not_in: [Int!]
    totalBalance: BigDecimal
    totalBalance_gt: BigDecimal
    totalBalance_gte: BigDecimal
    totalBalance_in: [BigDecimal!]
    totalBalance_lt: BigDecimal
    totalBalance_lte: BigDecimal
    totalBalance_not: BigDecimal
    totalBalance_not_in: [BigDecimal!]
}

enum DailyPoolSnapshot_orderBy {
    dailyDeposited
    dailyWithdrawn
    id
    pool
    poolId
    pool__allocPoint
    pool__id
    pool__name
    pool__nftDescriptor
    pool__pid
    pool__poolTokenAddress
    pool__relicCount
    pool__totalBalance
    relicCount
    snapshotTimestamp
    totalBalance
}

type DailyRelicSnapshot {
    balance: BigDecimal!
    entryTimestamp: Int!
    id: ID!
    level: Int!
    pool: Pool!
    poolId: Int!
    relic: Relic!
    relicId: Int!
    snapshotTimestamp: Int!
    user: User!
    userAddress: Bytes!
}

input DailyRelicSnapshot_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [DailyRelicSnapshot_filter]
    balance: BigDecimal
    balance_gt: BigDecimal
    balance_gte: BigDecimal
    balance_in: [BigDecimal!]
    balance_lt: BigDecimal
    balance_lte: BigDecimal
    balance_not: BigDecimal
    balance_not_in: [BigDecimal!]
    entryTimestamp: Int
    entryTimestamp_gt: Int
    entryTimestamp_gte: Int
    entryTimestamp_in: [Int!]
    entryTimestamp_lt: Int
    entryTimestamp_lte: Int
    entryTimestamp_not: Int
    entryTimestamp_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    level: Int
    level_gt: Int
    level_gte: Int
    level_in: [Int!]
    level_lt: Int
    level_lte: Int
    level_not: Int
    level_not_in: [Int!]
    or: [DailyRelicSnapshot_filter]
    pool: String
    poolId: Int
    poolId_gt: Int
    poolId_gte: Int
    poolId_in: [Int!]
    poolId_lt: Int
    poolId_lte: Int
    poolId_not: Int
    poolId_not_in: [Int!]
    pool_: Pool_filter
    pool_contains: String
    pool_contains_nocase: String
    pool_ends_with: String
    pool_ends_with_nocase: String
    pool_gt: String
    pool_gte: String
    pool_in: [String!]
    pool_lt: String
    pool_lte: String
    pool_not: String
    pool_not_contains: String
    pool_not_contains_nocase: String
    pool_not_ends_with: String
    pool_not_ends_with_nocase: String
    pool_not_in: [String!]
    pool_not_starts_with: String
    pool_not_starts_with_nocase: String
    pool_starts_with: String
    pool_starts_with_nocase: String
    relic: String
    relicId: Int
    relicId_gt: Int
    relicId_gte: Int
    relicId_in: [Int!]
    relicId_lt: Int
    relicId_lte: Int
    relicId_not: Int
    relicId_not_in: [Int!]
    relic_: Relic_filter
    relic_contains: String
    relic_contains_nocase: String
    relic_ends_with: String
    relic_ends_with_nocase: String
    relic_gt: String
    relic_gte: String
    relic_in: [String!]
    relic_lt: String
    relic_lte: String
    relic_not: String
    relic_not_contains: String
    relic_not_contains_nocase: String
    relic_not_ends_with: String
    relic_not_ends_with_nocase: String
    relic_not_in: [String!]
    relic_not_starts_with: String
    relic_not_starts_with_nocase: String
    relic_starts_with: String
    relic_starts_with_nocase: String
    snapshotTimestamp: Int
    snapshotTimestamp_gt: Int
    snapshotTimestamp_gte: Int
    snapshotTimestamp_in: [Int!]
    snapshotTimestamp_lt: Int
    snapshotTimestamp_lte: Int
    snapshotTimestamp_not: Int
    snapshotTimestamp_not_in: [Int!]
    user: String
    userAddress: Bytes
    userAddress_contains: Bytes
    userAddress_gt: Bytes
    userAddress_gte: Bytes
    userAddress_in: [Bytes!]
    userAddress_lt: Bytes
    userAddress_lte: Bytes
    userAddress_not: Bytes
    userAddress_not_contains: Bytes
    userAddress_not_in: [Bytes!]
    user_: User_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
}

enum DailyRelicSnapshot_orderBy {
    balance
    entryTimestamp
    id
    level
    pool
    poolId
    pool__allocPoint
    pool__id
    pool__name
    pool__nftDescriptor
    pool__pid
    pool__poolTokenAddress
    pool__relicCount
    pool__totalBalance
    relic
    relicId
    relic__balance
    relic__entryTimestamp
    relic__id
    relic__level
    relic__pid
    relic__relicId
    relic__userAddress
    snapshotTimestamp
    user
    userAddress
    user__address
    user__id
}

type EmissionCurve {
    address: Bytes!
    id: Bytes!
    rewardPerSecond: BigDecimal!
}

input EmissionCurve_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    address: Bytes
    address_contains: Bytes
    address_gt: Bytes
    address_gte: Bytes
    address_in: [Bytes!]
    address_lt: Bytes
    address_lte: Bytes
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    and: [EmissionCurve_filter]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [EmissionCurve_filter]
    rewardPerSecond: BigDecimal
    rewardPerSecond_gt: BigDecimal
    rewardPerSecond_gte: BigDecimal
    rewardPerSecond_in: [BigDecimal!]
    rewardPerSecond_lt: BigDecimal
    rewardPerSecond_lte: BigDecimal
    rewardPerSecond_not: BigDecimal
    rewardPerSecond_not_in: [BigDecimal!]
}

enum EmissionCurve_orderBy {
    address
    id
    rewardPerSecond
}

type Harvest {
    amount: BigDecimal!
    id: Bytes!
    relic: Relic!
    reliquary: Reliquary!
    timestamp: Int!
    token: Token!
    user: User!
}

input Harvest_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    amount: BigDecimal
    amount_gt: BigDecimal
    amount_gte: BigDecimal
    amount_in: [BigDecimal!]
    amount_lt: BigDecimal
    amount_lte: BigDecimal
    amount_not: BigDecimal
    amount_not_in: [BigDecimal!]
    and: [Harvest_filter]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [Harvest_filter]
    relic: String
    relic_: Relic_filter
    relic_contains: String
    relic_contains_nocase: String
    relic_ends_with: String
    relic_ends_with_nocase: String
    relic_gt: String
    relic_gte: String
    relic_in: [String!]
    relic_lt: String
    relic_lte: String
    relic_not: String
    relic_not_contains: String
    relic_not_contains_nocase: String
    relic_not_ends_with: String
    relic_not_ends_with_nocase: String
    relic_not_in: [String!]
    relic_not_starts_with: String
    relic_not_starts_with_nocase: String
    relic_starts_with: String
    relic_starts_with_nocase: String
    reliquary: String
    reliquary_: Reliquary_filter
    reliquary_contains: String
    reliquary_contains_nocase: String
    reliquary_ends_with: String
    reliquary_ends_with_nocase: String
    reliquary_gt: String
    reliquary_gte: String
    reliquary_in: [String!]
    reliquary_lt: String
    reliquary_lte: String
    reliquary_not: String
    reliquary_not_contains: String
    reliquary_not_contains_nocase: String
    reliquary_not_ends_with: String
    reliquary_not_ends_with_nocase: String
    reliquary_not_in: [String!]
    reliquary_not_starts_with: String
    reliquary_not_starts_with_nocase: String
    reliquary_starts_with: String
    reliquary_starts_with_nocase: String
    timestamp: Int
    timestamp_gt: Int
    timestamp_gte: Int
    timestamp_in: [Int!]
    timestamp_lt: Int
    timestamp_lte: Int
    timestamp_not: Int
    timestamp_not_in: [Int!]
    token: String
    token_: Token_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
    user: String
    user_: User_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
}

enum Harvest_orderBy {
    amount
    id
    relic
    relic__balance
    relic__entryTimestamp
    relic__id
    relic__level
    relic__pid
    relic__relicId
    relic__userAddress
    reliquary
    reliquary__id
    reliquary__poolCount
    reliquary__relicCount
    reliquary__totalAllocPoint
    timestamp
    token
    token__address
    token__decimals
    token__id
    token__name
    token__symbol
    user
    user__address
    user__id
}

"""
8 bytes signed integer
"""
scalar Int8

"""
Defines the order direction, either ascending or descending
"""
enum OrderDirection {
    asc
    desc
}

type Pool {
    allocPoint: Int!
    dailyPoolSnapshots(
        first: Int = 100
        orderBy: DailyPoolSnapshot_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: DailyPoolSnapshot_filter
    ): [DailyPoolSnapshot!]!
    dailyRelicSnapshots(
        first: Int = 100
        orderBy: DailyRelicSnapshot_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: DailyRelicSnapshot_filter
    ): [DailyRelicSnapshot!]!
    id: Bytes!
    levels(
        first: Int = 100
        orderBy: PoolLevel_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: PoolLevel_filter
    ): [PoolLevel!]!
    name: String!
    nftDescriptor: Bytes!
    pid: Int!
    poolToken: Token!
    poolTokenAddress: Bytes!
    relicCount: Int!
    relics(
        first: Int = 100
        orderBy: Relic_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Relic_filter
    ): [Relic!]!
    reliquary: Reliquary!
    rewarder: Rewarder
    totalBalance: BigDecimal!
}

type PoolLevel {
    allocationPoints: Int!
    balance: BigDecimal!
    id: Bytes!
    level: Int!
    pool: Pool!
    relics(
        first: Int = 100
        orderBy: Relic_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Relic_filter
    ): [Relic!]!
    requiredMaturity: Int!
}

input PoolLevel_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    allocationPoints: Int
    allocationPoints_gt: Int
    allocationPoints_gte: Int
    allocationPoints_in: [Int!]
    allocationPoints_lt: Int
    allocationPoints_lte: Int
    allocationPoints_not: Int
    allocationPoints_not_in: [Int!]
    and: [PoolLevel_filter]
    balance: BigDecimal
    balance_gt: BigDecimal
    balance_gte: BigDecimal
    balance_in: [BigDecimal!]
    balance_lt: BigDecimal
    balance_lte: BigDecimal
    balance_not: BigDecimal
    balance_not_in: [BigDecimal!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    level: Int
    level_gt: Int
    level_gte: Int
    level_in: [Int!]
    level_lt: Int
    level_lte: Int
    level_not: Int
    level_not_in: [Int!]
    or: [PoolLevel_filter]
    pool: String
    pool_: Pool_filter
    pool_contains: String
    pool_contains_nocase: String
    pool_ends_with: String
    pool_ends_with_nocase: String
    pool_gt: String
    pool_gte: String
    pool_in: [String!]
    pool_lt: String
    pool_lte: String
    pool_not: String
    pool_not_contains: String
    pool_not_contains_nocase: String
    pool_not_ends_with: String
    pool_not_ends_with_nocase: String
    pool_not_in: [String!]
    pool_not_starts_with: String
    pool_not_starts_with_nocase: String
    pool_starts_with: String
    pool_starts_with_nocase: String
    relics_: Relic_filter
    requiredMaturity: Int
    requiredMaturity_gt: Int
    requiredMaturity_gte: Int
    requiredMaturity_in: [Int!]
    requiredMaturity_lt: Int
    requiredMaturity_lte: Int
    requiredMaturity_not: Int
    requiredMaturity_not_in: [Int!]
}

enum PoolLevel_orderBy {
    allocationPoints
    balance
    id
    level
    pool
    pool__allocPoint
    pool__id
    pool__name
    pool__nftDescriptor
    pool__pid
    pool__poolTokenAddress
    pool__relicCount
    pool__totalBalance
    relics
    requiredMaturity
}

input Pool_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    allocPoint: Int
    allocPoint_gt: Int
    allocPoint_gte: Int
    allocPoint_in: [Int!]
    allocPoint_lt: Int
    allocPoint_lte: Int
    allocPoint_not: Int
    allocPoint_not_in: [Int!]
    and: [Pool_filter]
    dailyPoolSnapshots_: DailyPoolSnapshot_filter
    dailyRelicSnapshots_: DailyRelicSnapshot_filter
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    levels_: PoolLevel_filter
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    nftDescriptor: Bytes
    nftDescriptor_contains: Bytes
    nftDescriptor_gt: Bytes
    nftDescriptor_gte: Bytes
    nftDescriptor_in: [Bytes!]
    nftDescriptor_lt: Bytes
    nftDescriptor_lte: Bytes
    nftDescriptor_not: Bytes
    nftDescriptor_not_contains: Bytes
    nftDescriptor_not_in: [Bytes!]
    or: [Pool_filter]
    pid: Int
    pid_gt: Int
    pid_gte: Int
    pid_in: [Int!]
    pid_lt: Int
    pid_lte: Int
    pid_not: Int
    pid_not_in: [Int!]
    poolToken: String
    poolTokenAddress: Bytes
    poolTokenAddress_contains: Bytes
    poolTokenAddress_gt: Bytes
    poolTokenAddress_gte: Bytes
    poolTokenAddress_in: [Bytes!]
    poolTokenAddress_lt: Bytes
    poolTokenAddress_lte: Bytes
    poolTokenAddress_not: Bytes
    poolTokenAddress_not_contains: Bytes
    poolTokenAddress_not_in: [Bytes!]
    poolToken_: Token_filter
    poolToken_contains: String
    poolToken_contains_nocase: String
    poolToken_ends_with: String
    poolToken_ends_with_nocase: String
    poolToken_gt: String
    poolToken_gte: String
    poolToken_in: [String!]
    poolToken_lt: String
    poolToken_lte: String
    poolToken_not: String
    poolToken_not_contains: String
    poolToken_not_contains_nocase: String
    poolToken_not_ends_with: String
    poolToken_not_ends_with_nocase: String
    poolToken_not_in: [String!]
    poolToken_not_starts_with: String
    poolToken_not_starts_with_nocase: String
    poolToken_starts_with: String
    poolToken_starts_with_nocase: String
    relicCount: Int
    relicCount_gt: Int
    relicCount_gte: Int
    relicCount_in: [Int!]
    relicCount_lt: Int
    relicCount_lte: Int
    relicCount_not: Int
    relicCount_not_in: [Int!]
    relics_: Relic_filter
    reliquary: String
    reliquary_: Reliquary_filter
    reliquary_contains: String
    reliquary_contains_nocase: String
    reliquary_ends_with: String
    reliquary_ends_with_nocase: String
    reliquary_gt: String
    reliquary_gte: String
    reliquary_in: [String!]
    reliquary_lt: String
    reliquary_lte: String
    reliquary_not: String
    reliquary_not_contains: String
    reliquary_not_contains_nocase: String
    reliquary_not_ends_with: String
    reliquary_not_ends_with_nocase: String
    reliquary_not_in: [String!]
    reliquary_not_starts_with: String
    reliquary_not_starts_with_nocase: String
    reliquary_starts_with: String
    reliquary_starts_with_nocase: String
    rewarder: String
    rewarder_: Rewarder_filter
    rewarder_contains: String
    rewarder_contains_nocase: String
    rewarder_ends_with: String
    rewarder_ends_with_nocase: String
    rewarder_gt: String
    rewarder_gte: String
    rewarder_in: [String!]
    rewarder_lt: String
    rewarder_lte: String
    rewarder_not: String
    rewarder_not_contains: String
    rewarder_not_contains_nocase: String
    rewarder_not_ends_with: String
    rewarder_not_ends_with_nocase: String
    rewarder_not_in: [String!]
    rewarder_not_starts_with: String
    rewarder_not_starts_with_nocase: String
    rewarder_starts_with: String
    rewarder_starts_with_nocase: String
    totalBalance: BigDecimal
    totalBalance_gt: BigDecimal
    totalBalance_gte: BigDecimal
    totalBalance_in: [BigDecimal!]
    totalBalance_lt: BigDecimal
    totalBalance_lte: BigDecimal
    totalBalance_not: BigDecimal
    totalBalance_not_in: [BigDecimal!]
}

enum Pool_orderBy {
    allocPoint
    dailyPoolSnapshots
    dailyRelicSnapshots
    id
    levels
    name
    nftDescriptor
    pid
    poolToken
    poolTokenAddress
    poolToken__address
    poolToken__decimals
    poolToken__id
    poolToken__name
    poolToken__symbol
    relicCount
    relics
    reliquary
    reliquary__id
    reliquary__poolCount
    reliquary__relicCount
    reliquary__totalAllocPoint
    rewarder
    rewarder__id
    totalBalance
}

type Query {
    """
    Access to subgraph metadata
    """
    _meta(block: Block_height): _Meta_
    dailyPoolSnapshot(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DailyPoolSnapshot
    dailyPoolSnapshots(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: DailyPoolSnapshot_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: DailyPoolSnapshot_filter
    ): [DailyPoolSnapshot!]!
    dailyRelicSnapshot(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DailyRelicSnapshot
    dailyRelicSnapshots(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: DailyRelicSnapshot_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: DailyRelicSnapshot_filter
    ): [DailyRelicSnapshot!]!
    emissionCurve(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): EmissionCurve
    emissionCurves(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: EmissionCurve_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: EmissionCurve_filter
    ): [EmissionCurve!]!
    harvest(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Harvest
    harvests(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Harvest_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Harvest_filter
    ): [Harvest!]!
    pool(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Pool
    poolLevel(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PoolLevel
    poolLevels(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: PoolLevel_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: PoolLevel_filter
    ): [PoolLevel!]!
    pools(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Pool_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Pool_filter
    ): [Pool!]!
    relic(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Relic
    relics(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Relic_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Relic_filter
    ): [Relic!]!
    reliquaries(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Reliquary_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Reliquary_filter
    ): [Reliquary!]!
    reliquary(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Reliquary
    rewarder(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Rewarder
    rewarderEmission(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RewarderEmission
    rewarderEmissions(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: RewarderEmission_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: RewarderEmission_filter
    ): [RewarderEmission!]!
    rewarders(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Rewarder_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Rewarder_filter
    ): [Rewarder!]!
    token(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Token
    tokens(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Token_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Token_filter
    ): [Token!]!
    user(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): User
    users(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: User_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: User_filter
    ): [User!]!
}

type Relic {
    balance: BigDecimal!
    dailyRelicSnapshots(
        first: Int = 100
        orderBy: DailyRelicSnapshot_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: DailyRelicSnapshot_filter
    ): [DailyRelicSnapshot!]!
    entryTimestamp: Int!
    harvests(
        first: Int = 100
        orderBy: Harvest_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Harvest_filter
    ): [Harvest!]!
    id: Bytes!
    level: Int!
    pid: Int!
    pool: Pool!
    poolLevel: PoolLevel!
    relicId: Int!
    reliquary: Reliquary!
    user: User!
    userAddress: Bytes!
}

input Relic_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [Relic_filter]
    balance: BigDecimal
    balance_gt: BigDecimal
    balance_gte: BigDecimal
    balance_in: [BigDecimal!]
    balance_lt: BigDecimal
    balance_lte: BigDecimal
    balance_not: BigDecimal
    balance_not_in: [BigDecimal!]
    dailyRelicSnapshots_: DailyRelicSnapshot_filter
    entryTimestamp: Int
    entryTimestamp_gt: Int
    entryTimestamp_gte: Int
    entryTimestamp_in: [Int!]
    entryTimestamp_lt: Int
    entryTimestamp_lte: Int
    entryTimestamp_not: Int
    entryTimestamp_not_in: [Int!]
    harvests_: Harvest_filter
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    level: Int
    level_gt: Int
    level_gte: Int
    level_in: [Int!]
    level_lt: Int
    level_lte: Int
    level_not: Int
    level_not_in: [Int!]
    or: [Relic_filter]
    pid: Int
    pid_gt: Int
    pid_gte: Int
    pid_in: [Int!]
    pid_lt: Int
    pid_lte: Int
    pid_not: Int
    pid_not_in: [Int!]
    pool: String
    poolLevel: String
    poolLevel_: PoolLevel_filter
    poolLevel_contains: String
    poolLevel_contains_nocase: String
    poolLevel_ends_with: String
    poolLevel_ends_with_nocase: String
    poolLevel_gt: String
    poolLevel_gte: String
    poolLevel_in: [String!]
    poolLevel_lt: String
    poolLevel_lte: String
    poolLevel_not: String
    poolLevel_not_contains: String
    poolLevel_not_contains_nocase: String
    poolLevel_not_ends_with: String
    poolLevel_not_ends_with_nocase: String
    poolLevel_not_in: [String!]
    poolLevel_not_starts_with: String
    poolLevel_not_starts_with_nocase: String
    poolLevel_starts_with: String
    poolLevel_starts_with_nocase: String
    pool_: Pool_filter
    pool_contains: String
    pool_contains_nocase: String
    pool_ends_with: String
    pool_ends_with_nocase: String
    pool_gt: String
    pool_gte: String
    pool_in: [String!]
    pool_lt: String
    pool_lte: String
    pool_not: String
    pool_not_contains: String
    pool_not_contains_nocase: String
    pool_not_ends_with: String
    pool_not_ends_with_nocase: String
    pool_not_in: [String!]
    pool_not_starts_with: String
    pool_not_starts_with_nocase: String
    pool_starts_with: String
    pool_starts_with_nocase: String
    relicId: Int
    relicId_gt: Int
    relicId_gte: Int
    relicId_in: [Int!]
    relicId_lt: Int
    relicId_lte: Int
    relicId_not: Int
    relicId_not_in: [Int!]
    reliquary: String
    reliquary_: Reliquary_filter
    reliquary_contains: String
    reliquary_contains_nocase: String
    reliquary_ends_with: String
    reliquary_ends_with_nocase: String
    reliquary_gt: String
    reliquary_gte: String
    reliquary_in: [String!]
    reliquary_lt: String
    reliquary_lte: String
    reliquary_not: String
    reliquary_not_contains: String
    reliquary_not_contains_nocase: String
    reliquary_not_ends_with: String
    reliquary_not_ends_with_nocase: String
    reliquary_not_in: [String!]
    reliquary_not_starts_with: String
    reliquary_not_starts_with_nocase: String
    reliquary_starts_with: String
    reliquary_starts_with_nocase: String
    user: String
    userAddress: Bytes
    userAddress_contains: Bytes
    userAddress_gt: Bytes
    userAddress_gte: Bytes
    userAddress_in: [Bytes!]
    userAddress_lt: Bytes
    userAddress_lte: Bytes
    userAddress_not: Bytes
    userAddress_not_contains: Bytes
    userAddress_not_in: [Bytes!]
    user_: User_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
}

enum Relic_orderBy {
    balance
    dailyRelicSnapshots
    entryTimestamp
    harvests
    id
    level
    pid
    pool
    poolLevel
    poolLevel__allocationPoints
    poolLevel__balance
    poolLevel__id
    poolLevel__level
    poolLevel__requiredMaturity
    pool__allocPoint
    pool__id
    pool__name
    pool__nftDescriptor
    pool__pid
    pool__poolTokenAddress
    pool__relicCount
    pool__totalBalance
    relicId
    reliquary
    reliquary__id
    reliquary__poolCount
    reliquary__relicCount
    reliquary__totalAllocPoint
    user
    userAddress
    user__address
    user__id
}

type Reliquary {
    emissionCurve: EmissionCurve!
    emissionToken: Token!
    harvests(
        first: Int = 100
        orderBy: Harvest_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Harvest_filter
    ): [Harvest!]!
    id: Bytes!
    poolCount: Int!
    pools(
        first: Int = 100
        orderBy: Pool_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Pool_filter
    ): [Pool!]
    relicCount: Int!
    relics(
        first: Int = 100
        orderBy: Relic_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Relic_filter
    ): [Relic!]!
    totalAllocPoint: Int!
    users(
        first: Int = 100
        orderBy: User_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: User_filter
    ): [User!]
}

input Reliquary_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [Reliquary_filter]
    emissionCurve: String
    emissionCurve_: EmissionCurve_filter
    emissionCurve_contains: String
    emissionCurve_contains_nocase: String
    emissionCurve_ends_with: String
    emissionCurve_ends_with_nocase: String
    emissionCurve_gt: String
    emissionCurve_gte: String
    emissionCurve_in: [String!]
    emissionCurve_lt: String
    emissionCurve_lte: String
    emissionCurve_not: String
    emissionCurve_not_contains: String
    emissionCurve_not_contains_nocase: String
    emissionCurve_not_ends_with: String
    emissionCurve_not_ends_with_nocase: String
    emissionCurve_not_in: [String!]
    emissionCurve_not_starts_with: String
    emissionCurve_not_starts_with_nocase: String
    emissionCurve_starts_with: String
    emissionCurve_starts_with_nocase: String
    emissionToken: String
    emissionToken_: Token_filter
    emissionToken_contains: String
    emissionToken_contains_nocase: String
    emissionToken_ends_with: String
    emissionToken_ends_with_nocase: String
    emissionToken_gt: String
    emissionToken_gte: String
    emissionToken_in: [String!]
    emissionToken_lt: String
    emissionToken_lte: String
    emissionToken_not: String
    emissionToken_not_contains: String
    emissionToken_not_contains_nocase: String
    emissionToken_not_ends_with: String
    emissionToken_not_ends_with_nocase: String
    emissionToken_not_in: [String!]
    emissionToken_not_starts_with: String
    emissionToken_not_starts_with_nocase: String
    emissionToken_starts_with: String
    emissionToken_starts_with_nocase: String
    harvests_: Harvest_filter
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [Reliquary_filter]
    poolCount: Int
    poolCount_gt: Int
    poolCount_gte: Int
    poolCount_in: [Int!]
    poolCount_lt: Int
    poolCount_lte: Int
    poolCount_not: Int
    poolCount_not_in: [Int!]
    pools_: Pool_filter
    relicCount: Int
    relicCount_gt: Int
    relicCount_gte: Int
    relicCount_in: [Int!]
    relicCount_lt: Int
    relicCount_lte: Int
    relicCount_not: Int
    relicCount_not_in: [Int!]
    relics_: Relic_filter
    totalAllocPoint: Int
    totalAllocPoint_gt: Int
    totalAllocPoint_gte: Int
    totalAllocPoint_in: [Int!]
    totalAllocPoint_lt: Int
    totalAllocPoint_lte: Int
    totalAllocPoint_not: Int
    totalAllocPoint_not_in: [Int!]
    users_: User_filter
}

enum Reliquary_orderBy {
    emissionCurve
    emissionCurve__address
    emissionCurve__id
    emissionCurve__rewardPerSecond
    emissionToken
    emissionToken__address
    emissionToken__decimals
    emissionToken__id
    emissionToken__name
    emissionToken__symbol
    harvests
    id
    poolCount
    pools
    relicCount
    relics
    totalAllocPoint
    users
}

type Rewarder {
    emissions(
        first: Int = 100
        orderBy: RewarderEmission_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: RewarderEmission_filter
    ): [RewarderEmission!]!
    id: Bytes!
}

type RewarderEmission {
    id: Bytes!
    rewardPerSecond: BigDecimal!
    rewardToken: Token!
    rewardTokenAddress: Bytes!
    rewarder: Rewarder!
}

input RewarderEmission_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [RewarderEmission_filter]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [RewarderEmission_filter]
    rewardPerSecond: BigDecimal
    rewardPerSecond_gt: BigDecimal
    rewardPerSecond_gte: BigDecimal
    rewardPerSecond_in: [BigDecimal!]
    rewardPerSecond_lt: BigDecimal
    rewardPerSecond_lte: BigDecimal
    rewardPerSecond_not: BigDecimal
    rewardPerSecond_not_in: [BigDecimal!]
    rewardToken: String
    rewardTokenAddress: Bytes
    rewardTokenAddress_contains: Bytes
    rewardTokenAddress_gt: Bytes
    rewardTokenAddress_gte: Bytes
    rewardTokenAddress_in: [Bytes!]
    rewardTokenAddress_lt: Bytes
    rewardTokenAddress_lte: Bytes
    rewardTokenAddress_not: Bytes
    rewardTokenAddress_not_contains: Bytes
    rewardTokenAddress_not_in: [Bytes!]
    rewardToken_: Token_filter
    rewardToken_contains: String
    rewardToken_contains_nocase: String
    rewardToken_ends_with: String
    rewardToken_ends_with_nocase: String
    rewardToken_gt: String
    rewardToken_gte: String
    rewardToken_in: [String!]
    rewardToken_lt: String
    rewardToken_lte: String
    rewardToken_not: String
    rewardToken_not_contains: String
    rewardToken_not_contains_nocase: String
    rewardToken_not_ends_with: String
    rewardToken_not_ends_with_nocase: String
    rewardToken_not_in: [String!]
    rewardToken_not_starts_with: String
    rewardToken_not_starts_with_nocase: String
    rewardToken_starts_with: String
    rewardToken_starts_with_nocase: String
    rewarder: String
    rewarder_: Rewarder_filter
    rewarder_contains: String
    rewarder_contains_nocase: String
    rewarder_ends_with: String
    rewarder_ends_with_nocase: String
    rewarder_gt: String
    rewarder_gte: String
    rewarder_in: [String!]
    rewarder_lt: String
    rewarder_lte: String
    rewarder_not: String
    rewarder_not_contains: String
    rewarder_not_contains_nocase: String
    rewarder_not_ends_with: String
    rewarder_not_ends_with_nocase: String
    rewarder_not_in: [String!]
    rewarder_not_starts_with: String
    rewarder_not_starts_with_nocase: String
    rewarder_starts_with: String
    rewarder_starts_with_nocase: String
}

enum RewarderEmission_orderBy {
    id
    rewardPerSecond
    rewardToken
    rewardTokenAddress
    rewardToken__address
    rewardToken__decimals
    rewardToken__id
    rewardToken__name
    rewardToken__symbol
    rewarder
    rewarder__id
}

input Rewarder_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [Rewarder_filter]
    emissions_: RewarderEmission_filter
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [Rewarder_filter]
}

enum Rewarder_orderBy {
    emissions
    id
}

type Subscription {
    """
    Access to subgraph metadata
    """
    _meta(block: Block_height): _Meta_
    dailyPoolSnapshot(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DailyPoolSnapshot
    dailyPoolSnapshots(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: DailyPoolSnapshot_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: DailyPoolSnapshot_filter
    ): [DailyPoolSnapshot!]!
    dailyRelicSnapshot(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DailyRelicSnapshot
    dailyRelicSnapshots(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: DailyRelicSnapshot_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: DailyRelicSnapshot_filter
    ): [DailyRelicSnapshot!]!
    emissionCurve(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): EmissionCurve
    emissionCurves(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: EmissionCurve_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: EmissionCurve_filter
    ): [EmissionCurve!]!
    harvest(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Harvest
    harvests(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Harvest_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Harvest_filter
    ): [Harvest!]!
    pool(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Pool
    poolLevel(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PoolLevel
    poolLevels(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: PoolLevel_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: PoolLevel_filter
    ): [PoolLevel!]!
    pools(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Pool_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Pool_filter
    ): [Pool!]!
    relic(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Relic
    relics(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Relic_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Relic_filter
    ): [Relic!]!
    reliquaries(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Reliquary_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Reliquary_filter
    ): [Reliquary!]!
    reliquary(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Reliquary
    rewarder(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Rewarder
    rewarderEmission(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RewarderEmission
    rewarderEmissions(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: RewarderEmission_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: RewarderEmission_filter
    ): [RewarderEmission!]!
    rewarders(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Rewarder_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Rewarder_filter
    ): [Rewarder!]!
    token(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Token
    tokens(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Token_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Token_filter
    ): [Token!]!
    user(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): User
    users(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: User_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: User_filter
    ): [User!]!
}

"""
A string representation of microseconds UNIX timestamp (16 digits)
"""
scalar Timestamp

type Token {
    address: Bytes!
    decimals: Int!
    id: Bytes!
    name: String!
    symbol: String!
}

input Token_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    address: Bytes
    address_contains: Bytes
    address_gt: Bytes
    address_gte: Bytes
    address_in: [Bytes!]
    address_lt: Bytes
    address_lte: Bytes
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    and: [Token_filter]
    decimals: Int
    decimals_gt: Int
    decimals_gte: Int
    decimals_in: [Int!]
    decimals_lt: Int
    decimals_lte: Int
    decimals_not: Int
    decimals_not_in: [Int!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    or: [Token_filter]
    symbol: String
    symbol_contains: String
    symbol_contains_nocase: String
    symbol_ends_with: String
    symbol_ends_with_nocase: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_contains_nocase: String
    symbol_not_ends_with: String
    symbol_not_ends_with_nocase: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_not_starts_with_nocase: String
    symbol_starts_with: String
    symbol_starts_with_nocase: String
}

enum Token_orderBy {
    address
    decimals
    id
    name
    symbol
}

type User {
    address: Bytes!
    dailyRelicSnapshots(
        first: Int = 100
        orderBy: DailyRelicSnapshot_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: DailyRelicSnapshot_filter
    ): [DailyRelicSnapshot!]!
    id: Bytes!
    relics(
        first: Int = 100
        orderBy: Relic_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Relic_filter
    ): [Relic!]!
    reliquary: Reliquary!
}

input User_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    address: Bytes
    address_contains: Bytes
    address_gt: Bytes
    address_gte: Bytes
    address_in: [Bytes!]
    address_lt: Bytes
    address_lte: Bytes
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    and: [User_filter]
    dailyRelicSnapshots_: DailyRelicSnapshot_filter
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [User_filter]
    relics_: Relic_filter
    reliquary: String
    reliquary_: Reliquary_filter
    reliquary_contains: String
    reliquary_contains_nocase: String
    reliquary_ends_with: String
    reliquary_ends_with_nocase: String
    reliquary_gt: String
    reliquary_gte: String
    reliquary_in: [String!]
    reliquary_lt: String
    reliquary_lte: String
    reliquary_not: String
    reliquary_not_contains: String
    reliquary_not_contains_nocase: String
    reliquary_not_ends_with: String
    reliquary_not_ends_with_nocase: String
    reliquary_not_in: [String!]
    reliquary_not_starts_with: String
    reliquary_not_starts_with_nocase: String
    reliquary_starts_with: String
    reliquary_starts_with_nocase: String
}

enum User_orderBy {
    address
    dailyRelicSnapshots
    id
    relics
    reliquary
    reliquary__id
    reliquary__poolCount
    reliquary__relicCount
    reliquary__totalAllocPoint
}

type _Block_ {
    """
    The hash of the block
    """
    hash: Bytes

    """
    The block number
    """
    number: Int!

    """
    The hash of the parent block
    """
    parentHash: Bytes

    """
    Integer representation of the timestamp stored in blocks for the chain
    """
    timestamp: Int
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
    """
    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!

    """
    The deployment ID
    """
    deployment: String!

    """
    If `true`, the subgraph encountered indexing errors at some past block
    """
    hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
    """
    Data will be returned even if the subgraph has indexing errors
    """
    allow

    """
    If the subgraph has indexing errors, data will be omitted. The default.
    """
    deny
}
