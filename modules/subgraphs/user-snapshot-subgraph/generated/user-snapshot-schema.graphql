"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""
Defined a Subgraph ID for an object type
"""
directive @subgraphId(id: String!) on OBJECT

enum Aggregation_interval {
    day
    hour
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
    number_gte: Int!
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

scalar Bytes

type Gauge {
    id: ID!
    symbol: String!

    """
     Token addess
    """
    token: Token!
    userGaugeBalances(
        first: Int = 100
        orderBy: UserGaugeBalance_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: UserGaugeBalance_filter
    ): [UserGaugeBalance!]
}

input Gauge_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [Gauge_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [Gauge_filter]
    symbol: String
    symbol_contains: String
    symbol_contains_nocase: String
    symbol_ends_with: String
    symbol_ends_with_nocase: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_contains_nocase: String
    symbol_not_ends_with: String
    symbol_not_ends_with_nocase: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_not_starts_with_nocase: String
    symbol_starts_with: String
    symbol_starts_with_nocase: String
    token: String
    token_: Token_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
    userGaugeBalances_: UserGaugeBalance_filter
}

enum Gauge_orderBy {
    id
    symbol
    token
    token__address
    token__decimals
    token__id
    token__name
    token__symbol
    userGaugeBalances
}

"""
8 bytes signed integer
"""
scalar Int8

type MasterChefFarm {
    id: ID!
    token: Token!
    userFarmBalances(
        first: Int = 100
        orderBy: UserMasterChefFarmBalance_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: UserMasterChefFarmBalance_filter
    ): [UserMasterChefFarmBalance!]
}

input MasterChefFarm_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [MasterChefFarm_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [MasterChefFarm_filter]
    token: String
    token_: Token_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
    userFarmBalances_: UserMasterChefFarmBalance_filter
}

enum MasterChefFarm_orderBy {
    id
    token
    token__address
    token__decimals
    token__id
    token__name
    token__symbol
    userFarmBalances
}

"""
Defines the order direction, either ascending or descending
"""
enum OrderDirection {
    asc
    desc
}

type Query {
    """
    Access to subgraph metadata
    """
    _meta(block: Block_height): _Meta_
    gauge(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Gauge
    gauges(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Gauge_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Gauge_filter
    ): [Gauge!]!
    masterChefFarm(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): MasterChefFarm
    masterChefFarms(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: MasterChefFarm_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: MasterChefFarm_filter
    ): [MasterChefFarm!]!
    token(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Token
    tokenEvent(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenEvent
    tokenEvents(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: TokenEvent_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: TokenEvent_filter
    ): [TokenEvent!]!
    tokens(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Token_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Token_filter
    ): [Token!]!
    transferEvent(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TransferEvent
    transferEvents(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: TransferEvent_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: TransferEvent_filter
    ): [TransferEvent!]!
    user(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): User
    userBalanceSnapshot(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UserBalanceSnapshot
    userBalanceSnapshots(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: UserBalanceSnapshot_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: UserBalanceSnapshot_filter
    ): [UserBalanceSnapshot!]!
    userGaugeBalance(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UserGaugeBalance
    userGaugeBalances(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: UserGaugeBalance_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: UserGaugeBalance_filter
    ): [UserGaugeBalance!]!
    userMasterChefFarmBalance(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UserMasterChefFarmBalance
    userMasterChefFarmBalances(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: UserMasterChefFarmBalance_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: UserMasterChefFarmBalance_filter
    ): [UserMasterChefFarmBalance!]!
    userWalletBalance(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UserWalletBalance
    userWalletBalances(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: UserWalletBalance_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: UserWalletBalance_filter
    ): [UserWalletBalance!]!
    users(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: User_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: User_filter
    ): [User!]!
}

type Subscription {
    """
    Access to subgraph metadata
    """
    _meta(block: Block_height): _Meta_
    gauge(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Gauge
    gauges(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Gauge_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Gauge_filter
    ): [Gauge!]!
    masterChefFarm(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): MasterChefFarm
    masterChefFarms(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: MasterChefFarm_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: MasterChefFarm_filter
    ): [MasterChefFarm!]!
    token(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Token
    tokenEvent(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenEvent
    tokenEvents(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: TokenEvent_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: TokenEvent_filter
    ): [TokenEvent!]!
    tokens(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Token_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Token_filter
    ): [Token!]!
    transferEvent(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TransferEvent
    transferEvents(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: TransferEvent_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: TransferEvent_filter
    ): [TransferEvent!]!
    user(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): User
    userBalanceSnapshot(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UserBalanceSnapshot
    userBalanceSnapshots(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: UserBalanceSnapshot_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: UserBalanceSnapshot_filter
    ): [UserBalanceSnapshot!]!
    userGaugeBalance(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UserGaugeBalance
    userGaugeBalances(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: UserGaugeBalance_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: UserGaugeBalance_filter
    ): [UserGaugeBalance!]!
    userMasterChefFarmBalance(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UserMasterChefFarmBalance
    userMasterChefFarmBalances(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: UserMasterChefFarmBalance_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: UserMasterChefFarmBalance_filter
    ): [UserMasterChefFarmBalance!]!
    userWalletBalance(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UserWalletBalance
    userWalletBalances(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: UserWalletBalance_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: UserWalletBalance_filter
    ): [UserWalletBalance!]!
    users(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: User_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: User_filter
    ): [User!]!
}

"""
A string representation of microseconds UNIX timestamp (16 digits)
"""
scalar Timestamp

type Token {
    """
     Token address
    """
    address: Bytes!

    """
     Number of decimals the token uses
    """
    decimals: Int!

    """
     List of token events
    """
    events(
        first: Int = 100
        orderBy: TokenEvent_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: TokenEvent_filter
    ): [TokenEvent!]!
    id: ID!

    """
     Human-readable name of the token
    """
    name: String!

    """
     Symbol of the token
    """
    symbol: String!
}

interface TokenEvent {
    amount: BigDecimal!
    block: BigInt!
    id: ID!
    sender: Bytes!
    timestamp: BigInt!
    token: Token!
    transaction: Bytes!
}

input TokenEvent_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    amount: BigDecimal
    amount_gt: BigDecimal
    amount_gte: BigDecimal
    amount_in: [BigDecimal!]
    amount_lt: BigDecimal
    amount_lte: BigDecimal
    amount_not: BigDecimal
    amount_not_in: [BigDecimal!]
    and: [TokenEvent_filter]
    block: BigInt
    block_gt: BigInt
    block_gte: BigInt
    block_in: [BigInt!]
    block_lt: BigInt
    block_lte: BigInt
    block_not: BigInt
    block_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [TokenEvent_filter]
    sender: Bytes
    sender_contains: Bytes
    sender_gt: Bytes
    sender_gte: Bytes
    sender_in: [Bytes!]
    sender_lt: Bytes
    sender_lte: Bytes
    sender_not: Bytes
    sender_not_contains: Bytes
    sender_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    token: String
    token_: Token_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
    transaction: Bytes
    transaction_contains: Bytes
    transaction_gt: Bytes
    transaction_gte: Bytes
    transaction_in: [Bytes!]
    transaction_lt: Bytes
    transaction_lte: Bytes
    transaction_not: Bytes
    transaction_not_contains: Bytes
    transaction_not_in: [Bytes!]
}

enum TokenEvent_orderBy {
    amount
    block
    id
    sender
    timestamp
    token
    token__address
    token__decimals
    token__id
    token__name
    token__symbol
    transaction
}

input Token_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    address: Bytes
    address_contains: Bytes
    address_gt: Bytes
    address_gte: Bytes
    address_in: [Bytes!]
    address_lt: Bytes
    address_lte: Bytes
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    and: [Token_filter]
    decimals: Int
    decimals_gt: Int
    decimals_gte: Int
    decimals_in: [Int!]
    decimals_lt: Int
    decimals_lte: Int
    decimals_not: Int
    decimals_not_in: [Int!]
    events_: TokenEvent_filter
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    or: [Token_filter]
    symbol: String
    symbol_contains: String
    symbol_contains_nocase: String
    symbol_ends_with: String
    symbol_ends_with_nocase: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_contains_nocase: String
    symbol_not_ends_with: String
    symbol_not_ends_with_nocase: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_not_starts_with_nocase: String
    symbol_starts_with: String
    symbol_starts_with_nocase: String
}

enum Token_orderBy {
    address
    decimals
    events
    id
    name
    symbol
}

type TransferEvent implements TokenEvent {
    """
     Quantity of tokens transferred
    """
    amount: BigDecimal!

    """
     Block number
    """
    block: BigInt!

    """
     Address of destination account
    """
    destination: Bytes!
    id: ID!

    """
     Transaction sender address
    """
    sender: Bytes!

    """
     Address of source account
    """
    source: Bytes!

    """
     Event timestamp
    """
    timestamp: BigInt!

    """
     Token address
    """
    token: Token!

    """
     Transaction hash
    """
    transaction: Bytes!
}

input TransferEvent_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    amount: BigDecimal
    amount_gt: BigDecimal
    amount_gte: BigDecimal
    amount_in: [BigDecimal!]
    amount_lt: BigDecimal
    amount_lte: BigDecimal
    amount_not: BigDecimal
    amount_not_in: [BigDecimal!]
    and: [TransferEvent_filter]
    block: BigInt
    block_gt: BigInt
    block_gte: BigInt
    block_in: [BigInt!]
    block_lt: BigInt
    block_lte: BigInt
    block_not: BigInt
    block_not_in: [BigInt!]
    destination: Bytes
    destination_contains: Bytes
    destination_gt: Bytes
    destination_gte: Bytes
    destination_in: [Bytes!]
    destination_lt: Bytes
    destination_lte: Bytes
    destination_not: Bytes
    destination_not_contains: Bytes
    destination_not_in: [Bytes!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [TransferEvent_filter]
    sender: Bytes
    sender_contains: Bytes
    sender_gt: Bytes
    sender_gte: Bytes
    sender_in: [Bytes!]
    sender_lt: Bytes
    sender_lte: Bytes
    sender_not: Bytes
    sender_not_contains: Bytes
    sender_not_in: [Bytes!]
    source: Bytes
    source_contains: Bytes
    source_gt: Bytes
    source_gte: Bytes
    source_in: [Bytes!]
    source_lt: Bytes
    source_lte: Bytes
    source_not: Bytes
    source_not_contains: Bytes
    source_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    token: String
    token_: Token_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
    transaction: Bytes
    transaction_contains: Bytes
    transaction_gt: Bytes
    transaction_gte: Bytes
    transaction_in: [Bytes!]
    transaction_lt: Bytes
    transaction_lte: Bytes
    transaction_not: Bytes
    transaction_not_contains: Bytes
    transaction_not_in: [Bytes!]
}

enum TransferEvent_orderBy {
    amount
    block
    destination
    id
    sender
    source
    timestamp
    token
    token__address
    token__decimals
    token__id
    token__name
    token__symbol
    transaction
}

type User {
    """
     User address
    """
    address: Bytes!

    """
     Token balances that this user has staked in farms
    """
    farmBalances(
        first: Int = 100
        orderBy: UserMasterChefFarmBalance_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: UserMasterChefFarmBalance_filter
    ): [UserMasterChefFarmBalance!]!
    farms: [String!]!

    """
     Token balances that this user has staked in gauges
    """
    gaugeBalances(
        first: Int = 100
        orderBy: UserGaugeBalance_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: UserGaugeBalance_filter
    ): [UserGaugeBalance!]!
    gauges: [Bytes!]!

    """
     Equals to: <userAddress>
    """
    id: ID!

    """
     Token balances that this user holds in their wallet
    """
    walletBalances(
        first: Int = 100
        orderBy: UserWalletBalance_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: UserWalletBalance_filter
    ): [UserWalletBalance!]!
    walletTokens: [Bytes!]!
}

type UserBalanceSnapshot {
    farmBalances: [BigDecimal!]!
    farms: [String!]!
    gaugeBalances: [BigDecimal!]!
    gauges: [Bytes!]!

    """
     Equals to: <userAddress>-<dayTimestamp>
    """
    id: ID!

    """
     Timestamp in seconds, rounded down to the closest day
    """
    timestamp: Int!

    """
     Account address
    """
    user: User!
    walletBalances: [BigDecimal!]!
    walletTokens: [Bytes!]!
}

input UserBalanceSnapshot_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [UserBalanceSnapshot_filter]
    farmBalances: [BigDecimal!]
    farmBalances_contains: [BigDecimal!]
    farmBalances_contains_nocase: [BigDecimal!]
    farmBalances_not: [BigDecimal!]
    farmBalances_not_contains: [BigDecimal!]
    farmBalances_not_contains_nocase: [BigDecimal!]
    farms: [String!]
    farms_contains: [String!]
    farms_contains_nocase: [String!]
    farms_not: [String!]
    farms_not_contains: [String!]
    farms_not_contains_nocase: [String!]
    gaugeBalances: [BigDecimal!]
    gaugeBalances_contains: [BigDecimal!]
    gaugeBalances_contains_nocase: [BigDecimal!]
    gaugeBalances_not: [BigDecimal!]
    gaugeBalances_not_contains: [BigDecimal!]
    gaugeBalances_not_contains_nocase: [BigDecimal!]
    gauges: [Bytes!]
    gauges_contains: [Bytes!]
    gauges_contains_nocase: [Bytes!]
    gauges_not: [Bytes!]
    gauges_not_contains: [Bytes!]
    gauges_not_contains_nocase: [Bytes!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [UserBalanceSnapshot_filter]
    timestamp: Int
    timestamp_gt: Int
    timestamp_gte: Int
    timestamp_in: [Int!]
    timestamp_lt: Int
    timestamp_lte: Int
    timestamp_not: Int
    timestamp_not_in: [Int!]
    user: String
    user_: User_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
    walletBalances: [BigDecimal!]
    walletBalances_contains: [BigDecimal!]
    walletBalances_contains_nocase: [BigDecimal!]
    walletBalances_not: [BigDecimal!]
    walletBalances_not_contains: [BigDecimal!]
    walletBalances_not_contains_nocase: [BigDecimal!]
    walletTokens: [Bytes!]
    walletTokens_contains: [Bytes!]
    walletTokens_contains_nocase: [Bytes!]
    walletTokens_not: [Bytes!]
    walletTokens_not_contains: [Bytes!]
    walletTokens_not_contains_nocase: [Bytes!]
}

enum UserBalanceSnapshot_orderBy {
    farmBalances
    farms
    gaugeBalances
    gauges
    id
    timestamp
    user
    user__address
    user__id
    walletBalances
    walletTokens
}

type UserGaugeBalance {
    balance: BigDecimal!

    """
     Block number in which the balance was last modified
    """
    block: BigInt
    gauge: Gauge!
    id: ID!

    """
     Last modified timestamp in seconds
    """
    modified: BigInt

    """
     Hash of the last transaction that modified the balance
    """
    transaction: Bytes
    user: User!
}

input UserGaugeBalance_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [UserGaugeBalance_filter]
    balance: BigDecimal
    balance_gt: BigDecimal
    balance_gte: BigDecimal
    balance_in: [BigDecimal!]
    balance_lt: BigDecimal
    balance_lte: BigDecimal
    balance_not: BigDecimal
    balance_not_in: [BigDecimal!]
    block: BigInt
    block_gt: BigInt
    block_gte: BigInt
    block_in: [BigInt!]
    block_lt: BigInt
    block_lte: BigInt
    block_not: BigInt
    block_not_in: [BigInt!]
    gauge: String
    gauge_: Gauge_filter
    gauge_contains: String
    gauge_contains_nocase: String
    gauge_ends_with: String
    gauge_ends_with_nocase: String
    gauge_gt: String
    gauge_gte: String
    gauge_in: [String!]
    gauge_lt: String
    gauge_lte: String
    gauge_not: String
    gauge_not_contains: String
    gauge_not_contains_nocase: String
    gauge_not_ends_with: String
    gauge_not_ends_with_nocase: String
    gauge_not_in: [String!]
    gauge_not_starts_with: String
    gauge_not_starts_with_nocase: String
    gauge_starts_with: String
    gauge_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    modified: BigInt
    modified_gt: BigInt
    modified_gte: BigInt
    modified_in: [BigInt!]
    modified_lt: BigInt
    modified_lte: BigInt
    modified_not: BigInt
    modified_not_in: [BigInt!]
    or: [UserGaugeBalance_filter]
    transaction: Bytes
    transaction_contains: Bytes
    transaction_gt: Bytes
    transaction_gte: Bytes
    transaction_in: [Bytes!]
    transaction_lt: Bytes
    transaction_lte: Bytes
    transaction_not: Bytes
    transaction_not_contains: Bytes
    transaction_not_in: [Bytes!]
    user: String
    user_: User_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
}

enum UserGaugeBalance_orderBy {
    balance
    block
    gauge
    gauge__id
    gauge__symbol
    id
    modified
    transaction
    user
    user__address
    user__id
}

type UserMasterChefFarmBalance {
    balance: BigDecimal!
    farm: MasterChefFarm!
    id: ID!
    user: User!
}

input UserMasterChefFarmBalance_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [UserMasterChefFarmBalance_filter]
    balance: BigDecimal
    balance_gt: BigDecimal
    balance_gte: BigDecimal
    balance_in: [BigDecimal!]
    balance_lt: BigDecimal
    balance_lte: BigDecimal
    balance_not: BigDecimal
    balance_not_in: [BigDecimal!]
    farm: String
    farm_: MasterChefFarm_filter
    farm_contains: String
    farm_contains_nocase: String
    farm_ends_with: String
    farm_ends_with_nocase: String
    farm_gt: String
    farm_gte: String
    farm_in: [String!]
    farm_lt: String
    farm_lte: String
    farm_not: String
    farm_not_contains: String
    farm_not_contains_nocase: String
    farm_not_ends_with: String
    farm_not_ends_with_nocase: String
    farm_not_in: [String!]
    farm_not_starts_with: String
    farm_not_starts_with_nocase: String
    farm_starts_with: String
    farm_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [UserMasterChefFarmBalance_filter]
    user: String
    user_: User_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
}

enum UserMasterChefFarmBalance_orderBy {
    balance
    farm
    farm__id
    id
    user
    user__address
    user__id
}

type UserWalletBalance {
    """
     Current account balance
    """
    balance: BigDecimal!

    """
     Block number in which the balance was last modified
    """
    block: BigInt

    """
     Equals to: <accountAddress>-<tokenAddress>
    """
    id: ID!

    """
     Last modified timestamp in seconds
    """
    modified: BigInt

    """
     Token address
    """
    token: Token!

    """
     Hash of the last transaction that modified the balance
    """
    transaction: Bytes

    """
     Account address
    """
    user: User!
}

input UserWalletBalance_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    and: [UserWalletBalance_filter]
    balance: BigDecimal
    balance_gt: BigDecimal
    balance_gte: BigDecimal
    balance_in: [BigDecimal!]
    balance_lt: BigDecimal
    balance_lte: BigDecimal
    balance_not: BigDecimal
    balance_not_in: [BigDecimal!]
    block: BigInt
    block_gt: BigInt
    block_gte: BigInt
    block_in: [BigInt!]
    block_lt: BigInt
    block_lte: BigInt
    block_not: BigInt
    block_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    modified: BigInt
    modified_gt: BigInt
    modified_gte: BigInt
    modified_in: [BigInt!]
    modified_lt: BigInt
    modified_lte: BigInt
    modified_not: BigInt
    modified_not_in: [BigInt!]
    or: [UserWalletBalance_filter]
    token: String
    token_: Token_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
    transaction: Bytes
    transaction_contains: Bytes
    transaction_gt: Bytes
    transaction_gte: Bytes
    transaction_in: [Bytes!]
    transaction_lt: Bytes
    transaction_lte: Bytes
    transaction_not: Bytes
    transaction_not_contains: Bytes
    transaction_not_in: [Bytes!]
    user: String
    user_: User_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
}

enum UserWalletBalance_orderBy {
    balance
    block
    id
    modified
    token
    token__address
    token__decimals
    token__id
    token__name
    token__symbol
    transaction
    user
    user__address
    user__id
}

input User_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    address: Bytes
    address_contains: Bytes
    address_gt: Bytes
    address_gte: Bytes
    address_in: [Bytes!]
    address_lt: Bytes
    address_lte: Bytes
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    and: [User_filter]
    farmBalances_: UserMasterChefFarmBalance_filter
    farms: [String!]
    farms_contains: [String!]
    farms_contains_nocase: [String!]
    farms_not: [String!]
    farms_not_contains: [String!]
    farms_not_contains_nocase: [String!]
    gaugeBalances_: UserGaugeBalance_filter
    gauges: [Bytes!]
    gauges_contains: [Bytes!]
    gauges_contains_nocase: [Bytes!]
    gauges_not: [Bytes!]
    gauges_not_contains: [Bytes!]
    gauges_not_contains_nocase: [Bytes!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [User_filter]
    walletBalances_: UserWalletBalance_filter
    walletTokens: [Bytes!]
    walletTokens_contains: [Bytes!]
    walletTokens_contains_nocase: [Bytes!]
    walletTokens_not: [Bytes!]
    walletTokens_not_contains: [Bytes!]
    walletTokens_not_contains_nocase: [Bytes!]
}

enum User_orderBy {
    address
    farmBalances
    farms
    gaugeBalances
    gauges
    id
    walletBalances
    walletTokens
}

type _Block_ {
    """
    The hash of the block
    """
    hash: Bytes

    """
    The block number
    """
    number: Int!

    """
    The hash of the parent block
    """
    parentHash: Bytes

    """
    Integer representation of the timestamp stored in blocks for the chain
    """
    timestamp: Int
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
    """
    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!

    """
    The deployment ID
    """
    deployment: String!

    """
    If `true`, the subgraph encountered indexing errors at some past block
    """
    hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
    """
    Data will be returned even if the subgraph has indexing errors
    """
    allow

    """
    If the subgraph has indexing errors, data will be omitted. The default.
    """
    deny
}
