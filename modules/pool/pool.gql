extend type Query {
    """
    Returns one pool. If a user address is provided, the user balances for the given pool will also be returned.
    """
    poolGetPool(id: String!, chain: GqlChain, userAddress: String): GqlPoolBase!
    """
    Returns all pools for a given filter
    """
    poolGetPools(
        first: Int
        skip: Int
        orderBy: GqlPoolOrderBy
        orderDirection: GqlPoolOrderDirection
        where: GqlPoolFilter
        textSearch: String
    ): [GqlPoolMinimal!]!
    """
    Returns the number of pools for a given filter.
    """
    poolGetPoolsCount(
        first: Int
        skip: Int
        orderBy: GqlPoolOrderBy
        orderDirection: GqlPoolOrderDirection
        where: GqlPoolFilter
        textSearch: String
    ): Int!
    """
    Will de deprecated in favor of poolEvents
    """
    poolGetSwaps(first: Int, skip: Int, where: GqlPoolSwapFilter): [GqlPoolSwap!]!
    """
    Will de deprecated in favor of poolEvents
    """
    poolGetBatchSwaps(first: Int, skip: Int, where: GqlPoolSwapFilter): [GqlPoolBatchSwap!]!
    """
    Will de deprecated in favor of poolEvents
    """
    poolGetJoinExits(first: Int, skip: Int, where: GqlPoolJoinExitFilter): [GqlPoolJoinExit!]!
    """
    Will de deprecated in favor of poolGetFeaturedPools
    """
    poolGetFeaturedPoolGroups(chains: [GqlChain!]): [GqlPoolFeaturedPoolGroup!]!
    """
    Returns the list of featured pools for chains
    """
    poolGetFeaturedPools(chains: [GqlChain!]!): [GqlPoolFeaturedPool!]!
    """
    Gets all the snapshots for a given pool on a chain for a certain range
    """
    poolGetSnapshots(id: String!, chain: GqlChain, range: GqlPoolSnapshotDataRange!): [GqlPoolSnapshot!]!
    """
    Getting swap, add and remove events with range
    """
    poolGetEvents(
        range: GqlPoolEventsDataRange!
        poolId: String!
        chain: GqlChain!
        typeIn: [GqlPoolEventType!]!
        userAddress: String
    ): [GqlPoolEvent!]!
    """
    Getting swap, add and remove events with paging
    """
    poolEvents(first: Int, skip: Int, where: GqlPoolEventsFilter!): [GqlPoolEvent!]!
}

extend type Mutation {
    poolSyncAllPoolsFromSubgraph: [String!]!
    poolSyncNewPoolsFromSubgraph: [String!]!
    poolLoadOnChainDataForAllPools: String!
    poolLoadOnChainDataForPoolsWithActiveUpdates: String!
    poolUpdateLiquidityValuesForAllPools: String!
    poolUpdateVolumeAndFeeValuesForAllPools: String!
    poolSyncSwapsForLast48Hours: String!
    poolSyncSanityPoolData: String!
    poolUpdateAprs(chain: GqlChain!): String!
    poolSyncPoolAllTokensRelationship: String!
    poolReloadAllPoolAprs(chain: GqlChain!): String!
    poolSyncTotalShares: String!
    poolReloadStakingForAllPools(stakingTypes: [GqlPoolStakingType!]!): String!
    poolSyncStakingForPools: String!
    poolUpdateLiquidity24hAgoForAllPools: String!
    poolLoadSnapshotsForAllPools: String!
    poolLoadSnapshotsForPools(poolIds: [String!]!, reload: Boolean): String!
    poolSyncLatestSnapshotsForAllPools(daysToSync: Int): String!
    poolUpdateLifetimeValuesForAllPools: String!
    poolInitializeSnapshotsForPool(poolId: String!): String!
    poolSyncPool(poolId: String!): String!
    poolReloadAllTokenNestedPoolIds: String!
    poolBlackListAddPool(poolId: String!): String!
    poolBlackListRemovePool(poolId: String!): String!
    poolDeletePool(poolId: String!): String!
    poolInitOnChainDataForAllPools: String!
}

"""
The pool schema returned for poolGetPools (pool list query)
"""
type GqlPoolMinimal {
    """
    The pool id. This is equal to the address for vaultVersion 3 pools
    """
    id: ID!
    """
    The chain on which the pool is deployed
    """
    chain: GqlChain!
    """
    The vault version on which the pool is deployed, 2 or 3
    """
    vaultVersion: Int!
    """
    The name of the pool as per contract
    """
    name: String!
    """
    The token symbol of the pool as per contract
    """
    symbol: String!
    """
    The contract address of the pool.
    """
    address: Bytes!
    """
    The decimals of the BPT, usually 18
    """
    decimals: Int!
    """
    The wallet address of the owner of the pool. Pool owners can set certain properties like swapFees or AMP.
    """
    owner: Bytes
    """
    The factory contract address from which the pool was created.
    """
    factory: Bytes
    """
    The timestamp the pool was created.
    """
    createTime: Int!
    """
    Only returns main tokens, also known as leave tokens. Wont return any nested BPTs. Used for displaying the tokens that the pool consists of.
    """
    displayTokens: [GqlPoolTokenDisplay!]!
    """
    Returns all pool tokens, including any nested tokens and phantom BPTs
    """
    allTokens: [GqlPoolTokenExpanded!]!
    """
    Dynamic data such as token balances, swap fees or volume
    """
    dynamicData: GqlPoolDynamicData!
    """
    Staking options of this pool which emit additional rewards
    """
    staking: GqlPoolStaking
    """
    The pool type, such as weighted, stable, etc.
    """
    type: GqlPoolType!
    """
    The version of the pool type.
    """
    version: Int!
    """
    If a user address was provided in the query, the user balance is populated here
    """
    userBalance: GqlPoolUserBalance
}

"""
If a user address was provided in the query, the user balance is populated here
"""
type GqlPoolUserBalance {
    """
    Total balance (wallet + staked) as float
    """
    totalBalance: AmountHumanReadable!
    """
    Total balance (wallet + staked) in USD as float
    """
    totalBalanceUsd: Float!
    """
    The wallet balance (BPT in wallet) as float.
    """
    walletBalance: AmountHumanReadable!
    """
    The wallet balance (BPT in wallet) in USD as float.
    """
    walletBalanceUsd: Float!
    """
    The staked balance in either a gauge or farm as float.
    """
    stakedBalance: AmountHumanReadable!
    """
    The staked balance in either a gauge or farm in USD as float.
    """
    stakedBalanceUsd: Float!
}

"""
Supported pool types
"""
enum GqlPoolType {
    WEIGHTED
    STABLE
    META_STABLE
    PHANTOM_STABLE
    COMPOSABLE_STABLE
    ELEMENT
    UNKNOWN
    LIQUIDITY_BOOTSTRAPPING
    INVESTMENT
    GYRO
    GYRO3
    GYROE
    FX
}

"""
The base type as returned by poolGetPool (specific pool query)
"""
interface GqlPoolBase {
    """
    The pool id. This is equal to the address for vaultVersion 3 pools
    """
    id: ID!
    """
    The chain on which the pool is deployed
    """
    chain: GqlChain!
    """
    The vault version on which the pool is deployed, 2 or 3
    """
    vaultVersion: Int!
    """
    The pool type, such as weighted, stable, etc.
    """
    type: GqlPoolType!
    """
    The name of the pool as per contract
    """
    name: String!
    """
    The token symbol of the pool as per contract
    """
    symbol: String!
    """
    The contract address of the pool.
    """
    address: Bytes!
    """
    The decimals of the BPT, usually 18
    """
    decimals: Int!
    """
    The wallet address of the owner of the pool. Pool owners can set certain properties like swapFees or AMP.
    """
    owner: Bytes
    """
    The factory contract address from which the pool was created.
    """
    factory: Bytes
    """
    The timestamp the pool was created.
    """
    createTime: Int!
    """
    The version of the pool type.
    """
    version: Int!
    """
    Deprecated
    """
    investConfig: GqlPoolInvestConfig!
    """
    Deprecated
    """
    withdrawConfig: GqlPoolWithdrawConfig!
    """
    Only returns main tokens, also known as leave tokens. Wont return any nested BPTs. Used for displaying the tokens that the pool consists of.
    """
    displayTokens: [GqlPoolTokenDisplay!]!
    """
    Returns all pool tokens, including any nested tokens and phantom BPTs on one level.
    """
    allTokens: [GqlPoolTokenExpanded!]!
    """
    Returns all pool tokens, including BPTs and nested pools if there are any. Only one nested level deep.
    """
    poolTokens: [GqlPoolTokenDetail!]!
    """
    Dynamic data such as token balances, swap fees or volume
    """
    dynamicData: GqlPoolDynamicData!
    """
    Staking options of this pool which emit additional rewards
    """
    staking: GqlPoolStaking
    """
    If a user address was provided in the query, the user balance is populated here
    """
    userBalance: GqlPoolUserBalance
}

type GqlPoolDynamicData {
    poolId: ID!

    #fields that change rarely
    swapFee: BigDecimal!
    swapEnabled: Boolean!
    #fields that change often
    totalShares: BigDecimal!
    #data that has USD values
    totalLiquidity: BigDecimal!
    volume24h: BigDecimal!
    fees24h: BigDecimal!
    yieldCapture24h: BigDecimal!
    apr: GqlPoolApr!
    aprItems: [GqlPoolAprItem!]!

    isInRecoveryMode: Boolean!
    isPaused: Boolean!

    totalLiquidity24hAgo: BigDecimal!
    totalShares24hAgo: BigDecimal!
    volume48h: BigDecimal!
    fees48h: BigDecimal!
    yieldCapture48h: BigDecimal!

    lifetimeVolume: BigDecimal!
    lifetimeSwapFees: BigDecimal!
    holdersCount: BigInt!
    swapsCount: BigInt!

    sharePriceAth: BigDecimal!
    sharePriceAthTimestamp: Int!
    sharePriceAtl: BigDecimal!
    sharePriceAtlTimestamp: Int!

    totalLiquidityAth: BigDecimal!
    totalLiquidityAthTimestamp: Int!
    totalLiquidityAtl: BigDecimal!
    totalLiquidityAtlTimestamp: Int!

    volume24hAth: BigDecimal!
    volume24hAthTimestamp: Int!
    volume24hAtl: BigDecimal!
    volume24hAtlTimestamp: Int!

    fees24hAth: BigDecimal!
    fees24hAthTimestamp: Int!
    fees24hAtl: BigDecimal!
    fees24hAtlTimestamp: Int!
}

type GqlPoolInvestConfig {
    proportionalEnabled: Boolean!
    singleAssetEnabled: Boolean!
    options: [GqlPoolInvestOption!]!
}

type GqlPoolInvestOption {
    #we include the index because it is useful for constructing contract calls
    poolTokenIndex: Int!
    poolTokenAddress: String!

    # we use an array here for invest options where there are more than one option, but only one can be selected
    # - FTM/wFTM or ETH/wETH
    # - weighted boosted with nested composable stable (bb-yv-USD) where you can only invest with DAI or USDC, not both at the same time
    tokenOptions: [GqlPoolToken!]!
}

type GqlPoolWithdrawConfig {
    proportionalEnabled: Boolean!
    singleAssetEnabled: Boolean!
    options: [GqlPoolWithdrawOption!]!
}

type GqlPoolWithdrawOption {
    poolTokenIndex: Int!
    poolTokenAddress: String!
    tokenOptions: [GqlPoolToken!]!
}

enum GqlPoolNestingType {
    NO_NESTING
    HAS_SOME_PHANTOM_BPT
    HAS_ONLY_PHANTOM_BPT
}

type GqlPoolWeighted implements GqlPoolBase {
    id: ID!
    chain: GqlChain!
    vaultVersion: Int!
    name: String!
    symbol: String!
    address: Bytes!
    decimals: Int!
    owner: Bytes!
    factory: Bytes
    createTime: Int!
    investConfig: GqlPoolInvestConfig!
    withdrawConfig: GqlPoolWithdrawConfig!
    dynamicData: GqlPoolDynamicData!
    displayTokens: [GqlPoolTokenDisplay!]!
    allTokens: [GqlPoolTokenExpanded!]!
    poolTokens: [GqlPoolTokenDetail!]!

    """
    All tokens of the pool. If it is a nested pool, the nested pool is expanded with its own tokens again.
    """
    tokens: [GqlPoolTokenUnion!]! @deprecated(reason: "Use poolTokens instead")
    nestingType: GqlPoolNestingType!
    staking: GqlPoolStaking
    type: GqlPoolType!
    version: Int!

    userBalance: GqlPoolUserBalance
}

type GqlPoolGyro implements GqlPoolBase {
    id: ID!
    chain: GqlChain!
    vaultVersion: Int!
    name: String!
    type: GqlPoolType!
    symbol: String!
    address: Bytes!
    decimals: Int!
    owner: Bytes!
    factory: Bytes
    createTime: Int!
    investConfig: GqlPoolInvestConfig!
    withdrawConfig: GqlPoolWithdrawConfig!
    dynamicData: GqlPoolDynamicData!
    displayTokens: [GqlPoolTokenDisplay!]!
    allTokens: [GqlPoolTokenExpanded!]!
    poolTokens: [GqlPoolTokenDetail!]!

    alpha: String!
    beta: String!
    sqrtAlpha: String!
    sqrtBeta: String!
    root3Alpha: String!
    c: String!
    s: String!
    lambda: String!
    tauAlphaX: String!
    tauAlphaY: String!
    tauBetaX: String!
    tauBetaY: String!
    u: String!
    v: String!
    w: String!
    z: String!
    dSq: String!

    """
    All tokens of the pool. If it is a nested pool, the nested pool is expanded with its own tokens again.
    """
    tokens: [GqlPoolTokenUnion!]! @deprecated(reason: "Use poolTokens instead")
    nestingType: GqlPoolNestingType!
    staking: GqlPoolStaking
    version: Int!

    userBalance: GqlPoolUserBalance
}

type GqlPoolFx implements GqlPoolBase {
    alpha: String!
    beta: String!
    delta: String!
    epsilon: String!
    lambda: String!

    # Base pool
    id: ID!
    chain: GqlChain!
    vaultVersion: Int!
    type: GqlPoolType!
    version: Int!
    name: String!
    symbol: String!
    address: Bytes!
    decimals: Int!
    owner: Bytes
    factory: Bytes
    createTime: Int!
    investConfig: GqlPoolInvestConfig!
    withdrawConfig: GqlPoolWithdrawConfig!
    displayTokens: [GqlPoolTokenDisplay!]!
    allTokens: [GqlPoolTokenExpanded!]!
    poolTokens: [GqlPoolTokenDetail!]!

    dynamicData: GqlPoolDynamicData!
    staking: GqlPoolStaking
    userBalance: GqlPoolUserBalance
    """
    All tokens of the pool. If it is a nested pool, the nested pool is expanded with its own tokens again.
    """
    tokens: [GqlPoolTokenUnion!]! @deprecated(reason: "Use poolTokens instead")
}

type GqlPoolLiquidityBootstrapping implements GqlPoolBase {
    id: ID!
    chain: GqlChain!
    vaultVersion: Int!
    name: String!
    symbol: String!
    address: Bytes!
    decimals: Int!
    owner: Bytes!
    factory: Bytes
    createTime: Int!
    investConfig: GqlPoolInvestConfig!
    withdrawConfig: GqlPoolWithdrawConfig!
    dynamicData: GqlPoolDynamicData!
    displayTokens: [GqlPoolTokenDisplay!]!
    allTokens: [GqlPoolTokenExpanded!]!
    poolTokens: [GqlPoolTokenDetail!]!

    """
    All tokens of the pool. If it is a nested pool, the nested pool is expanded with its own tokens again.
    """
    tokens: [GqlPoolTokenUnion!]! @deprecated(reason: "Use poolTokens instead")
    nestingType: GqlPoolNestingType!
    staking: GqlPoolStaking
    type: GqlPoolType!
    version: Int!

    userBalance: GqlPoolUserBalance
}

type GqlPoolStable implements GqlPoolBase {
    id: ID!
    chain: GqlChain!
    vaultVersion: Int!
    name: String!
    symbol: String!
    address: Bytes!
    decimals: Int!
    owner: Bytes!
    factory: Bytes
    createTime: Int!
    investConfig: GqlPoolInvestConfig!
    withdrawConfig: GqlPoolWithdrawConfig!
    dynamicData: GqlPoolDynamicData!
    displayTokens: [GqlPoolTokenDisplay!]!
    allTokens: [GqlPoolTokenExpanded!]!
    poolTokens: [GqlPoolTokenDetail!]!

    tokens: [GqlPoolToken!]!
    amp: BigInt!
    staking: GqlPoolStaking
    type: GqlPoolType!
    version: Int!

    userBalance: GqlPoolUserBalance
}

type GqlPoolMetaStable implements GqlPoolBase {
    id: ID!
    chain: GqlChain!
    vaultVersion: Int!
    name: String!
    symbol: String!
    address: Bytes!
    decimals: Int!
    owner: Bytes!
    factory: Bytes
    createTime: Int!
    investConfig: GqlPoolInvestConfig!
    withdrawConfig: GqlPoolWithdrawConfig!
    dynamicData: GqlPoolDynamicData!
    displayTokens: [GqlPoolTokenDisplay!]!
    allTokens: [GqlPoolTokenExpanded!]!
    poolTokens: [GqlPoolTokenDetail!]!

    tokens: [GqlPoolToken!]! @deprecated(reason: "Use poolTokens instead")
    amp: BigInt!
    staking: GqlPoolStaking
    type: GqlPoolType!
    version: Int!

    userBalance: GqlPoolUserBalance
}

type GqlPoolComposableStable implements GqlPoolBase {
    id: ID!
    chain: GqlChain!
    vaultVersion: Int!
    name: String!
    symbol: String!
    address: Bytes!
    decimals: Int!
    owner: Bytes!
    factory: Bytes
    createTime: Int!
    investConfig: GqlPoolInvestConfig!
    withdrawConfig: GqlPoolWithdrawConfig!
    dynamicData: GqlPoolDynamicData!
    displayTokens: [GqlPoolTokenDisplay!]!
    allTokens: [GqlPoolTokenExpanded!]!
    poolTokens: [GqlPoolTokenDetail!]!

    """
    All tokens of the pool. If it is a nested pool, the nested pool is expanded with its own tokens again.
    """
    tokens: [GqlPoolTokenUnion!]! @deprecated(reason: "Use poolTokens instead")
    nestingType: GqlPoolNestingType!
    amp: BigInt!
    staking: GqlPoolStaking
    bptPriceRate: BigDecimal!
    type: GqlPoolType!
    version: Int!

    userBalance: GqlPoolUserBalance
}

type GqlPoolElement implements GqlPoolBase {
    id: ID!
    chain: GqlChain!
    vaultVersion: Int!
    name: String!
    symbol: String!
    address: Bytes!
    decimals: Int!
    owner: Bytes!
    factory: Bytes
    createTime: Int!
    investConfig: GqlPoolInvestConfig!
    withdrawConfig: GqlPoolWithdrawConfig!
    dynamicData: GqlPoolDynamicData!
    displayTokens: [GqlPoolTokenDisplay!]!
    allTokens: [GqlPoolTokenExpanded!]!
    poolTokens: [GqlPoolTokenDetail!]!
    tokens: [GqlPoolToken!]! @deprecated(reason: "Use poolTokens instead")

    #element specific fields
    unitSeconds: BigInt!
    principalToken: Bytes!
    baseToken: Bytes!
    staking: GqlPoolStaking
    type: GqlPoolType!
    version: Int!

    userBalance: GqlPoolUserBalance
}

type GqlPoolComposableStableNested {
    id: ID!
    name: String!
    symbol: String!
    address: Bytes!
    owner: Bytes!
    factory: Bytes
    createTime: Int!
    tokens: [GqlPoolTokenComposableStableNestedUnion!]! @deprecated(reason: "Use poolTokens instead")
    nestingType: GqlPoolNestingType!

    totalShares: BigDecimal!
    totalLiquidity: BigDecimal!
    amp: BigInt!
    swapFee: BigDecimal!
    bptPriceRate: BigDecimal!

    type: GqlPoolType!
    version: Int!
}

union GqlPoolUnion =
      GqlPoolWeighted
    | GqlPoolStable
    | GqlPoolMetaStable
    | GqlPoolComposableStable
    | GqlPoolElement
    | GqlPoolLiquidityBootstrapping
    | GqlPoolGyro
    | GqlPoolFx
union GqlPoolNestedUnion = GqlPoolComposableStableNested

union GqlPoolTokenUnion = GqlPoolToken | GqlPoolTokenComposableStable
union GqlPoolTokenComposableStableNestedUnion = GqlPoolToken

"""
All info on the pool token. It will also include the nested pool if the token is a BPT. It will only support 1 level of nesting.
A second (unsupported) level of nesting is shown by having hasNestedPool = true but nestedPool = null.
"""
type GqlPoolTokenDetail {
    """
    Id of the token. A combination of pool id and token address.
    """
    id: ID!
    """
    Address of the pool token.
    """
    address: String!
    """
    Decimals of the pool token.
    """
    decimals: Int!
    """
    Name of the pool token.
    """
    name: String!
    """
    Symbol of the pool token.
    """
    symbol: String!
    """
    Index of the pool token in the pool as returned by the vault.
    """
    index: Int!
    """
    Balance of the pool token inside the pool.
    """
    balance: BigDecimal!
    """
    If it is an appreciating token, it shows the current price rate. 1 otherwise.
    """
    priceRate: BigDecimal!
    """
    The address of the price rate provider.
    """
    priceRateProvider: String
    """
    Additional data for the price rate provider, such as reviews or warnings.
    """
    priceRateProviderData: GqlPriceRateProviderData
    """
    The weight of the token in the pool if it is a weighted pool, null otherwise
    """
    weight: BigDecimal
    """
    Indicates whether this token is a BPT and therefor has a nested pool.
    """
    hasNestedPool: Boolean!
    """
    Additional data for the nested pool if the token is a BPT. Null otherwise.
    """
    nestedPool: GqlNestedPool
}
"""
All info on the nested pool if the token is a BPT. It will only support 1 level of nesting.
"""
type GqlNestedPool {
    """
    Unique identifier of the pool.
    """
    id: ID!
    """
    Name of the pool.
    """
    name: String!
    """
    Symbol of the pool.
    """
    symbol: String!
    """
    Address of the pool.
    """
    address: Bytes!
    """
    Type of the pool.
    """
    type: GqlPoolType!
    """
    Version of the pool.
    """
    version: Int!
    """
    Address of the pool's owner.
    """
    owner: Bytes!
    """
    Address of the factory contract that created the pool, if applicable.
    """
    factory: Bytes
    """
    Timestamp of when the pool was created.
    """
    createTime: Int!
    """
    List of all tokens in the pool.
    """
    tokens: [GqlPoolTokenDetail!]!
    """
    Total number of shares in the pool.
    """
    totalShares: BigDecimal!
    """
    Total liquidity in the pool in USD.
    """
    totalLiquidity: BigDecimal!
    """
    Number of shares of the parent pool in the nested pool.
    """
    nestedShares: BigDecimal!
    """
    Total liquidity of the parent pool in the nested pool in USD.
    """
    nestedLiquidity: BigDecimal!
    """
    Percentage of the parents pool shares inside the nested pool.
    """
    nestedPercentage: BigDecimal!
    """
    Fee charged for swapping tokens in the pool as %. 0.01 -> 0.01%
    """
    swapFee: BigDecimal!
    """
    Price rate of the Balancer Pool Token (BPT).
    """
    bptPriceRate: BigDecimal!
}

interface GqlPoolTokenBase {
    id: ID!
    address: String!
    balance: BigDecimal!
    decimals: Int!
    name: String!
    symbol: String!
    index: Int!

    priceRate: BigDecimal!
    priceRateProvider: String
    weight: BigDecimal
    #the total balance in the pool, regardless of nesting
    totalBalance: BigDecimal!
}

type GqlPoolToken implements GqlPoolTokenBase {
    id: ID!
    address: String!
    decimals: Int!
    name: String!
    symbol: String!
    index: Int!

    #dynamic data
    balance: BigDecimal!
    priceRate: BigDecimal!
    priceRateProvider: String
    weight: BigDecimal
    #the total balance in the pool, regardless of nesting
    totalBalance: BigDecimal!
}

type GqlPoolTokenComposableStable implements GqlPoolTokenBase {
    id: ID!
    address: String!
    balance: BigDecimal!
    decimals: Int!
    name: String!
    symbol: String!
    index: Int!
    priceRate: BigDecimal!
    priceRateProvider: String
    weight: BigDecimal
    #the total balance in the pool, regardless of nesting
    totalBalance: BigDecimal!

    pool: GqlPoolComposableStableNested!
}

type GqlPoolStableComposablePoolData {
    id: ID!
    address: String!
    symbol: String!
    tokens: [GqlPoolToken!]!
    totalSupply: String!
    balance: String!
}

type GqlPoolApr {
    apr: GqlPoolAprValue!
    swapApr: BigDecimal! # we make the assumption swap apr will never have a range
    nativeRewardApr: GqlPoolAprValue!
    thirdPartyApr: GqlPoolAprValue!
    items: [GqlBalancePoolAprItem!]!
    hasRewardApr: Boolean!
}

union GqlPoolAprValue = GqlPoolAprRange | GqlPoolAprTotal

type GqlPoolAprRange {
    min: BigDecimal!
    max: BigDecimal!
}

type GqlPoolAprTotal {
    total: BigDecimal!
}

input GqlPoolTimePeriod {
    gt: Int
    lt: Int
}

enum GqlPoolOrderBy {
    totalLiquidity
    totalShares
    volume24h
    fees24h
    apr
    userbalanceUsd
}

enum GqlPoolOrderDirection {
    asc
    desc
}

input GqlPoolFilter {
    categoryIn: [GqlPoolFilterCategory!]
    categoryNotIn: [GqlPoolFilterCategory!]
    tokensIn: [String!]
    tokensNotIn: [String!]
    poolTypeIn: [GqlPoolType!]
    poolTypeNotIn: [GqlPoolType!]
    idIn: [String!]
    idNotIn: [String!]
    filterIn: [String!]
    filterNotIn: [String!]
    chainIn: [GqlChain!]
    chainNotIn: [GqlChain!]
    createTime: GqlPoolTimePeriod
    userAddress: String
    vaultVersionIn: [Int!]
    minTvl: Float
}

enum GqlPoolFilterCategory {
    INCENTIVIZED
    BLACK_LISTED
}

type GqlPoolTokenExpanded {
    id: ID!
    address: String!
    name: String!
    symbol: String!
    decimals: Int!
    weight: String
    isNested: Boolean!
    isPhantomBpt: Boolean!
    isMainToken: Boolean!
}

type GqlPoolSwap {
    id: ID!
    chain: GqlChain!
    poolId: String!
    userAddress: String!
    tokenIn: String!
    tokenOut: String!
    tokenAmountIn: String!
    tokenAmountOut: String!
    timestamp: Int!
    tx: String!
    valueUSD: Float!
}

type GqlPoolBatchSwap {
    id: ID!
    chain: GqlChain!
    userAddress: String!
    tokenIn: String!
    tokenOut: String!
    tokenAmountIn: String!
    tokenAmountOut: String!
    tokenInPrice: Float!
    tokenOutPrice: Float!
    timestamp: Int!
    tx: String!
    valueUSD: Float!
    swaps: [GqlPoolBatchSwapSwap!]!
}

type GqlPoolBatchSwapSwap {
    id: ID!
    pool: GqlPoolMinimal!
    userAddress: String!
    tokenIn: String!
    tokenOut: String!
    tokenAmountIn: String!
    tokenAmountOut: String!
    timestamp: Int!
    tx: String!
    valueUSD: Float!
}

type GqlPoolBatchSwapPool {
    id: ID!
    tokens: [String!]!
}

input GqlPoolSwapFilter {
    tokenInIn: [String!]
    tokenOutIn: [String!]
    poolIdIn: [String!]
    chainIn: [GqlChain!]
}

input GqlPoolJoinExitFilter {
    poolIdIn: [String!]
    chainIn: [GqlChain!]
}

type GqlPoolJoinExit {
    id: ID!
    chain: GqlChain!
    type: GqlPoolJoinExitType!
    sender: String!
    poolId: String!
    timestamp: Int!
    valueUSD: String
    tx: String!
    amounts: [GqlPoolJoinExitAmount!]!
}

enum GqlPoolJoinExitType {
    Join
    Exit
}

type GqlPoolJoinExitAmount {
    address: String!
    amount: String!
}

type GqlPoolAprItem {
    id: ID!
    title: String!
    apr: BigDecimal!
    type: GqlPoolAprItemType!
}

enum GqlPoolAprItemType {
    SWAP_FEE
    IB_YIELD
    STAKING
    LOCKING
    VOTING
    VEBAL_BOOST
    MABEETS_BOOST
    AURA
}

type GqlBalancePoolAprItem {
    id: ID!
    title: String!
    apr: GqlPoolAprValue!
    subItems: [GqlBalancePoolAprSubItem!]
}

type GqlBalancePoolAprSubItem {
    id: ID!
    title: String!
    apr: GqlPoolAprValue!
}

input GqlUserSwapVolumeFilter {
    tokenInIn: [String!]
    tokenOutIn: [String!]
    poolIdIn: [String!]
}

type GqlPoolUserSwapVolume {
    userAddress: String!
    swapVolumeUSD: BigDecimal!
}

type GqlPoolFeaturedPool {
    poolId: ID!
    primary: Boolean!
    pool: GqlPoolBase!
    description: String!
}

type GqlPoolFeaturedPoolGroup {
    id: ID!
    title: String!
    icon: String!
    items: [GqlPoolFeaturedPoolGroupItem!]!
}

union GqlPoolFeaturedPoolGroupItem = GqlPoolMinimal | GqlFeaturePoolGroupItemExternalLink

type GqlFeaturePoolGroupItemExternalLink {
    id: ID!
    image: String!
    buttonText: String!
    buttonUrl: String!
}

enum GqlPoolEventsDataRange {
    SEVEN_DAYS
    THIRTY_DAYS
    NINETY_DAYS
}

enum GqlPoolSnapshotDataRange {
    THIRTY_DAYS
    NINETY_DAYS
    ONE_HUNDRED_EIGHTY_DAYS
    ONE_YEAR
    ALL_TIME
}

type GqlPoolSnapshot {
    id: ID!
    chain: GqlChain!
    poolId: String!
    timestamp: Int!
    totalLiquidity: String!
    volume24h: String!
    fees24h: String!
    totalShares: String!
    totalSwapVolume: String!
    totalSwapFee: String!
    swapsCount: String!
    holdersCount: String!
    sharePrice: String!
    amounts: [String!]!
}

type GqlPoolTokenDisplay {
    id: ID!
    address: String!
    name: String!
    symbol: String!
    weight: BigDecimal
    nestedTokens: [GqlPoolTokenDisplay!]
}

type GqlPoolStaking {
    id: ID!
    chain: GqlChain!
    type: GqlPoolStakingType!
    address: String!
    gauge: GqlPoolStakingGauge
    farm: GqlPoolStakingMasterChefFarm
    reliquary: GqlPoolStakingReliquaryFarm
}

enum GqlPoolStakingType {
    GAUGE
    MASTER_CHEF
    FRESH_BEETS
    RELIQUARY
}

enum GqlPoolStakingGaugeStatus {
    KILLED
    ACTIVE
    PREFERRED
}

type GqlPoolStakingGauge {
    id: ID!
    gaugeAddress: String!
    rewards: [GqlPoolStakingGaugeReward!]!
    status: GqlPoolStakingGaugeStatus!
    version: Int!
    workingSupply: String!
    # There can be more than one gauge per pool, but only one preferred. For simplicity of handling, we focus on
    # the primary gauge.
    otherGauges: [GqlPoolStakingOtherGauge!]
}

type GqlPoolStakingGaugeReward {
    id: ID!
    tokenAddress: String!
    rewardPerSecond: String!
}

type GqlPoolStakingOtherGauge {
    id: ID!
    gaugeAddress: String!
    status: GqlPoolStakingGaugeStatus!
    version: Int!
    rewards: [GqlPoolStakingGaugeReward!]!
}

type GqlPoolStakingMasterChefFarm {
    id: ID!
    beetsPerBlock: String!
    rewarders: [GqlPoolStakingFarmRewarder!]
}

type GqlPoolStakingFarmRewarder {
    id: ID!
    address: String!
    tokenAddress: String!
    rewardPerSecond: String!
}

type GqlPoolStakingReliquaryFarm {
    id: ID!
    beetsPerSecond: String!
    totalBalance: String!
    totalWeightedBalance: String!
    levels: [GqlPoolStakingReliquaryFarmLevel!]
}

type GqlPoolStakingReliquaryFarmLevel {
    id: ID!
    level: Int!
    balance: BigDecimal!
    requiredMaturity: Int!
    allocationPoints: Int!
    apr: BigDecimal!
}

type GqlReliquaryFarmSnapshot {
    id: ID!
    farmId: String!
    timestamp: Int!
    relicCount: String!
    userCount: String!
    totalBalance: String!
    dailyDeposited: String!
    dailyWithdrawn: String!
    totalLiquidity: String!
    levelBalances: [GqlReliquaryFarmLevelSnapshot!]!
    tokenBalances: [GqlReliquaryTokenBalanceSnapshot!]!
}

type GqlReliquaryTokenBalanceSnapshot {
    id: ID!
    address: String!
    balance: String!
    symbol: String!
    name: String!
    decimals: Int!
}
type GqlReliquaryFarmLevelSnapshot {
    id: ID!
    level: String!
    balance: String!
}

type GqlRelicSnapshot {
    relicId: Int!
    farmId: String!
    balance: String!
    entryTimestamp: Int!
    level: Int!
}

enum GqlPoolEventType {
    ADD
    REMOVE
    SWAP
}

input GqlPoolEventsFilter {
    chain: GqlChain!
    poolId: String!
    typeIn: [GqlPoolEventType]
    userAddress: String
    range: GqlPoolEventsDataRange
}

type GqlPoolEventAmount {
    address: String!
    amount: String!
    valueUSD: Float!
}

interface GqlPoolEvent {
    chain: GqlChain!
    id: ID!
    tx: String!
    logIndex: Int!
    blockNumber: Int!
    blockTimestamp: Int!
    type: GqlPoolEventType!
    sender: String!
    userAddress: String!
    poolId: String!
    timestamp: Int!
    valueUSD: Float!
}

type GqlPoolAddRemoveEventV3 implements GqlPoolEvent {
    chain: GqlChain!
    id: ID!
    tx: String!
    logIndex: Int!
    blockNumber: Int!
    blockTimestamp: Int!
    type: GqlPoolEventType!
    sender: String!
    userAddress: String!
    poolId: String!
    timestamp: Int!
    valueUSD: Float!
    tokens: [GqlPoolEventAmount!]!
}

type GqlPoolSwapEventV3 implements GqlPoolEvent {
    chain: GqlChain!
    id: ID!
    tx: String!
    logIndex: Int!
    blockNumber: Int!
    blockTimestamp: Int!
    type: GqlPoolEventType!
    sender: String!
    userAddress: String!
    poolId: String!
    timestamp: Int!
    valueUSD: Float!
    tokenIn: GqlPoolEventAmount!
    tokenOut: GqlPoolEventAmount!
}
