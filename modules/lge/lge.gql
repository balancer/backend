input GqlLgeCreateInput {
    id: ID!
    address: String!
    name: String!
    websiteUrl: String!
    tokenIconUrl: String!
    bannerImageUrl: String!
    twitterUrl: String!
    mediumUrl: String!
    discordUrl: String!
    telegramUrl: String!
    description: String!
    startTimestamp: Int!
    endTimestamp: Int!
    tokenAddress: String!
    tokenAmount: String!
    tokenStartWeight: Int!
    tokenEndWeight: Int!
    collateralAddress: String!
    collateralAmount: String!
    collateralStartWeight: Int!
    collateralEndWeight: Int!
    swapFee: String!
}

input GqlLgeUpdateInput {
    id: ID!
    name: String!
    description: String!
    websiteUrl: String!
    tokenIconUrl: String!
    twitterUrl: String!
    mediumUrl: String!
    discordUrl: String!
    telegramUrl: String!
}

type GqlLge {
    id: ID!
    address: String!
    name: String!
    websiteUrl: String!
    tokenIconUrl: String!
    bannerImageUrl: String!
    twitterUrl: String!
    mediumUrl: String!
    discordUrl: String!
    telegramUrl: String!
    description: String!
    startTimestamp: Int!
    endTimestamp: Int!
    tokenAddress: String!
    tokenDecimals: Int!
    tokenAmount: String!
    tokenStartWeight: Int!
    tokenEndWeight: Int!
    collateralAddress: String!
    collateralDecimals: Int!
    collateralAmount: String!
    collateralStartWeight: Int!
    collateralEndWeight: Int!
    swapFee: String!
    adminAddress: String!
    adminIsMultisig: Boolean!
}

type GqlLgePriceData {
    timestamp: Int!
    price: Float!
    type: String!
}

extend type Query {
    lges: [GqlLge!]!
    lge(id: ID!): GqlLge!
    getLgeChartData(id: ID!, steps: Int!): [GqlLgePriceData]!
}

# since the lge is now in the db, think about how to update lge details (website, banner etc)
extend type Mutation {
    lgeCreate(lge: GqlLgeCreateInput!, signature: String!): GqlLge!
    #LgeUpdate(Lge: GqlLgeUpdateInput!, signature: String!): GqlLge!
}
